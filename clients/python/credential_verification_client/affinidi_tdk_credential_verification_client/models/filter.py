# coding: utf-8

"""
    VerificationService

    Affinidi VerificationService Structure

    The version of the OpenAPI document: 1.0.0
    Contact: info@affinidi.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Any, Dict, List, Optional
from pydantic import BaseModel, Field, StrictInt, StrictStr, conlist
from affinidi_tdk_credential_verification_client.models.filter_const import FilterConst

class Filter(BaseModel):
    """
    Filter
    """
    const: Optional[FilterConst] = Field(None, alias="_const")
    enum: Optional[conlist(FilterConst)] = Field(None, alias="_enum")
    exclusive_minimum: Optional[FilterConst] = Field(None, alias="exclusiveMinimum")
    exclusive_maximum: Optional[FilterConst] = Field(None, alias="exclusiveMaximum")
    format: Optional[StrictStr] = None
    format_maximum: Optional[StrictStr] = Field(None, alias="formatMaximum")
    format_minimum: Optional[StrictStr] = Field(None, alias="formatMinimum")
    format_exclusive_maximum: Optional[StrictStr] = Field(None, alias="formatExclusiveMaximum")
    format_exclusive_minimum: Optional[StrictStr] = Field(None, alias="formatExclusiveMinimum")
    min_length: Optional[StrictInt] = Field(None, alias="minLength")
    max_length: Optional[StrictInt] = Field(None, alias="maxLength")
    minimum: Optional[FilterConst] = None
    maximum: Optional[FilterConst] = None
    var_not: Optional[Dict[str, Any]] = Field(None, alias="not")
    pattern: Optional[StrictStr] = None
    contains: Optional[Filter] = None
    items: Optional[FilterItems] = None
    type: Optional[StrictStr] = None
    __properties = ["_const", "_enum", "exclusiveMinimum", "exclusiveMaximum", "format", "formatMaximum", "formatMinimum", "formatExclusiveMaximum", "formatExclusiveMinimum", "minLength", "maxLength", "minimum", "maximum", "not", "pattern", "contains", "items", "type"]

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Filter:
        """Create an instance of Filter from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of const
        if self.const:
            _dict['_const'] = self.const.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in enum (list)
        _items = []
        if self.enum:
            for _item in self.enum:
                if _item:
                    _items.append(_item.to_dict())
            _dict['_enum'] = _items
        # override the default output from pydantic by calling `to_dict()` of exclusive_minimum
        if self.exclusive_minimum:
            _dict['exclusiveMinimum'] = self.exclusive_minimum.to_dict()
        # override the default output from pydantic by calling `to_dict()` of exclusive_maximum
        if self.exclusive_maximum:
            _dict['exclusiveMaximum'] = self.exclusive_maximum.to_dict()
        # override the default output from pydantic by calling `to_dict()` of minimum
        if self.minimum:
            _dict['minimum'] = self.minimum.to_dict()
        # override the default output from pydantic by calling `to_dict()` of maximum
        if self.maximum:
            _dict['maximum'] = self.maximum.to_dict()
        # override the default output from pydantic by calling `to_dict()` of contains
        if self.contains:
            _dict['contains'] = self.contains.to_dict()
        # override the default output from pydantic by calling `to_dict()` of items
        if self.items:
            _dict['items'] = self.items.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> Filter:
        """Create an instance of Filter from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return Filter.parse_obj(obj)

        _obj = Filter.parse_obj({
            "const": FilterConst.from_dict(obj.get("_const")) if obj.get("_const") is not None else None,
            "enum": [FilterConst.from_dict(_item) for _item in obj.get("_enum")] if obj.get("_enum") is not None else None,
            "exclusive_minimum": FilterConst.from_dict(obj.get("exclusiveMinimum")) if obj.get("exclusiveMinimum") is not None else None,
            "exclusive_maximum": FilterConst.from_dict(obj.get("exclusiveMaximum")) if obj.get("exclusiveMaximum") is not None else None,
            "format": obj.get("format"),
            "format_maximum": obj.get("formatMaximum"),
            "format_minimum": obj.get("formatMinimum"),
            "format_exclusive_maximum": obj.get("formatExclusiveMaximum"),
            "format_exclusive_minimum": obj.get("formatExclusiveMinimum"),
            "min_length": obj.get("minLength"),
            "max_length": obj.get("maxLength"),
            "minimum": FilterConst.from_dict(obj.get("minimum")) if obj.get("minimum") is not None else None,
            "maximum": FilterConst.from_dict(obj.get("maximum")) if obj.get("maximum") is not None else None,
            "var_not": obj.get("not"),
            "pattern": obj.get("pattern"),
            "contains": Filter.from_dict(obj.get("contains")) if obj.get("contains") is not None else None,
            "items": FilterItems.from_dict(obj.get("items")) if obj.get("items") is not None else None,
            "type": obj.get("type")
        })
        return _obj

from affinidi_tdk_credential_verification_client.models.filter_items import FilterItems
Filter.update_forward_refs()

