/* tslint:disable */
/* eslint-disable */
/**
 * VerificationService
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: info@affinidi.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration'
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios'
import globalAxios from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common'
import type { RequestArgs } from './base'
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  BaseAPI,
  RequiredError,
  operationServerMap,
} from './base'

/**
 *
 * @export
 * @interface Constraints
 */
export interface Constraints {
  /**
   *
   * @type {string}
   * @memberof Constraints
   */
  limit_disclosure?: ConstraintsLimitDisclosureEnum
  /**
   *
   * @type {ConstraintsStatuses}
   * @memberof Constraints
   */
  statuses?: ConstraintsStatuses
  /**
   *
   * @type {Array<Field>}
   * @memberof Constraints
   */
  fields?: Array<Field>
  /**
   *
   * @type {string}
   * @memberof Constraints
   */
  subject_is_issuer?: ConstraintsSubjectIsIssuerEnum
  /**
   *
   * @type {Array<HolderSubject>}
   * @memberof Constraints
   */
  is_holder?: Array<HolderSubject>
  /**
   *
   * @type {Array<HolderSubject>}
   * @memberof Constraints
   */
  same_subject?: Array<HolderSubject>
}

export const ConstraintsLimitDisclosureEnum = {
  Required: 'required',
  Preferred: 'preferred',
} as const

export type ConstraintsLimitDisclosureEnum =
  (typeof ConstraintsLimitDisclosureEnum)[keyof typeof ConstraintsLimitDisclosureEnum]
export const ConstraintsSubjectIsIssuerEnum = {
  Required: 'required',
  Preferred: 'preferred',
} as const

export type ConstraintsSubjectIsIssuerEnum =
  (typeof ConstraintsSubjectIsIssuerEnum)[keyof typeof ConstraintsSubjectIsIssuerEnum]

/**
 *
 * @export
 * @interface ConstraintsStatuses
 */
export interface ConstraintsStatuses {
  /**
   *
   * @type {PdStatus}
   * @memberof ConstraintsStatuses
   */
  active?: PdStatus
  /**
   *
   * @type {PdStatus}
   * @memberof ConstraintsStatuses
   */
  suspended?: PdStatus
  /**
   *
   * @type {PdStatus}
   * @memberof ConstraintsStatuses
   */
  revoked?: PdStatus
}
/**
 *
 * @export
 * @interface Descriptor
 */
export interface Descriptor {
  /**
   *
   * @type {string}
   * @memberof Descriptor
   */
  id: string
  /**
   *
   * @type {string}
   * @memberof Descriptor
   */
  path: string
  /**
   *
   * @type {NestedDescriptor}
   * @memberof Descriptor
   */
  path_nested?: NestedDescriptor
  /**
   *
   * @type {string}
   * @memberof Descriptor
   */
  format: string
}
/**
 * Detail of the error
 * @export
 * @interface ErrorDetail
 */
export interface ErrorDetail {
  /**
   * Error detail message
   * @type {string}
   * @memberof ErrorDetail
   */
  message?: string
}
/**
 *
 * @export
 * @interface EvaluateVpOutput
 */
export interface EvaluateVpOutput {
  /**
   *
   * @type {boolean}
   * @memberof EvaluateVpOutput
   */
  result: boolean
  /**
   *
   * @type {Array<string>}
   * @memberof EvaluateVpOutput
   */
  errors: Array<string>
}
/**
 *
 * @export
 * @interface Field
 */
export interface Field {
  /**
   *
   * @type {string}
   * @memberof Field
   */
  id?: string
  /**
   *
   * @type {Array<string>}
   * @memberof Field
   */
  path?: Array<string>
  /**
   *
   * @type {string}
   * @memberof Field
   */
  purpose?: string
  /**
   *
   * @type {Filter}
   * @memberof Field
   */
  filter?: Filter
  /**
   *
   * @type {string}
   * @memberof Field
   */
  predicate?: FieldPredicateEnum
}

export const FieldPredicateEnum = {
  Required: 'required',
  Preferred: 'preferred',
} as const

export type FieldPredicateEnum =
  (typeof FieldPredicateEnum)[keyof typeof FieldPredicateEnum]

/**
 *
 * @export
 * @interface Filter
 */
export interface Filter {
  /**
   *
   * @type {FilterConst}
   * @memberof Filter
   */
  _const?: FilterConst
  /**
   *
   * @type {Array<FilterConst>}
   * @memberof Filter
   */
  _enum?: Array<FilterConst>
  /**
   *
   * @type {FilterConst}
   * @memberof Filter
   */
  exclusiveMinimum?: FilterConst
  /**
   *
   * @type {FilterConst}
   * @memberof Filter
   */
  exclusiveMaximum?: FilterConst
  /**
   *
   * @type {string}
   * @memberof Filter
   */
  format?: string
  /**
   *
   * @type {string}
   * @memberof Filter
   */
  formatMaximum?: string
  /**
   *
   * @type {string}
   * @memberof Filter
   */
  formatMinimum?: string
  /**
   *
   * @type {string}
   * @memberof Filter
   */
  formatExclusiveMaximum?: string
  /**
   *
   * @type {string}
   * @memberof Filter
   */
  formatExclusiveMinimum?: string
  /**
   *
   * @type {number}
   * @memberof Filter
   */
  minLength?: number
  /**
   *
   * @type {number}
   * @memberof Filter
   */
  maxLength?: number
  /**
   *
   * @type {FilterConst}
   * @memberof Filter
   */
  minimum?: FilterConst
  /**
   *
   * @type {FilterConst}
   * @memberof Filter
   */
  maximum?: FilterConst
  /**
   *
   * @type {object}
   * @memberof Filter
   */
  not?: object
  /**
   *
   * @type {string}
   * @memberof Filter
   */
  pattern?: string
  /**
   *
   * @type {Filter}
   * @memberof Filter
   */
  contains?: Filter
  /**
   *
   * @type {FilterItems}
   * @memberof Filter
   */
  items?: FilterItems
  /**
   *
   * @type {string}
   * @memberof Filter
   */
  type?: string
}
/**
 * @type FilterConst
 * @export
 */
export type FilterConst = number | string

/**
 * @type FilterItems
 * @export
 */
export type FilterItems = Array<Filter> | Filter

/**
 *
 * @export
 * @interface Format
 */
export interface Format {
  /**
   *
   * @type {JwtObject}
   * @memberof Format
   */
  jwt?: JwtObject
  /**
   *
   * @type {JwtObject}
   * @memberof Format
   */
  jwt_vc?: JwtObject
  /**
   *
   * @type {JwtObject}
   * @memberof Format
   */
  jwt_vp?: JwtObject
  /**
   *
   * @type {LdpObject}
   * @memberof Format
   */
  ldp?: LdpObject
  /**
   *
   * @type {LdpObject}
   * @memberof Format
   */
  ldp_vc?: LdpObject
  /**
   *
   * @type {LdpObject}
   * @memberof Format
   */
  ldp_vp?: LdpObject
}
/**
 *
 * @export
 * @interface HolderSubject
 */
export interface HolderSubject {
  /**
   *
   * @type {Array<string>}
   * @memberof HolderSubject
   */
  field_id: Array<string>
  /**
   *
   * @type {string}
   * @memberof HolderSubject
   */
  directive: HolderSubjectDirectiveEnum
}

export const HolderSubjectDirectiveEnum = {
  Required: 'required',
  Preferred: 'preferred',
} as const

export type HolderSubjectDirectiveEnum =
  (typeof HolderSubjectDirectiveEnum)[keyof typeof HolderSubjectDirectiveEnum]

/**
 *
 * @export
 * @interface InputDescriptor
 */
export interface InputDescriptor {
  /**
   *
   * @type {string}
   * @memberof InputDescriptor
   */
  id: string
  /**
   *
   * @type {Constraints}
   * @memberof InputDescriptor
   */
  constraints: Constraints
  /**
   *
   * @type {string}
   * @memberof InputDescriptor
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof InputDescriptor
   */
  purpose?: string
  /**
   *
   * @type {Format}
   * @memberof InputDescriptor
   */
  format?: Format
  /**
   *
   * @type {Array<string>}
   * @memberof InputDescriptor
   */
  group?: Array<string>
}
/**
 *
 * @export
 * @interface InvalidParameterError
 */
export interface InvalidParameterError {
  /**
   *
   * @type {string}
   * @memberof InvalidParameterError
   */
  name: InvalidParameterErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof InvalidParameterError
   */
  message: InvalidParameterErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof InvalidParameterError
   */
  httpStatusCode: InvalidParameterErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof InvalidParameterError
   */
  traceId: string
  /**
   *
   * @type {Array<NotFoundErrorDetailsInner>}
   * @memberof InvalidParameterError
   */
  details?: Array<NotFoundErrorDetailsInner>
}

export const InvalidParameterErrorNameEnum = {
  InvalidParameterError: 'InvalidParameterError',
} as const

export type InvalidParameterErrorNameEnum =
  (typeof InvalidParameterErrorNameEnum)[keyof typeof InvalidParameterErrorNameEnum]
export const InvalidParameterErrorMessageEnum = {
  InvalidParameterParam: 'Invalid parameter: ${param}.',
} as const

export type InvalidParameterErrorMessageEnum =
  (typeof InvalidParameterErrorMessageEnum)[keyof typeof InvalidParameterErrorMessageEnum]
export const InvalidParameterErrorHttpStatusCodeEnum = {
  NUMBER_400: 400,
} as const

export type InvalidParameterErrorHttpStatusCodeEnum =
  (typeof InvalidParameterErrorHttpStatusCodeEnum)[keyof typeof InvalidParameterErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface JwtObject
 */
export interface JwtObject {
  /**
   * List of names of the the JWT Algorithms
   * @type {Array<string>}
   * @memberof JwtObject
   */
  alg: Array<string>
}
/**
 *
 * @export
 * @interface LdpObject
 */
export interface LdpObject {
  /**
   * List of names of the proof types
   * @type {Array<string>}
   * @memberof LdpObject
   */
  proof_type: Array<string>
}
/**
 * Error object
 * @export
 * @interface ModelError
 */
export interface ModelError {
  /**
   * Error code
   * @type {string}
   * @memberof ModelError
   */
  errorCode?: string
  /**
   * Error message
   * @type {string}
   * @memberof ModelError
   */
  errorMessage?: string
  /**
   * Verbose message
   * @type {string}
   * @memberof ModelError
   */
  message?: string
  /**
   * Error name
   * @type {string}
   * @memberof ModelError
   */
  name?: string
  /**
   * Debug identifier
   * @type {string}
   * @memberof ModelError
   */
  debugId?: string
  /**
   * Error details
   * @type {Array<ErrorDetail>}
   * @memberof ModelError
   */
  details?: Array<ErrorDetail>
}
/**
 *
 * @export
 * @interface NestedDescriptor
 */
export interface NestedDescriptor {
  /**
   *
   * @type {string}
   * @memberof NestedDescriptor
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof NestedDescriptor
   */
  path: string
  /**
   *
   * @type {NestedDescriptor}
   * @memberof NestedDescriptor
   */
  path_nested?: NestedDescriptor
  /**
   *
   * @type {string}
   * @memberof NestedDescriptor
   */
  format: string
}
/**
 *
 * @export
 * @interface NotFoundError
 */
export interface NotFoundError {
  /**
   *
   * @type {string}
   * @memberof NotFoundError
   */
  name: NotFoundErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof NotFoundError
   */
  message: NotFoundErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof NotFoundError
   */
  httpStatusCode: NotFoundErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof NotFoundError
   */
  traceId: string
  /**
   *
   * @type {Array<NotFoundErrorDetailsInner>}
   * @memberof NotFoundError
   */
  details?: Array<NotFoundErrorDetailsInner>
}

export const NotFoundErrorNameEnum = {
  NotFoundError: 'NotFoundError',
} as const

export type NotFoundErrorNameEnum =
  (typeof NotFoundErrorNameEnum)[keyof typeof NotFoundErrorNameEnum]
export const NotFoundErrorMessageEnum = {
  NotFoundParam: 'Not found: ${param}.',
} as const

export type NotFoundErrorMessageEnum =
  (typeof NotFoundErrorMessageEnum)[keyof typeof NotFoundErrorMessageEnum]
export const NotFoundErrorHttpStatusCodeEnum = {
  NUMBER_404: 404,
} as const

export type NotFoundErrorHttpStatusCodeEnum =
  (typeof NotFoundErrorHttpStatusCodeEnum)[keyof typeof NotFoundErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface NotFoundErrorDetailsInner
 */
export interface NotFoundErrorDetailsInner {
  /**
   *
   * @type {string}
   * @memberof NotFoundErrorDetailsInner
   */
  issue: string
  /**
   *
   * @type {string}
   * @memberof NotFoundErrorDetailsInner
   */
  field?: string
  /**
   *
   * @type {string}
   * @memberof NotFoundErrorDetailsInner
   */
  value?: string
  /**
   *
   * @type {string}
   * @memberof NotFoundErrorDetailsInner
   */
  location?: string
}
/**
 *
 * @export
 * @interface PdStatus
 */
export interface PdStatus {
  /**
   *
   * @type {string}
   * @memberof PdStatus
   */
  directive?: PdStatusDirectiveEnum
}

export const PdStatusDirectiveEnum = {
  Required: 'required',
  Allowed: 'allowed',
  Disallowed: 'disallowed',
} as const

export type PdStatusDirectiveEnum =
  (typeof PdStatusDirectiveEnum)[keyof typeof PdStatusDirectiveEnum]

/**
 * Presentation definition
 * @export
 * @interface PresentationDefinition
 */
export interface PresentationDefinition {
  /**
   * Definition id
   * @type {string}
   * @memberof PresentationDefinition
   */
  id: string
  /**
   * Definition name
   * @type {string}
   * @memberof PresentationDefinition
   */
  name?: string
  /**
   * Definition purpose
   * @type {string}
   * @memberof PresentationDefinition
   */
  purpose?: string
  /**
   *
   * @type {Format}
   * @memberof PresentationDefinition
   */
  format?: Format
  /**
   *
   * @type {Array<SubmissionRequirement>}
   * @memberof PresentationDefinition
   */
  submission_requirements?: Array<SubmissionRequirement>
  /**
   *
   * @type {Array<InputDescriptor>}
   * @memberof PresentationDefinition
   */
  input_descriptors: Array<InputDescriptor>
  /**
   * Dynamic model
   * @type {{ [key: string]: any; }}
   * @memberof PresentationDefinition
   */
  frame?: { [key: string]: any }
}
/**
 *
 * @export
 * @interface PresentationSubmission
 */
export interface PresentationSubmission {
  /**
   *
   * @type {string}
   * @memberof PresentationSubmission
   */
  id: string
  /**
   *
   * @type {string}
   * @memberof PresentationSubmission
   */
  definition_id: string
  /**
   *
   * @type {Array<Descriptor>}
   * @memberof PresentationSubmission
   */
  descriptor_map: Array<Descriptor>
}
/**
 *
 * @export
 * @interface SubmissionRequirement
 */
export interface SubmissionRequirement {
  /**
   *
   * @type {string}
   * @memberof SubmissionRequirement
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof SubmissionRequirement
   */
  purpose?: string
  /**
   *
   * @type {string}
   * @memberof SubmissionRequirement
   */
  rule: SubmissionRequirementRuleEnum
  /**
   *
   * @type {number}
   * @memberof SubmissionRequirement
   */
  count?: number
  /**
   *
   * @type {number}
   * @memberof SubmissionRequirement
   */
  min?: number
  /**
   *
   * @type {number}
   * @memberof SubmissionRequirement
   */
  max?: number
  /**
   *
   * @type {string}
   * @memberof SubmissionRequirement
   */
  from?: string
  /**
   *
   * @type {Array<SubmissionRequirement>}
   * @memberof SubmissionRequirement
   */
  from_nested?: Array<SubmissionRequirement>
}

export const SubmissionRequirementRuleEnum = {
  All: 'all',
  Pick: 'pick',
} as const

export type SubmissionRequirementRuleEnum =
  (typeof SubmissionRequirementRuleEnum)[keyof typeof SubmissionRequirementRuleEnum]

/**
 * Request model of /validate-jwt
 * @export
 * @interface ValidateJwtInput
 */
export interface ValidateJwtInput {
  /**
   * JWT token
   * @type {string}
   * @memberof ValidateJwtInput
   */
  token: string
}
/**
 * Response model of /validate-jwt
 * @export
 * @interface ValidateJwtOutput
 */
export interface ValidateJwtOutput {
  /**
   * Defines if jwt is valid
   * @type {boolean}
   * @memberof ValidateJwtOutput
   */
  isValid: boolean
  /**
   * Decoded payload of the token
   * @type {object}
   * @memberof ValidateJwtOutput
   */
  payload: object
}
/**
 * Request model of /verify-vcs
 * @export
 * @interface VerifyCredentialInput
 */
export interface VerifyCredentialInput {
  /**
   * List of VCs
   * @type {Array<object>}
   * @memberof VerifyCredentialInput
   */
  verifiableCredentials: Array<object>
  /**
   * Dynamic model
   * @type {{ [key: string]: any; }}
   * @memberof VerifyCredentialInput
   */
  issuerDidDocument?: { [key: string]: any }
}
/**
 * Response model of /verify-vcs
 * @export
 * @interface VerifyCredentialOutput
 */
export interface VerifyCredentialOutput {
  /**
   * Errors of the VCs failed verification
   * @type {Array<string>}
   * @memberof VerifyCredentialOutput
   */
  errors: Array<string>
  /**
   * Verification result
   * @type {boolean}
   * @memberof VerifyCredentialOutput
   */
  isValid: boolean
}
/**
 * Request model of /v2/verify-vcs
 * @export
 * @interface VerifyCredentialV2Input
 */
export interface VerifyCredentialV2Input {
  /**
   * List of VC strings
   * @type {Array<string>}
   * @memberof VerifyCredentialV2Input
   */
  verifiableCredentials: Array<string>
  /**
   * Dynamic model
   * @type {{ [key: string]: any; }}
   * @memberof VerifyCredentialV2Input
   */
  issuerDidDocument?: { [key: string]: any }
}
/**
 * Request model of /verify-vp
 * @export
 * @interface VerifyPresentationInput
 */
export interface VerifyPresentationInput {
  /**
   *
   * @type {object}
   * @memberof VerifyPresentationInput
   */
  verifiablePresentation?: object
  /**
   *
   * @type {object}
   * @memberof VerifyPresentationInput
   */
  signedPresentation?: object
  /**
   *
   * @type {object}
   * @memberof VerifyPresentationInput
   */
  presentationDefinition?: object
  /**
   *
   * @type {object}
   * @memberof VerifyPresentationInput
   */
  presentationSubmission?: object
  /**
   *
   * @type {object}
   * @memberof VerifyPresentationInput
   */
  dcqlQuery?: object
  /**
   *
   * @type {string}
   * @memberof VerifyPresentationInput
   */
  challenge?: string
}
/**
 * Response model of /verify-vp
 * @export
 * @interface VerifyPresentationOutput
 */
export interface VerifyPresentationOutput {
  /**
   * Error of the verification
   * @type {Array<string>}
   * @memberof VerifyPresentationOutput
   */
  errors: Array<string>
  /**
   * Verification result
   * @type {boolean}
   * @memberof VerifyPresentationOutput
   */
  isValid: boolean
}
/**
 * Request model of /v2/verify-vp
 * @export
 * @interface VerifyPresentationV2Input
 */
export interface VerifyPresentationV2Input {
  /**
   *
   * @type {object}
   * @memberof VerifyPresentationV2Input
   */
  verifiablePresentation?: object
  /**
   *
   * @type {VerifyPresentationV2InputPexQuery}
   * @memberof VerifyPresentationV2Input
   */
  pexQuery?: VerifyPresentationV2InputPexQuery
  /**
   *
   * @type {string}
   * @memberof VerifyPresentationV2Input
   */
  challenge?: string
}
/**
 * Presentation Exchange Query containing presentation definition and submission
 * @export
 * @interface VerifyPresentationV2InputPexQuery
 */
export interface VerifyPresentationV2InputPexQuery {
  /**
   * Presentation definition for the verification request
   * @type {object}
   * @memberof VerifyPresentationV2InputPexQuery
   */
  presentationDefinition?: object
  /**
   * Presentation submission for the verification request
   * @type {object}
   * @memberof VerifyPresentationV2InputPexQuery
   */
  presentationSubmission?: object
}
/**
 *
 * @export
 * @interface W3cCredentialStatus
 */
export interface W3cCredentialStatus {
  /**
   *
   * @type {string}
   * @memberof W3cCredentialStatus
   */
  id: string
  /**
   *
   * @type {string}
   * @memberof W3cCredentialStatus
   */
  type: string
  /**
   *
   * @type {string}
   * @memberof W3cCredentialStatus
   */
  revocationListIndex: string
  /**
   *
   * @type {string}
   * @memberof W3cCredentialStatus
   */
  revocationListCredential: string
}
/**
 *
 * @export
 * @interface W3cProof
 */
export interface W3cProof {
  /**
   *
   * @type {string}
   * @memberof W3cProof
   */
  type?: string | null
  /**
   *
   * @type {string}
   * @memberof W3cProof
   */
  created?: string | null
  /**
   *
   * @type {string}
   * @memberof W3cProof
   */
  verificationMethod: string
  /**
   *
   * @type {string}
   * @memberof W3cProof
   */
  proofPurpose: string
  /**
   *
   * @type {string}
   * @memberof W3cProof
   */
  jws?: string | null
  /**
   *
   * @type {string}
   * @memberof W3cProof
   */
  proofValue?: string | null
  /**
   *
   * @type {string}
   * @memberof W3cProof
   */
  nonce?: string | null
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Verifying Verifiable Credentials (signatures)  `isValid` - true if all credentials verified `errors` contains list of error messages for invalid credentials.
     * @summary Verifying VC
     * @param {VerifyCredentialInput} verifyCredentialInput VerifyCredentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyCredentials: async (
      verifyCredentialInput: VerifyCredentialInput,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'verifyCredentialInput' is not null or undefined
      assertParamExists(
        'verifyCredentials',
        'verifyCredentialInput',
        verifyCredentialInput,
      )
      const localVarPath = `/v1/verifier/verify-vcs`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        verifyCredentialInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Verifying Verifiable Presentation (signatures)  `isValid` - true if presentation verified `error` verificaction error.
     * @summary Verifying VP
     * @param {VerifyPresentationInput} verifyPresentationInput VerifyPresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyPresentation: async (
      verifyPresentationInput: VerifyPresentationInput,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'verifyPresentationInput' is not null or undefined
      assertParamExists(
        'verifyPresentation',
        'verifyPresentationInput',
        verifyPresentationInput,
      )
      const localVarPath = `/v1/verifier/verify-vp`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        verifyPresentationInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
  return {
    /**
     * Verifying Verifiable Credentials (signatures)  `isValid` - true if all credentials verified `errors` contains list of error messages for invalid credentials.
     * @summary Verifying VC
     * @param {VerifyCredentialInput} verifyCredentialInput VerifyCredentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async verifyCredentials(
      verifyCredentialInput: VerifyCredentialInput,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<VerifyCredentialOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.verifyCredentials(
          verifyCredentialInput,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.verifyCredentials']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Verifying Verifiable Presentation (signatures)  `isValid` - true if presentation verified `error` verificaction error.
     * @summary Verifying VP
     * @param {VerifyPresentationInput} verifyPresentationInput VerifyPresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async verifyPresentation(
      verifyPresentationInput: VerifyPresentationInput,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<VerifyPresentationOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.verifyPresentation(
          verifyPresentationInput,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.verifyPresentation']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DefaultApiFp(configuration)
  return {
    /**
     * Verifying Verifiable Credentials (signatures)  `isValid` - true if all credentials verified `errors` contains list of error messages for invalid credentials.
     * @summary Verifying VC
     * @param {VerifyCredentialInput} verifyCredentialInput VerifyCredentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyCredentials(
      verifyCredentialInput: VerifyCredentialInput,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<VerifyCredentialOutput> {
      return localVarFp
        .verifyCredentials(verifyCredentialInput, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Verifying Verifiable Presentation (signatures)  `isValid` - true if presentation verified `error` verificaction error.
     * @summary Verifying VP
     * @param {VerifyPresentationInput} verifyPresentationInput VerifyPresentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyPresentation(
      verifyPresentationInput: VerifyPresentationInput,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<VerifyPresentationOutput> {
      return localVarFp
        .verifyPresentation(verifyPresentationInput, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
  /**
   * Verifying Verifiable Credentials (signatures)  `isValid` - true if all credentials verified `errors` contains list of error messages for invalid credentials.
   * @summary Verifying VC
   * @param {VerifyCredentialInput} verifyCredentialInput VerifyCredentials
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public verifyCredentials(
    verifyCredentialInput: VerifyCredentialInput,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .verifyCredentials(verifyCredentialInput, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Verifying Verifiable Presentation (signatures)  `isValid` - true if presentation verified `error` verificaction error.
   * @summary Verifying VP
   * @param {VerifyPresentationInput} verifyPresentationInput VerifyPresentation
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public verifyPresentation(
    verifyPresentationInput: VerifyPresentationInput,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .verifyPresentation(verifyPresentationInput, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
