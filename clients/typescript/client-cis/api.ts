/* tslint:disable */
/* eslint-disable */
/**
 * CredentialIssuanceService
 * Affinidi Credential Issuance Service Structure
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: nucleus.team@affinidi.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration'
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios'
import globalAxios from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common'
import type { RequestArgs } from './base'
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  BaseAPI,
  RequiredError,
  operationServerMap,
} from './base'

/**
 *
 * @export
 * @interface ActionForbiddenError
 */
export interface ActionForbiddenError {
  /**
   *
   * @type {string}
   * @memberof ActionForbiddenError
   */
  name: ActionForbiddenErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof ActionForbiddenError
   */
  message: ActionForbiddenErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof ActionForbiddenError
   */
  httpStatusCode: ActionForbiddenErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof ActionForbiddenError
   */
  traceId: string
  /**
   *
   * @type {Array<ActionForbiddenErrorDetailsInner>}
   * @memberof ActionForbiddenError
   */
  details?: Array<ActionForbiddenErrorDetailsInner>
}

export const ActionForbiddenErrorNameEnum = {
  ActionForbiddenError: 'ActionForbiddenError',
} as const

export type ActionForbiddenErrorNameEnum =
  (typeof ActionForbiddenErrorNameEnum)[keyof typeof ActionForbiddenErrorNameEnum]
export const ActionForbiddenErrorMessageEnum = {
  PrincipalCanNotExecuteActionOnGivenResource:
    'Principal can not execute action on given resource',
} as const

export type ActionForbiddenErrorMessageEnum =
  (typeof ActionForbiddenErrorMessageEnum)[keyof typeof ActionForbiddenErrorMessageEnum]
export const ActionForbiddenErrorHttpStatusCodeEnum = {
  NUMBER_403: 403,
} as const

export type ActionForbiddenErrorHttpStatusCodeEnum =
  (typeof ActionForbiddenErrorHttpStatusCodeEnum)[keyof typeof ActionForbiddenErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface ActionForbiddenErrorDetailsInner
 */
export interface ActionForbiddenErrorDetailsInner {
  /**
   *
   * @type {string}
   * @memberof ActionForbiddenErrorDetailsInner
   */
  issue: string
  /**
   *
   * @type {string}
   * @memberof ActionForbiddenErrorDetailsInner
   */
  field?: string
  /**
   *
   * @type {string}
   * @memberof ActionForbiddenErrorDetailsInner
   */
  value?: string
  /**
   *
   * @type {string}
   * @memberof ActionForbiddenErrorDetailsInner
   */
  location?: string
}
/**
 *
 * @export
 * @interface CreateCredentialInput
 */
export interface CreateCredentialInput {
  /**
   * It is a String that identifies a Credential that is being requested to be issued.
   * @type {string}
   * @memberof CreateCredentialInput
   */
  credential_identifier: string
  /**
   *
   * @type {CredentialProof}
   * @memberof CreateCredentialInput
   */
  proof: CredentialProof
}
/**
 *
 * @export
 * @interface CreateIssuanceConfigInput
 */
export interface CreateIssuanceConfigInput {
  /**
   * Issuer Wallet id
   * @type {string}
   * @memberof CreateIssuanceConfigInput
   */
  issuerWalletId?: string
  /**
   * credential offer duration in second
   * @type {number}
   * @memberof CreateIssuanceConfigInput
   */
  credentialOfferDuration?: number
  /**
   * String identifying the format of this Credential, i.e., ldp_vc. Depending on the format value, the object contains further elements defining the type
   * @type {string}
   * @memberof CreateIssuanceConfigInput
   */
  format?: CreateIssuanceConfigInputFormatEnum
  /**
   *
   * @type {Array<CreateIssuanceConfigInputCredentialSupportedInner>}
   * @memberof CreateIssuanceConfigInput
   */
  credentialSupported: Array<CreateIssuanceConfigInputCredentialSupportedInner>
  /**
   * Issuer public information wallet may want to show to user during consent confirmation
   * @type {{ [key: string]: any; }}
   * @memberof CreateIssuanceConfigInput
   */
  issuerMetadata?: { [key: string]: any }
}

export const CreateIssuanceConfigInputFormatEnum = {
  LdpVc: 'ldp_vc',
} as const

export type CreateIssuanceConfigInputFormatEnum =
  (typeof CreateIssuanceConfigInputFormatEnum)[keyof typeof CreateIssuanceConfigInputFormatEnum]

/**
 *
 * @export
 * @interface CreateIssuanceConfigInputCredentialSupportedInner
 */
export interface CreateIssuanceConfigInputCredentialSupportedInner {
  /**
   * It is a String that identifies a Credential that is being requested to be issued.
   * @type {string}
   * @memberof CreateIssuanceConfigInputCredentialSupportedInner
   */
  credentialTypeId: string
  /**
   * credential jsonLdContextUrl
   * @type {string}
   * @memberof CreateIssuanceConfigInputCredentialSupportedInner
   */
  jsonSchemaUrl: string
  /**
   * credential jsonSchemaUrl
   * @type {string}
   * @memberof CreateIssuanceConfigInputCredentialSupportedInner
   */
  jsonLdContextUrl: string
}
/**
 *
 * @export
 * @interface CredentialOfferResponse
 */
export interface CredentialOfferResponse {
  /**
   * The URL of the Credential Issuer
   * @type {string}
   * @memberof CredentialOfferResponse
   */
  credential_issuer: string
  /**
   * Array of unique strings that each identify one of the keys in the name/value pairs stored in the credentialSupported
   * @type {Array<string>}
   * @memberof CredentialOfferResponse
   */
  credential_configuration_ids: Array<string>
  /**
   *
   * @type {CredentialOfferResponseGrants}
   * @memberof CredentialOfferResponse
   */
  grants: CredentialOfferResponseGrants
}
/**
 * Object indicating to the Wallet the Grant Types the Credential Issuer\'s Authorization Server is prepared to process for this Credential Offer.
 * @export
 * @interface CredentialOfferResponseGrants
 */
export interface CredentialOfferResponseGrants {
  /**
   *
   * @type {CredentialOfferResponseGrantsUrnIetfParamsOauthGrantTypePreAuthorizedCode}
   * @memberof CredentialOfferResponseGrants
   */
  'urn:ietf:params:oauth:grant-type:pre-authorized_code': CredentialOfferResponseGrantsUrnIetfParamsOauthGrantTypePreAuthorizedCode
}
/**
 * Grant type for `pre-authorized_code` flow
 * @export
 * @interface CredentialOfferResponseGrantsUrnIetfParamsOauthGrantTypePreAuthorizedCode
 */
export interface CredentialOfferResponseGrantsUrnIetfParamsOauthGrantTypePreAuthorizedCode {
  /**
   * pre authorized code to be exchanged with jwt token
   * @type {string}
   * @memberof CredentialOfferResponseGrantsUrnIetfParamsOauthGrantTypePreAuthorizedCode
   */
  'pre-authorized_code': string
  /**
   *
   * @type {CredentialOfferResponseGrantsUrnIetfParamsOauthGrantTypePreAuthorizedCodeTxCode}
   * @memberof CredentialOfferResponseGrantsUrnIetfParamsOauthGrantTypePreAuthorizedCode
   */
  tx_code: CredentialOfferResponseGrantsUrnIetfParamsOauthGrantTypePreAuthorizedCodeTxCode
}
/**
 * Object specifying whether the Authorization Server expects presentation of a Transaction Code by the End-User along with the Token Request in a Pre-Authorized Code Flow
 * @export
 * @interface CredentialOfferResponseGrantsUrnIetfParamsOauthGrantTypePreAuthorizedCodeTxCode
 */
export interface CredentialOfferResponseGrantsUrnIetfParamsOauthGrantTypePreAuthorizedCodeTxCode {
  /**
   * Integer specifying the length of the Transaction Code
   * @type {string}
   * @memberof CredentialOfferResponseGrantsUrnIetfParamsOauthGrantTypePreAuthorizedCodeTxCode
   */
  length?: string
  /**
   * String specifying the input character set. Possible values are numeric (only digits) and text (any characters).
   * @type {string}
   * @memberof CredentialOfferResponseGrantsUrnIetfParamsOauthGrantTypePreAuthorizedCodeTxCode
   */
  input_mode?: string
  /**
   * String containing guidance for the Holder of the Wallet on how to obtain the Transaction Code
   * @type {string}
   * @memberof CredentialOfferResponseGrantsUrnIetfParamsOauthGrantTypePreAuthorizedCodeTxCode
   */
  description?: string
}
/**
 * Object containing the proof of possession of the cryptographic key material the issued Credential would be bound to.
 * @export
 * @interface CredentialProof
 */
export interface CredentialProof {
  /**
   * String denoting the key proof type.
   * @type {string}
   * @memberof CredentialProof
   */
  proof_type: CredentialProofProofTypeEnum
  /**
   *
   * @type {string}
   * @memberof CredentialProof
   */
  jwt: string
}

export const CredentialProofProofTypeEnum = {
  Jwt: 'jwt',
} as const

export type CredentialProofProofTypeEnum =
  (typeof CredentialProofProofTypeEnum)[keyof typeof CredentialProofProofTypeEnum]

/**
 * @type CredentialResponse
 * @export
 */
export type CredentialResponse =
  | CredentialResponseDeferred
  | CredentialResponseImmediate

/**
 *
 * @export
 * @interface CredentialResponseDeferred
 */
export interface CredentialResponseDeferred {
  /**
   * String identifying a Deferred Issuance transaction. This claim is contained in the response if the Credential Issuer was unable to immediately issue the Credential.
   * @type {string}
   * @memberof CredentialResponseDeferred
   */
  transaction_id: string
  /**
   * String containing a nonce to be used when creating a proof of possession of the key proof
   * @type {string}
   * @memberof CredentialResponseDeferred
   */
  c_nonce: string
  /**
   * Lifetime in seconds of the c_nonce
   * @type {number}
   * @memberof CredentialResponseDeferred
   */
  c_nonce_expires_in: number
}
/**
 *
 * @export
 * @interface CredentialResponseImmediate
 */
export interface CredentialResponseImmediate {
  /**
   * Issued Credential, It can be a string or an object, depending on the Credential format. default format  is `ldp_vc`.
   * @type {{ [key: string]: any; }}
   * @memberof CredentialResponseImmediate
   */
  credential: { [key: string]: any }
  /**
   * String containing a nonce to be used when creating a proof of possession of the key proof
   * @type {string}
   * @memberof CredentialResponseImmediate
   */
  c_nonce: string
  /**
   * Lifetime in seconds of the c_nonce
   * @type {number}
   * @memberof CredentialResponseImmediate
   */
  c_nonce_expires_in: number
}
/**
 *
 * @export
 * @interface DeferredCredentialInput
 */
export interface DeferredCredentialInput {
  /**
   * String identifying a Deferred Issuance transaction. This claim is contained in the response if the Credential Issuer was unable to immediately issue the Credential.
   * @type {string}
   * @memberof DeferredCredentialInput
   */
  transaction_id: string
}
/**
 *
 * @export
 * @interface InvalidParameterError
 */
export interface InvalidParameterError {
  /**
   *
   * @type {string}
   * @memberof InvalidParameterError
   */
  name: InvalidParameterErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof InvalidParameterError
   */
  message: InvalidParameterErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof InvalidParameterError
   */
  httpStatusCode: InvalidParameterErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof InvalidParameterError
   */
  traceId: string
  /**
   *
   * @type {Array<ActionForbiddenErrorDetailsInner>}
   * @memberof InvalidParameterError
   */
  details?: Array<ActionForbiddenErrorDetailsInner>
}

export const InvalidParameterErrorNameEnum = {
  InvalidParameterError: 'InvalidParameterError',
} as const

export type InvalidParameterErrorNameEnum =
  (typeof InvalidParameterErrorNameEnum)[keyof typeof InvalidParameterErrorNameEnum]
export const InvalidParameterErrorMessageEnum = {
  InvalidParameterParam: 'Invalid parameter: ${param}.',
} as const

export type InvalidParameterErrorMessageEnum =
  (typeof InvalidParameterErrorMessageEnum)[keyof typeof InvalidParameterErrorMessageEnum]
export const InvalidParameterErrorHttpStatusCodeEnum = {
  NUMBER_400: 400,
} as const

export type InvalidParameterErrorHttpStatusCodeEnum =
  (typeof InvalidParameterErrorHttpStatusCodeEnum)[keyof typeof InvalidParameterErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface IssuanceConfig
 */
export interface IssuanceConfig {
  /**
   *
   * @type {string}
   * @memberof IssuanceConfig
   */
  id?: string
  /**
   * Issuer DID
   * @type {string}
   * @memberof IssuanceConfig
   */
  issuerDid?: string
  /**
   * Issuer Wallet id
   * @type {string}
   * @memberof IssuanceConfig
   */
  issuerWalletId?: string
  /**
   * credential offer duration in second
   * @type {number}
   * @memberof IssuanceConfig
   */
  credentialOfferDuration?: number
  /**
   * c_nonce duration in second
   * @type {number}
   * @memberof IssuanceConfig
   */
  cNonceDuration?: number
  /**
   * String identifying the format of this Credential, i.e., jwt_vc_json-ld or ldp_vc. Depending on the format value, the object contains further elements defining the type
   * @type {string}
   * @memberof IssuanceConfig
   */
  format?: IssuanceConfigFormatEnum
  /**
   * Issuer URI
   * @type {string}
   * @memberof IssuanceConfig
   */
  issuerUri?: string
  /**
   *
   * @type {Array<CreateIssuanceConfigInputCredentialSupportedInner>}
   * @memberof IssuanceConfig
   */
  credentialSupported?: Array<CreateIssuanceConfigInputCredentialSupportedInner>
  /**
   * Issuer public information wallet may want to show to user during consent confirmation
   * @type {{ [key: string]: any; }}
   * @memberof IssuanceConfig
   */
  issuerMetadata?: { [key: string]: any }
  /**
   *
   * @type {number}
   * @memberof IssuanceConfig
   */
  version?: number
}

export const IssuanceConfigFormatEnum = {
  LdpVc: 'ldp_vc',
} as const

export type IssuanceConfigFormatEnum =
  (typeof IssuanceConfigFormatEnum)[keyof typeof IssuanceConfigFormatEnum]

/**
 *
 * @export
 * @interface IssuanceStateResponse
 */
export interface IssuanceStateResponse {
  /**
   * Website\'s internal identifier. Website may use to get info about the status of issuance flow. If it is not provided, CIS will generate one.
   * @type {string}
   * @memberof IssuanceStateResponse
   */
  issuanceId: string
  /**
   * String describing the status of the issuance
   * @type {string}
   * @memberof IssuanceStateResponse
   */
  status: IssuanceStateResponseStatusEnum
}

export const IssuanceStateResponseStatusEnum = {
  Init: 'INIT',
  OfferDelivered: 'OFFER_DELIVERED',
  VcClaimed: 'VC_CLAIMED',
  Timeout: 'TIMEOUT',
} as const

export type IssuanceStateResponseStatusEnum =
  (typeof IssuanceStateResponseStatusEnum)[keyof typeof IssuanceStateResponseStatusEnum]

/**
 *
 * @export
 * @interface ListIssuanceResponse
 */
export interface ListIssuanceResponse {
  /**
   * The list of all issuances for the Project
   * @type {Array<string>}
   * @memberof ListIssuanceResponse
   */
  issuanceIds: Array<string>
}
/**
 *
 * @export
 * @interface NotFoundError
 */
export interface NotFoundError {
  /**
   *
   * @type {string}
   * @memberof NotFoundError
   */
  name: NotFoundErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof NotFoundError
   */
  message: NotFoundErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof NotFoundError
   */
  httpStatusCode: NotFoundErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof NotFoundError
   */
  traceId: string
  /**
   *
   * @type {Array<ActionForbiddenErrorDetailsInner>}
   * @memberof NotFoundError
   */
  details?: Array<ActionForbiddenErrorDetailsInner>
}

export const NotFoundErrorNameEnum = {
  NotFoundError: 'NotFoundError',
} as const

export type NotFoundErrorNameEnum =
  (typeof NotFoundErrorNameEnum)[keyof typeof NotFoundErrorNameEnum]
export const NotFoundErrorMessageEnum = {
  NotFoundParam: 'Not found: ${param}.',
} as const

export type NotFoundErrorMessageEnum =
  (typeof NotFoundErrorMessageEnum)[keyof typeof NotFoundErrorMessageEnum]
export const NotFoundErrorHttpStatusCodeEnum = {
  NUMBER_404: 404,
} as const

export type NotFoundErrorHttpStatusCodeEnum =
  (typeof NotFoundErrorHttpStatusCodeEnum)[keyof typeof NotFoundErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface StartIssuanceInput
 */
export interface StartIssuanceInput {
  /**
   * Holder DID
   * @type {string}
   * @memberof StartIssuanceInput
   */
  holderDid: string
  /**
   * Website\'s internal identifier. Website may use to get info about the status of issuance flow. If it is not provided, CIS will generate one.
   * @type {string}
   * @memberof StartIssuanceInput
   */
  issuanceId?: string
  /**
   *
   * @type {StartIssuanceInputData}
   * @memberof StartIssuanceInput
   */
  data: StartIssuanceInputData
}
/**
 * Data to be included in issued credential
 * @export
 * @interface StartIssuanceInputData
 */
export interface StartIssuanceInputData {
  /**
   * It is a String that identifies a Credential that is being requested to be issued.
   * @type {string}
   * @memberof StartIssuanceInputData
   */
  credentialTypeId: string
  /**
   * Object of data to be included in the issued credential ,should  match the credential type
   * @type {{ [key: string]: any; }}
   * @memberof StartIssuanceInputData
   */
  credentialData: { [key: string]: any }
}
/**
 *
 * @export
 * @interface StartIssuanceResponse
 */
export interface StartIssuanceResponse {
  /**
   * URL where wallet can view offer details
   * @type {string}
   * @memberof StartIssuanceResponse
   */
  credentialOfferUri: string
  /**
   * One time transaction code generated by CIS
   * @type {string}
   * @memberof StartIssuanceResponse
   */
  txCode: string
  /**
   * Website\'s internal identifier. Website may use to get info about the status of issuance flow. If it is not provided, CIS will generate one.
   * @type {string}
   * @memberof StartIssuanceResponse
   */
  issuanceId: string
  /**
   * Expire time in seconds
   * @type {number}
   * @memberof StartIssuanceResponse
   */
  expiresIn: number
}
/**
 *
 * @export
 * @interface UpdateIssuanceConfigInput
 */
export interface UpdateIssuanceConfigInput {
  /**
   * Issuer Wallet id
   * @type {string}
   * @memberof UpdateIssuanceConfigInput
   */
  issuerWalletId?: string
  /**
   * credential offer duration in second
   * @type {number}
   * @memberof UpdateIssuanceConfigInput
   */
  credentialOfferDuration?: number
  /**
   * String identifying the format of this Credential, i.e., ldp_vc. Depending on the format value, the object contains further elements defining the type
   * @type {string}
   * @memberof UpdateIssuanceConfigInput
   */
  format?: UpdateIssuanceConfigInputFormatEnum
  /**
   * Issuer URI
   * @type {string}
   * @memberof UpdateIssuanceConfigInput
   */
  issuerUri?: string
  /**
   *
   * @type {Array<CreateIssuanceConfigInputCredentialSupportedInner>}
   * @memberof UpdateIssuanceConfigInput
   */
  credentialSupported?: Array<CreateIssuanceConfigInputCredentialSupportedInner>
  /**
   * Issuer public information wallet may want to show to user during consent confirmation
   * @type {{ [key: string]: any; }}
   * @memberof UpdateIssuanceConfigInput
   */
  issuerMetadata?: { [key: string]: any }
}

export const UpdateIssuanceConfigInputFormatEnum = {
  LdpVc: 'ldp_vc',
} as const

export type UpdateIssuanceConfigInputFormatEnum =
  (typeof UpdateIssuanceConfigInputFormatEnum)[keyof typeof UpdateIssuanceConfigInputFormatEnum]

/**
 *
 * @export
 * @interface WellKnownOpenIdCredentialIssuerResponse
 */
export interface WellKnownOpenIdCredentialIssuerResponse {
  [key: string]: any

  /**
   *
   * @type {string}
   * @memberof WellKnownOpenIdCredentialIssuerResponse
   */
  authorization_endpoint?: string
  /**
   *
   * @type {string}
   * @memberof WellKnownOpenIdCredentialIssuerResponse
   */
  credential_endpoint?: string
  /**
   *
   * @type {string}
   * @memberof WellKnownOpenIdCredentialIssuerResponse
   */
  credential_issuer?: string
  /**
   *
   * @type {Array<CreateIssuanceConfigInputCredentialSupportedInner>}
   * @memberof WellKnownOpenIdCredentialIssuerResponse
   */
  credentials_supported?: Array<CreateIssuanceConfigInputCredentialSupportedInner>
  /**
   *
   * @type {string}
   * @memberof WellKnownOpenIdCredentialIssuerResponse
   */
  deferred_credential_endpoint?: string
  /**
   *
   * @type {Array<string>}
   * @memberof WellKnownOpenIdCredentialIssuerResponse
   */
  grant_types_supported?: Array<WellKnownOpenIdCredentialIssuerResponseGrantTypesSupportedEnum>
  /**
   *
   * @type {string}
   * @memberof WellKnownOpenIdCredentialIssuerResponse
   */
  jwks_uri?: string
  /**
   *
   * @type {Array<string>}
   * @memberof WellKnownOpenIdCredentialIssuerResponse
   */
  scopes_supported?: Array<WellKnownOpenIdCredentialIssuerResponseScopesSupportedEnum>
  /**
   *
   * @type {string}
   * @memberof WellKnownOpenIdCredentialIssuerResponse
   */
  token_endpoint?: string
  /**
   *
   * @type {Array<string>}
   * @memberof WellKnownOpenIdCredentialIssuerResponse
   */
  token_endpoint_auth_methods_supported?: Array<WellKnownOpenIdCredentialIssuerResponseTokenEndpointAuthMethodsSupportedEnum>
}

export const WellKnownOpenIdCredentialIssuerResponseGrantTypesSupportedEnum = {
  AuthorizationCode: 'authorization_code',
  UrnietfparamsoauthgrantTypepreAuthorizedCode:
    'urn:ietf:params:oauth:grant-type:pre-authorized_code',
} as const

export type WellKnownOpenIdCredentialIssuerResponseGrantTypesSupportedEnum =
  (typeof WellKnownOpenIdCredentialIssuerResponseGrantTypesSupportedEnum)[keyof typeof WellKnownOpenIdCredentialIssuerResponseGrantTypesSupportedEnum]
export const WellKnownOpenIdCredentialIssuerResponseScopesSupportedEnum = {
  Openid: 'openid',
} as const

export type WellKnownOpenIdCredentialIssuerResponseScopesSupportedEnum =
  (typeof WellKnownOpenIdCredentialIssuerResponseScopesSupportedEnum)[keyof typeof WellKnownOpenIdCredentialIssuerResponseScopesSupportedEnum]
export const WellKnownOpenIdCredentialIssuerResponseTokenEndpointAuthMethodsSupportedEnum =
  {
    ClientSecretPost: 'client_secret_post',
    ClientSecretBasic: 'client_secret_basic',
    None: 'none',
  } as const

export type WellKnownOpenIdCredentialIssuerResponseTokenEndpointAuthMethodsSupportedEnum =
  (typeof WellKnownOpenIdCredentialIssuerResponseTokenEndpointAuthMethodsSupportedEnum)[keyof typeof WellKnownOpenIdCredentialIssuerResponseTokenEndpointAuthMethodsSupportedEnum]

/**
 * ConfigurationApi - axios parameter creator
 * @export
 */
export const ConfigurationApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Create issuance configuration, project have only one configuration
     * @param {CreateIssuanceConfigInput} createIssuanceConfigInput Request body of create configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createIssuanceConfig: async (
      createIssuanceConfigInput: CreateIssuanceConfigInput,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createIssuanceConfigInput' is not null or undefined
      assertParamExists(
        'createIssuanceConfig',
        'createIssuanceConfigInput',
        createIssuanceConfigInput
      )
      const localVarPath = `/v1/configuration`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        createIssuanceConfigInput,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete project issuance configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteIssuanceConfig: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/configuration`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get issuance configuration for my selected project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIssuanceConfig: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/configuration`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update issuance configuration
     * @param {UpdateIssuanceConfigInput} updateIssuanceConfigInput Request body of update configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateIssuanceConfig: async (
      updateIssuanceConfigInput: UpdateIssuanceConfigInput,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'updateIssuanceConfigInput' is not null or undefined
      assertParamExists(
        'updateIssuanceConfig',
        'updateIssuanceConfigInput',
        updateIssuanceConfigInput
      )
      const localVarPath = `/v1/configuration`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateIssuanceConfigInput,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ConfigurationApi - functional programming interface
 * @export
 */
export const ConfigurationApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ConfigurationApiAxiosParamCreator(configuration)
  return {
    /**
     * Create issuance configuration, project have only one configuration
     * @param {CreateIssuanceConfigInput} createIssuanceConfigInput Request body of create configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createIssuanceConfig(
      createIssuanceConfigInput: CreateIssuanceConfigInput,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<IssuanceConfig>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createIssuanceConfig(
          createIssuanceConfigInput,
          options
        )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['ConfigurationApi.createIssuanceConfig']?.[index]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * Delete project issuance configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteIssuanceConfig(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteIssuanceConfig(options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['ConfigurationApi.deleteIssuanceConfig']?.[index]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * Get issuance configuration for my selected project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getIssuanceConfig(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<IssuanceConfig>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getIssuanceConfig(options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['ConfigurationApi.getIssuanceConfig']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * Update issuance configuration
     * @param {UpdateIssuanceConfigInput} updateIssuanceConfigInput Request body of update configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateIssuanceConfig(
      updateIssuanceConfigInput: UpdateIssuanceConfigInput,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<IssuanceConfig>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateIssuanceConfig(
          updateIssuanceConfigInput,
          options
        )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['ConfigurationApi.updateIssuanceConfig']?.[index]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
  }
}

/**
 * ConfigurationApi - factory interface
 * @export
 */
export const ConfigurationApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ConfigurationApiFp(configuration)
  return {
    /**
     * Create issuance configuration, project have only one configuration
     * @param {CreateIssuanceConfigInput} createIssuanceConfigInput Request body of create configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createIssuanceConfig(
      createIssuanceConfigInput: CreateIssuanceConfigInput,
      options?: any
    ): AxiosPromise<IssuanceConfig> {
      return localVarFp
        .createIssuanceConfig(createIssuanceConfigInput, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete project issuance configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteIssuanceConfig(options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteIssuanceConfig(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get issuance configuration for my selected project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIssuanceConfig(options?: any): AxiosPromise<IssuanceConfig> {
      return localVarFp
        .getIssuanceConfig(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update issuance configuration
     * @param {UpdateIssuanceConfigInput} updateIssuanceConfigInput Request body of update configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateIssuanceConfig(
      updateIssuanceConfigInput: UpdateIssuanceConfigInput,
      options?: any
    ): AxiosPromise<IssuanceConfig> {
      return localVarFp
        .updateIssuanceConfig(updateIssuanceConfigInput, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ConfigurationApi - object-oriented interface
 * @export
 * @class ConfigurationApi
 * @extends {BaseAPI}
 */
export class ConfigurationApi extends BaseAPI {
  /**
   * Create issuance configuration, project have only one configuration
   * @param {CreateIssuanceConfigInput} createIssuanceConfigInput Request body of create configuration
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConfigurationApi
   */
  public createIssuanceConfig(
    createIssuanceConfigInput: CreateIssuanceConfigInput,
    options?: RawAxiosRequestConfig
  ) {
    return ConfigurationApiFp(this.configuration)
      .createIssuanceConfig(createIssuanceConfigInput, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete project issuance configuration
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConfigurationApi
   */
  public deleteIssuanceConfig(options?: RawAxiosRequestConfig) {
    return ConfigurationApiFp(this.configuration)
      .deleteIssuanceConfig(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get issuance configuration for my selected project
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConfigurationApi
   */
  public getIssuanceConfig(options?: RawAxiosRequestConfig) {
    return ConfigurationApiFp(this.configuration)
      .getIssuanceConfig(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update issuance configuration
   * @param {UpdateIssuanceConfigInput} updateIssuanceConfigInput Request body of update configuration
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConfigurationApi
   */
  public updateIssuanceConfig(
    updateIssuanceConfigInput: UpdateIssuanceConfigInput,
    options?: RawAxiosRequestConfig
  ) {
    return ConfigurationApiFp(this.configuration)
      .updateIssuanceConfig(updateIssuanceConfigInput, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * CredentialsApi - axios parameter creator
 * @export
 */
export const CredentialsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Get deferred credential by `transaction_id`
     * @param {string} projectId Affinidi project id
     * @param {DeferredCredentialInput} deferredCredentialInput Request body of deferred credentials
     * @param {string} [authorization] Token from OID4VCI auth server
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deferredCredentials: async (
      projectId: string,
      deferredCredentialInput: DeferredCredentialInput,
      authorization?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists('deferredCredentials', 'projectId', projectId)
      // verify required parameter 'deferredCredentialInput' is not null or undefined
      assertParamExists(
        'deferredCredentials',
        'deferredCredentialInput',
        deferredCredentialInput
      )
      const localVarPath = `/v1/{projectId}/deferred_credential`.replace(
        `{${'projectId'}}`,
        encodeURIComponent(String(projectId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        deferredCredentialInput,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Issue credential for end user upon presentation a valid access token. Since we don\'t immediate issue credential It\'s expected to return `transaction_id` and use this `transaction_id` to get the deferred credentials
     * @param {string} projectId Affinidi project id
     * @param {CreateCredentialInput} createCredentialInput Request body to issue credentials
     * @param {string} [authorization] Token from OID4VCI auth server
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateCredentials: async (
      projectId: string,
      createCredentialInput: CreateCredentialInput,
      authorization?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists('generateCredentials', 'projectId', projectId)
      // verify required parameter 'createCredentialInput' is not null or undefined
      assertParamExists(
        'generateCredentials',
        'createCredentialInput',
        createCredentialInput
      )
      const localVarPath = `/v1/{projectId}/credential`.replace(
        `{${'projectId'}}`,
        encodeURIComponent(String(projectId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (authorization != null) {
        localVarHeaderParameter['authorization'] = String(authorization)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        createCredentialInput,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * CredentialsApi - functional programming interface
 * @export
 */
export const CredentialsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    CredentialsApiAxiosParamCreator(configuration)
  return {
    /**
     * Get deferred credential by `transaction_id`
     * @param {string} projectId Affinidi project id
     * @param {DeferredCredentialInput} deferredCredentialInput Request body of deferred credentials
     * @param {string} [authorization] Token from OID4VCI auth server
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deferredCredentials(
      projectId: string,
      deferredCredentialInput: DeferredCredentialInput,
      authorization?: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CredentialResponseImmediate>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deferredCredentials(
          projectId,
          deferredCredentialInput,
          authorization,
          options
        )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['CredentialsApi.deferredCredentials']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * Issue credential for end user upon presentation a valid access token. Since we don\'t immediate issue credential It\'s expected to return `transaction_id` and use this `transaction_id` to get the deferred credentials
     * @param {string} projectId Affinidi project id
     * @param {CreateCredentialInput} createCredentialInput Request body to issue credentials
     * @param {string} [authorization] Token from OID4VCI auth server
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async generateCredentials(
      projectId: string,
      createCredentialInput: CreateCredentialInput,
      authorization?: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CredentialResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.generateCredentials(
          projectId,
          createCredentialInput,
          authorization,
          options
        )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['CredentialsApi.generateCredentials']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
  }
}

/**
 * CredentialsApi - factory interface
 * @export
 */
export const CredentialsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = CredentialsApiFp(configuration)
  return {
    /**
     * Get deferred credential by `transaction_id`
     * @param {string} projectId Affinidi project id
     * @param {DeferredCredentialInput} deferredCredentialInput Request body of deferred credentials
     * @param {string} [authorization] Token from OID4VCI auth server
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deferredCredentials(
      projectId: string,
      deferredCredentialInput: DeferredCredentialInput,
      authorization?: string,
      options?: any
    ): AxiosPromise<CredentialResponseImmediate> {
      return localVarFp
        .deferredCredentials(
          projectId,
          deferredCredentialInput,
          authorization,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Issue credential for end user upon presentation a valid access token. Since we don\'t immediate issue credential It\'s expected to return `transaction_id` and use this `transaction_id` to get the deferred credentials
     * @param {string} projectId Affinidi project id
     * @param {CreateCredentialInput} createCredentialInput Request body to issue credentials
     * @param {string} [authorization] Token from OID4VCI auth server
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateCredentials(
      projectId: string,
      createCredentialInput: CreateCredentialInput,
      authorization?: string,
      options?: any
    ): AxiosPromise<CredentialResponse> {
      return localVarFp
        .generateCredentials(
          projectId,
          createCredentialInput,
          authorization,
          options
        )
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * CredentialsApi - object-oriented interface
 * @export
 * @class CredentialsApi
 * @extends {BaseAPI}
 */
export class CredentialsApi extends BaseAPI {
  /**
   * Get deferred credential by `transaction_id`
   * @param {string} projectId Affinidi project id
   * @param {DeferredCredentialInput} deferredCredentialInput Request body of deferred credentials
   * @param {string} [authorization] Token from OID4VCI auth server
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CredentialsApi
   */
  public deferredCredentials(
    projectId: string,
    deferredCredentialInput: DeferredCredentialInput,
    authorization?: string,
    options?: RawAxiosRequestConfig
  ) {
    return CredentialsApiFp(this.configuration)
      .deferredCredentials(
        projectId,
        deferredCredentialInput,
        authorization,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Issue credential for end user upon presentation a valid access token. Since we don\'t immediate issue credential It\'s expected to return `transaction_id` and use this `transaction_id` to get the deferred credentials
   * @param {string} projectId Affinidi project id
   * @param {CreateCredentialInput} createCredentialInput Request body to issue credentials
   * @param {string} [authorization] Token from OID4VCI auth server
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CredentialsApi
   */
  public generateCredentials(
    projectId: string,
    createCredentialInput: CreateCredentialInput,
    authorization?: string,
    options?: RawAxiosRequestConfig
  ) {
    return CredentialsApiFp(this.configuration)
      .generateCredentials(
        projectId,
        createCredentialInput,
        authorization,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * IssuanceApi - axios parameter creator
 * @export
 */
export const IssuanceApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Get issuance status
     * @param {string} issuanceId
     * @param {string} projectId Affinidi project id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    issuanceState: async (
      issuanceId: string,
      projectId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'issuanceId' is not null or undefined
      assertParamExists('issuanceState', 'issuanceId', issuanceId)
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists('issuanceState', 'projectId', projectId)
      const localVarPath = `/v1/{projectId}/issuance/state/{issuanceId}`
        .replace(`{${'issuanceId'}}`, encodeURIComponent(String(issuanceId)))
        .replace(`{${'projectId'}}`, encodeURIComponent(String(projectId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List all issuances for Project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listIssuance: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/issuance`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Endpoint used b websites to start the issuance process
     * @param {string} projectId Affinidi project id
     * @param {StartIssuanceInput} startIssuanceInput Request body to start issuance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startIssuance: async (
      projectId: string,
      startIssuanceInput: StartIssuanceInput,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists('startIssuance', 'projectId', projectId)
      // verify required parameter 'startIssuanceInput' is not null or undefined
      assertParamExists(
        'startIssuance',
        'startIssuanceInput',
        startIssuanceInput
      )
      const localVarPath = `/v1/{projectId}/issuance/start`.replace(
        `{${'projectId'}}`,
        encodeURIComponent(String(projectId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        startIssuanceInput,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * IssuanceApi - functional programming interface
 * @export
 */
export const IssuanceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = IssuanceApiAxiosParamCreator(configuration)
  return {
    /**
     * Get issuance status
     * @param {string} issuanceId
     * @param {string} projectId Affinidi project id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async issuanceState(
      issuanceId: string,
      projectId: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<IssuanceStateResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.issuanceState(
        issuanceId,
        projectId,
        options
      )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['IssuanceApi.issuanceState']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * List all issuances for Project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listIssuance(
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListIssuanceResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listIssuance(
        options
      )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['IssuanceApi.listIssuance']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
    /**
     * Endpoint used b websites to start the issuance process
     * @param {string} projectId Affinidi project id
     * @param {StartIssuanceInput} startIssuanceInput Request body to start issuance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async startIssuance(
      projectId: string,
      startIssuanceInput: StartIssuanceInput,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<StartIssuanceResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.startIssuance(
        projectId,
        startIssuanceInput,
        options
      )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['IssuanceApi.startIssuance']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
  }
}

/**
 * IssuanceApi - factory interface
 * @export
 */
export const IssuanceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = IssuanceApiFp(configuration)
  return {
    /**
     * Get issuance status
     * @param {string} issuanceId
     * @param {string} projectId Affinidi project id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    issuanceState(
      issuanceId: string,
      projectId: string,
      options?: any
    ): AxiosPromise<IssuanceStateResponse> {
      return localVarFp
        .issuanceState(issuanceId, projectId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * List all issuances for Project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listIssuance(options?: any): AxiosPromise<ListIssuanceResponse> {
      return localVarFp
        .listIssuance(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Endpoint used b websites to start the issuance process
     * @param {string} projectId Affinidi project id
     * @param {StartIssuanceInput} startIssuanceInput Request body to start issuance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startIssuance(
      projectId: string,
      startIssuanceInput: StartIssuanceInput,
      options?: any
    ): AxiosPromise<StartIssuanceResponse> {
      return localVarFp
        .startIssuance(projectId, startIssuanceInput, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * IssuanceApi - object-oriented interface
 * @export
 * @class IssuanceApi
 * @extends {BaseAPI}
 */
export class IssuanceApi extends BaseAPI {
  /**
   * Get issuance status
   * @param {string} issuanceId
   * @param {string} projectId Affinidi project id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IssuanceApi
   */
  public issuanceState(
    issuanceId: string,
    projectId: string,
    options?: RawAxiosRequestConfig
  ) {
    return IssuanceApiFp(this.configuration)
      .issuanceState(issuanceId, projectId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List all issuances for Project
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IssuanceApi
   */
  public listIssuance(options?: RawAxiosRequestConfig) {
    return IssuanceApiFp(this.configuration)
      .listIssuance(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Endpoint used b websites to start the issuance process
   * @param {string} projectId Affinidi project id
   * @param {StartIssuanceInput} startIssuanceInput Request body to start issuance
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IssuanceApi
   */
  public startIssuance(
    projectId: string,
    startIssuanceInput: StartIssuanceInput,
    options?: RawAxiosRequestConfig
  ) {
    return IssuanceApiFp(this.configuration)
      .startIssuance(projectId, startIssuanceInput, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * OfferApi - axios parameter creator
 * @export
 */
export const OfferApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Endpoint used to return Credential Offer details, used with `credential_offer_uri` response
     * @param {string} issuanceId issuanceId from credential_offer_uri
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCredentialOffer: async (
      issuanceId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'issuanceId' is not null or undefined
      assertParamExists('getCredentialOffer', 'issuanceId', issuanceId)
      const localVarPath = `/v1/{projectId}/offer/{issuanceId}`.replace(
        `{${'issuanceId'}}`,
        encodeURIComponent(String(issuanceId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * OfferApi - functional programming interface
 * @export
 */
export const OfferApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = OfferApiAxiosParamCreator(configuration)
  return {
    /**
     * Endpoint used to return Credential Offer details, used with `credential_offer_uri` response
     * @param {string} issuanceId issuanceId from credential_offer_uri
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCredentialOffer(
      issuanceId: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CredentialOfferResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCredentialOffer(issuanceId, options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['OfferApi.getCredentialOffer']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
  }
}

/**
 * OfferApi - factory interface
 * @export
 */
export const OfferApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = OfferApiFp(configuration)
  return {
    /**
     * Endpoint used to return Credential Offer details, used with `credential_offer_uri` response
     * @param {string} issuanceId issuanceId from credential_offer_uri
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCredentialOffer(
      issuanceId: string,
      options?: any
    ): AxiosPromise<CredentialOfferResponse> {
      return localVarFp
        .getCredentialOffer(issuanceId, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * OfferApi - object-oriented interface
 * @export
 * @class OfferApi
 * @extends {BaseAPI}
 */
export class OfferApi extends BaseAPI {
  /**
   * Endpoint used to return Credential Offer details, used with `credential_offer_uri` response
   * @param {string} issuanceId issuanceId from credential_offer_uri
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OfferApi
   */
  public getCredentialOffer(
    issuanceId: string,
    options?: RawAxiosRequestConfig
  ) {
    return OfferApiFp(this.configuration)
      .getCredentialOffer(issuanceId, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * WellKnownApi - axios parameter creator
 * @export
 */
export const WellKnownApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWellKnownOpenIdCredentialIssuer: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/{projectId}/.well-known/openid-credential-issuer`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * WellKnownApi - functional programming interface
 * @export
 */
export const WellKnownApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = WellKnownApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getWellKnownOpenIdCredentialIssuer(
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<WellKnownOpenIdCredentialIssuerResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getWellKnownOpenIdCredentialIssuer(
          options
        )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['WellKnownApi.getWellKnownOpenIdCredentialIssuer']?.[
          index
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath)
    },
  }
}

/**
 * WellKnownApi - factory interface
 * @export
 */
export const WellKnownApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = WellKnownApiFp(configuration)
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWellKnownOpenIdCredentialIssuer(
      options?: any
    ): AxiosPromise<WellKnownOpenIdCredentialIssuerResponse> {
      return localVarFp
        .getWellKnownOpenIdCredentialIssuer(options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * WellKnownApi - object-oriented interface
 * @export
 * @class WellKnownApi
 * @extends {BaseAPI}
 */
export class WellKnownApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WellKnownApi
   */
  public getWellKnownOpenIdCredentialIssuer(options?: RawAxiosRequestConfig) {
    return WellKnownApiFp(this.configuration)
      .getWellKnownOpenIdCredentialIssuer(options)
      .then((request) => request(this.axios, this.basePath))
  }
}
