/* tslint:disable */
/* eslint-disable */
/**
 * CredentialIssuanceService
 * Affinidi Credential Issuance Service Structure
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: info@affinidi.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration'
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios'
import globalAxios from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common'
import type { RequestArgs } from './base'
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  BaseAPI,
  RequiredError,
  operationServerMap,
} from './base'

/**
 *
 * @export
 * @interface ActionForbiddenError
 */
export interface ActionForbiddenError {
  /**
   *
   * @type {string}
   * @memberof ActionForbiddenError
   */
  name: ActionForbiddenErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof ActionForbiddenError
   */
  message: ActionForbiddenErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof ActionForbiddenError
   */
  httpStatusCode: ActionForbiddenErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof ActionForbiddenError
   */
  traceId: string
  /**
   *
   * @type {Array<ActionForbiddenErrorDetailsInner>}
   * @memberof ActionForbiddenError
   */
  details?: Array<ActionForbiddenErrorDetailsInner>
}

export const ActionForbiddenErrorNameEnum = {
  ActionForbiddenError: 'ActionForbiddenError',
} as const

export type ActionForbiddenErrorNameEnum =
  (typeof ActionForbiddenErrorNameEnum)[keyof typeof ActionForbiddenErrorNameEnum]
export const ActionForbiddenErrorMessageEnum = {
  PrincipalCanNotExecuteActionOnGivenResource:
    'Principal can not execute action on given resource',
} as const

export type ActionForbiddenErrorMessageEnum =
  (typeof ActionForbiddenErrorMessageEnum)[keyof typeof ActionForbiddenErrorMessageEnum]
export const ActionForbiddenErrorHttpStatusCodeEnum = {
  NUMBER_403: 403,
} as const

export type ActionForbiddenErrorHttpStatusCodeEnum =
  (typeof ActionForbiddenErrorHttpStatusCodeEnum)[keyof typeof ActionForbiddenErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface ActionForbiddenErrorDetailsInner
 */
export interface ActionForbiddenErrorDetailsInner {
  /**
   *
   * @type {string}
   * @memberof ActionForbiddenErrorDetailsInner
   */
  issue: string
  /**
   *
   * @type {string}
   * @memberof ActionForbiddenErrorDetailsInner
   */
  field?: string
  /**
   *
   * @type {string}
   * @memberof ActionForbiddenErrorDetailsInner
   */
  value?: string
  /**
   *
   * @type {string}
   * @memberof ActionForbiddenErrorDetailsInner
   */
  location?: string
}
/**
 *
 * @export
 * @interface CorsGenerateCredentialsOK
 */
export interface CorsGenerateCredentialsOK {
  /**
   *
   * @type {string}
   * @memberof CorsGenerateCredentialsOK
   */
  corsGenerateCredentialsOk?: string
}
/**
 *
 * @export
 * @interface CorsGetCredentialOfferOK
 */
export interface CorsGetCredentialOfferOK {
  /**
   *
   * @type {string}
   * @memberof CorsGetCredentialOfferOK
   */
  corsGetCredentialOfferOk?: string
}
/**
 *
 * @export
 * @interface CorsGetWellKnownOpenIdCredentialIssuerOK
 */
export interface CorsGetWellKnownOpenIdCredentialIssuerOK {
  /**
   *
   * @type {string}
   * @memberof CorsGetWellKnownOpenIdCredentialIssuerOK
   */
  corsGetWellKnownOpenIdCredentialIssuerOk?: string
}
/**
 *
 * @export
 * @interface CreateCredentialInput
 */
export interface CreateCredentialInput {
  [key: string]: any

  /**
   * It is a String that identifies a Credential that is being requested to be issued.
   * @type {string}
   * @memberof CreateCredentialInput
   */
  credential_identifier?: string
  /**
   *
   * @type {CredentialProof}
   * @memberof CreateCredentialInput
   */
  proof: CredentialProof
}
/**
 * @type CreateIssuanceConfig400Response
 * @export
 */
export type CreateIssuanceConfig400Response =
  | InvalidIssuerWalletError
  | ProjectCredentialConfigExistError
  | ProjectCredentialConfigNotExistError

/**
 *
 * @export
 * @interface CreateIssuanceConfigInput
 */
export interface CreateIssuanceConfigInput {
  /**
   *
   * @type {string}
   * @memberof CreateIssuanceConfigInput
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof CreateIssuanceConfigInput
   */
  description?: string
  /**
   * Issuer Wallet id
   * @type {string}
   * @memberof CreateIssuanceConfigInput
   */
  issuerWalletId: string
  /**
   * credential offer duration in second
   * @type {number}
   * @memberof CreateIssuanceConfigInput
   */
  credentialOfferDuration?: number
  /**
   * String identifying the format of this Credential, i.e., ldp_vc. Depending on the format value, the object contains further elements defining the type
   * @type {string}
   * @memberof CreateIssuanceConfigInput
   */
  format?: CreateIssuanceConfigInputFormatEnum
  /**
   *
   * @type {Array<CreateIssuanceConfigInputCredentialSupportedInner>}
   * @memberof CreateIssuanceConfigInput
   */
  credentialSupported: Array<CreateIssuanceConfigInputCredentialSupportedInner>
  /**
   * Issuer public information wallet may want to show to user during consent confirmation
   * @type {{ [key: string]: any; }}
   * @memberof CreateIssuanceConfigInput
   */
  issuerMetadata?: { [key: string]: any }
}

export const CreateIssuanceConfigInputFormatEnum = {
  LdpVc: 'ldp_vc',
  JwtVcJsonLd: 'jwt_vc_json-ld',
} as const

export type CreateIssuanceConfigInputFormatEnum =
  (typeof CreateIssuanceConfigInputFormatEnum)[keyof typeof CreateIssuanceConfigInputFormatEnum]

/**
 *
 * @export
 * @interface CreateIssuanceConfigInputCredentialSupportedInner
 */
export interface CreateIssuanceConfigInputCredentialSupportedInner {
  /**
   * It is a String that identifies a Credential that is being requested to be issued.
   * @type {string}
   * @memberof CreateIssuanceConfigInputCredentialSupportedInner
   */
  credentialTypeId: string
  /**
   * credential jsonLdContextUrl
   * @type {string}
   * @memberof CreateIssuanceConfigInputCredentialSupportedInner
   */
  jsonSchemaUrl: string
  /**
   * credential jsonSchemaUrl
   * @type {string}
   * @memberof CreateIssuanceConfigInputCredentialSupportedInner
   */
  jsonLdContextUrl: string
}
/**
 *
 * @export
 * @interface CredentialIssuanceIdExistError
 */
export interface CredentialIssuanceIdExistError {
  /**
   *
   * @type {string}
   * @memberof CredentialIssuanceIdExistError
   */
  name: CredentialIssuanceIdExistErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof CredentialIssuanceIdExistError
   */
  message: CredentialIssuanceIdExistErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof CredentialIssuanceIdExistError
   */
  httpStatusCode: CredentialIssuanceIdExistErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof CredentialIssuanceIdExistError
   */
  traceId: string
  /**
   *
   * @type {Array<ActionForbiddenErrorDetailsInner>}
   * @memberof CredentialIssuanceIdExistError
   */
  details?: Array<ActionForbiddenErrorDetailsInner>
}

export const CredentialIssuanceIdExistErrorNameEnum = {
  CredentialIssuanceIdExistError: 'CredentialIssuanceIdExistError',
} as const

export type CredentialIssuanceIdExistErrorNameEnum =
  (typeof CredentialIssuanceIdExistErrorNameEnum)[keyof typeof CredentialIssuanceIdExistErrorNameEnum]
export const CredentialIssuanceIdExistErrorMessageEnum = {
  IssuanceIdExistForTheProjectPleaseUseDifferentIssuanceId:
    'issuanceId exist for the project, please use different issuanceId',
} as const

export type CredentialIssuanceIdExistErrorMessageEnum =
  (typeof CredentialIssuanceIdExistErrorMessageEnum)[keyof typeof CredentialIssuanceIdExistErrorMessageEnum]
export const CredentialIssuanceIdExistErrorHttpStatusCodeEnum = {
  NUMBER_400: 400,
} as const

export type CredentialIssuanceIdExistErrorHttpStatusCodeEnum =
  (typeof CredentialIssuanceIdExistErrorHttpStatusCodeEnum)[keyof typeof CredentialIssuanceIdExistErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface CredentialOfferClaimedError
 */
export interface CredentialOfferClaimedError {
  /**
   *
   * @type {string}
   * @memberof CredentialOfferClaimedError
   */
  name: CredentialOfferClaimedErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof CredentialOfferClaimedError
   */
  message: CredentialOfferClaimedErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof CredentialOfferClaimedError
   */
  httpStatusCode: CredentialOfferClaimedErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof CredentialOfferClaimedError
   */
  traceId: string
  /**
   *
   * @type {Array<ActionForbiddenErrorDetailsInner>}
   * @memberof CredentialOfferClaimedError
   */
  details?: Array<ActionForbiddenErrorDetailsInner>
}

export const CredentialOfferClaimedErrorNameEnum = {
  CredentialOfferClaimedError: 'CredentialOfferClaimedError',
} as const

export type CredentialOfferClaimedErrorNameEnum =
  (typeof CredentialOfferClaimedErrorNameEnum)[keyof typeof CredentialOfferClaimedErrorNameEnum]
export const CredentialOfferClaimedErrorMessageEnum = {
  CredentialOfferIsAlreadyClaimed: 'Credential offer is already claimed',
} as const

export type CredentialOfferClaimedErrorMessageEnum =
  (typeof CredentialOfferClaimedErrorMessageEnum)[keyof typeof CredentialOfferClaimedErrorMessageEnum]
export const CredentialOfferClaimedErrorHttpStatusCodeEnum = {
  NUMBER_400: 400,
} as const

export type CredentialOfferClaimedErrorHttpStatusCodeEnum =
  (typeof CredentialOfferClaimedErrorHttpStatusCodeEnum)[keyof typeof CredentialOfferClaimedErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface CredentialOfferExpiredError
 */
export interface CredentialOfferExpiredError {
  /**
   *
   * @type {string}
   * @memberof CredentialOfferExpiredError
   */
  name: CredentialOfferExpiredErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof CredentialOfferExpiredError
   */
  message: CredentialOfferExpiredErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof CredentialOfferExpiredError
   */
  httpStatusCode: CredentialOfferExpiredErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof CredentialOfferExpiredError
   */
  traceId: string
  /**
   *
   * @type {Array<ActionForbiddenErrorDetailsInner>}
   * @memberof CredentialOfferExpiredError
   */
  details?: Array<ActionForbiddenErrorDetailsInner>
}

export const CredentialOfferExpiredErrorNameEnum = {
  CredentialOfferExpiredError: 'CredentialOfferExpiredError',
} as const

export type CredentialOfferExpiredErrorNameEnum =
  (typeof CredentialOfferExpiredErrorNameEnum)[keyof typeof CredentialOfferExpiredErrorNameEnum]
export const CredentialOfferExpiredErrorMessageEnum = {
  CredentialOfferIsExpired: 'Credential offer is expired',
} as const

export type CredentialOfferExpiredErrorMessageEnum =
  (typeof CredentialOfferExpiredErrorMessageEnum)[keyof typeof CredentialOfferExpiredErrorMessageEnum]
export const CredentialOfferExpiredErrorHttpStatusCodeEnum = {
  NUMBER_400: 400,
} as const

export type CredentialOfferExpiredErrorHttpStatusCodeEnum =
  (typeof CredentialOfferExpiredErrorHttpStatusCodeEnum)[keyof typeof CredentialOfferExpiredErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface CredentialOfferResponse
 */
export interface CredentialOfferResponse {
  /**
   * The URL of the Credential Issuer
   * @type {string}
   * @memberof CredentialOfferResponse
   */
  credential_issuer: string
  /**
   * Array of unique strings that each identify one of the keys in the name/value pairs stored in the credentialSupported
   * @type {Array<string>}
   * @memberof CredentialOfferResponse
   */
  credential_configuration_ids: Array<string>
  /**
   *
   * @type {CredentialOfferResponseGrants}
   * @memberof CredentialOfferResponse
   */
  grants: CredentialOfferResponseGrants
}
/**
 * Object indicating to the Wallet the Grant Types the Credential Issuer\'s Authorization Server is prepared to process for this Credential Offer.
 * @export
 * @interface CredentialOfferResponseGrants
 */
export interface CredentialOfferResponseGrants {
  /**
   *
   * @type {CredentialOfferResponseGrantsUrnIetfParamsOauthGrantTypePreAuthorizedCode}
   * @memberof CredentialOfferResponseGrants
   */
  'urn:ietf:params:oauth:grant-type:pre-authorized_code': CredentialOfferResponseGrantsUrnIetfParamsOauthGrantTypePreAuthorizedCode
}
/**
 * Grant type for `pre-authorized_code` flow
 * @export
 * @interface CredentialOfferResponseGrantsUrnIetfParamsOauthGrantTypePreAuthorizedCode
 */
export interface CredentialOfferResponseGrantsUrnIetfParamsOauthGrantTypePreAuthorizedCode {
  /**
   * pre authorized code to be exchanged with jwt token
   * @type {string}
   * @memberof CredentialOfferResponseGrantsUrnIetfParamsOauthGrantTypePreAuthorizedCode
   */
  'pre-authorized_code': string
  /**
   *
   * @type {CredentialOfferResponseGrantsUrnIetfParamsOauthGrantTypePreAuthorizedCodeTxCode}
   * @memberof CredentialOfferResponseGrantsUrnIetfParamsOauthGrantTypePreAuthorizedCode
   */
  tx_code?: CredentialOfferResponseGrantsUrnIetfParamsOauthGrantTypePreAuthorizedCodeTxCode
}
/**
 * Object specifying whether the Authorization Server expects presentation of a Transaction Code by the End-User along with the Token Request in a Pre-Authorized Code Flow
 * @export
 * @interface CredentialOfferResponseGrantsUrnIetfParamsOauthGrantTypePreAuthorizedCodeTxCode
 */
export interface CredentialOfferResponseGrantsUrnIetfParamsOauthGrantTypePreAuthorizedCodeTxCode {
  /**
   * Integer specifying the length of the Transaction Code
   * @type {number}
   * @memberof CredentialOfferResponseGrantsUrnIetfParamsOauthGrantTypePreAuthorizedCodeTxCode
   */
  length?: number
  /**
   * String specifying the input character set. Possible values are numeric (only digits) and text (any characters).
   * @type {string}
   * @memberof CredentialOfferResponseGrantsUrnIetfParamsOauthGrantTypePreAuthorizedCodeTxCode
   */
  input_mode?: string
  /**
   * String containing guidance for the Holder of the Wallet on how to obtain the Transaction Code
   * @type {string}
   * @memberof CredentialOfferResponseGrantsUrnIetfParamsOauthGrantTypePreAuthorizedCodeTxCode
   */
  description?: string
}
/**
 * Object containing the proof of possession of the cryptographic key material the issued Credential would be bound to.
 * @export
 * @interface CredentialProof
 */
export interface CredentialProof {
  /**
   * String denoting the key proof type.
   * @type {string}
   * @memberof CredentialProof
   */
  proof_type: CredentialProofProofTypeEnum
  /**
   *
   * @type {string}
   * @memberof CredentialProof
   */
  jwt: string
}

export const CredentialProofProofTypeEnum = {
  Jwt: 'jwt',
} as const

export type CredentialProofProofTypeEnum =
  (typeof CredentialProofProofTypeEnum)[keyof typeof CredentialProofProofTypeEnum]

/**
 * @type CredentialResponse
 * @export
 */
export type CredentialResponse =
  | CredentialResponseDeferred
  | CredentialResponseImmediate

/**
 *
 * @export
 * @interface CredentialResponseDeferred
 */
export interface CredentialResponseDeferred {
  /**
   * String identifying a Deferred Issuance transaction. This claim is contained in the response if the Credential Issuer was unable to immediately issue the Credential.
   * @type {string}
   * @memberof CredentialResponseDeferred
   */
  transaction_id: string
  /**
   * String containing a nonce to be used when creating a proof of possession of the key proof
   * @type {string}
   * @memberof CredentialResponseDeferred
   */
  c_nonce: string
  /**
   * Lifetime in seconds of the c_nonce
   * @type {number}
   * @memberof CredentialResponseDeferred
   */
  c_nonce_expires_in: number
}
/**
 *
 * @export
 * @interface CredentialResponseImmediate
 */
export interface CredentialResponseImmediate {
  /**
   *
   * @type {CredentialResponseImmediateCredential}
   * @memberof CredentialResponseImmediate
   */
  credential: CredentialResponseImmediateCredential
  /**
   * String containing a nonce to be used when creating a proof of possession of the key proof
   * @type {string}
   * @memberof CredentialResponseImmediate
   */
  c_nonce: string
  /**
   *
   * @type {CredentialResponseImmediateCNonceExpiresIn}
   * @memberof CredentialResponseImmediate
   */
  c_nonce_expires_in: CredentialResponseImmediateCNonceExpiresIn
}
/**
 * @type CredentialResponseImmediateCNonceExpiresIn
 * @export
 */
export type CredentialResponseImmediateCNonceExpiresIn = number | string

/**
 * @type CredentialResponseImmediateCredential
 * @export
 */
export type CredentialResponseImmediateCredential =
  | string
  | { [key: string]: any }

/**
 *
 * @export
 * @interface CredentialSubjectNotValidError
 */
export interface CredentialSubjectNotValidError {
  /**
   *
   * @type {string}
   * @memberof CredentialSubjectNotValidError
   */
  name: CredentialSubjectNotValidErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof CredentialSubjectNotValidError
   */
  message: CredentialSubjectNotValidErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof CredentialSubjectNotValidError
   */
  httpStatusCode: CredentialSubjectNotValidErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof CredentialSubjectNotValidError
   */
  traceId: string
  /**
   *
   * @type {Array<ActionForbiddenErrorDetailsInner>}
   * @memberof CredentialSubjectNotValidError
   */
  details?: Array<ActionForbiddenErrorDetailsInner>
}

export const CredentialSubjectNotValidErrorNameEnum = {
  CredentialSubjectNotValidError: 'CredentialSubjectNotValidError',
} as const

export type CredentialSubjectNotValidErrorNameEnum =
  (typeof CredentialSubjectNotValidErrorNameEnum)[keyof typeof CredentialSubjectNotValidErrorNameEnum]
export const CredentialSubjectNotValidErrorMessageEnum = {
  CredentialSubjectIsNotAccordingToTheVcSchema:
    'Credential subject is not according to the vc schema',
} as const

export type CredentialSubjectNotValidErrorMessageEnum =
  (typeof CredentialSubjectNotValidErrorMessageEnum)[keyof typeof CredentialSubjectNotValidErrorMessageEnum]
export const CredentialSubjectNotValidErrorHttpStatusCodeEnum = {
  NUMBER_400: 400,
} as const

export type CredentialSubjectNotValidErrorHttpStatusCodeEnum =
  (typeof CredentialSubjectNotValidErrorHttpStatusCodeEnum)[keyof typeof CredentialSubjectNotValidErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface DeferredCredentialInput
 */
export interface DeferredCredentialInput {
  /**
   * String identifying a Deferred Issuance transaction. This claim is contained in the response if the Credential Issuer was unable to immediately issue the Credential.
   * @type {string}
   * @memberof DeferredCredentialInput
   */
  transaction_id: string
}
/**
 * @type GenerateCredentials400Response
 * @export
 */
export type GenerateCredentials400Response =
  | InvalidCredentialRequestError
  | InvalidProofError

/**
 * @type GetCredentialOffer400Response
 * @export
 */
export type GetCredentialOffer400Response =
  | CredentialOfferClaimedError
  | CredentialOfferExpiredError
  | InvalidParameterError
  | ProjectCredentialConfigNotExistError
  | VcClaimedError

/**
 *
 * @export
 * @interface InvalidCredentialRequestError
 */
export interface InvalidCredentialRequestError {
  /**
   *
   * @type {string}
   * @memberof InvalidCredentialRequestError
   */
  name: InvalidCredentialRequestErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof InvalidCredentialRequestError
   */
  message: InvalidCredentialRequestErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof InvalidCredentialRequestError
   */
  httpStatusCode: InvalidCredentialRequestErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof InvalidCredentialRequestError
   */
  traceId: string
  /**
   *
   * @type {Array<ActionForbiddenErrorDetailsInner>}
   * @memberof InvalidCredentialRequestError
   */
  details?: Array<ActionForbiddenErrorDetailsInner>
}

export const InvalidCredentialRequestErrorNameEnum = {
  InvalidCredentialRequestError: 'InvalidCredentialRequestError',
} as const

export type InvalidCredentialRequestErrorNameEnum =
  (typeof InvalidCredentialRequestErrorNameEnum)[keyof typeof InvalidCredentialRequestErrorNameEnum]
export const InvalidCredentialRequestErrorMessageEnum = {
  CredentialRequestIsInvalid: 'Credential Request is invalid',
} as const

export type InvalidCredentialRequestErrorMessageEnum =
  (typeof InvalidCredentialRequestErrorMessageEnum)[keyof typeof InvalidCredentialRequestErrorMessageEnum]
export const InvalidCredentialRequestErrorHttpStatusCodeEnum = {
  NUMBER_400: 400,
} as const

export type InvalidCredentialRequestErrorHttpStatusCodeEnum =
  (typeof InvalidCredentialRequestErrorHttpStatusCodeEnum)[keyof typeof InvalidCredentialRequestErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface InvalidCredentialTypeError
 */
export interface InvalidCredentialTypeError {
  /**
   *
   * @type {string}
   * @memberof InvalidCredentialTypeError
   */
  name: InvalidCredentialTypeErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof InvalidCredentialTypeError
   */
  message: InvalidCredentialTypeErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof InvalidCredentialTypeError
   */
  httpStatusCode: InvalidCredentialTypeErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof InvalidCredentialTypeError
   */
  traceId: string
  /**
   *
   * @type {Array<ActionForbiddenErrorDetailsInner>}
   * @memberof InvalidCredentialTypeError
   */
  details?: Array<ActionForbiddenErrorDetailsInner>
}

export const InvalidCredentialTypeErrorNameEnum = {
  InvalidCredentialTypeError: 'InvalidCredentialTypeError',
} as const

export type InvalidCredentialTypeErrorNameEnum =
  (typeof InvalidCredentialTypeErrorNameEnum)[keyof typeof InvalidCredentialTypeErrorNameEnum]
export const InvalidCredentialTypeErrorMessageEnum = {
  TheRequestedCredentialTypeIsNotSupported:
    'The requested credential type is not supported',
} as const

export type InvalidCredentialTypeErrorMessageEnum =
  (typeof InvalidCredentialTypeErrorMessageEnum)[keyof typeof InvalidCredentialTypeErrorMessageEnum]
export const InvalidCredentialTypeErrorHttpStatusCodeEnum = {
  NUMBER_400: 400,
} as const

export type InvalidCredentialTypeErrorHttpStatusCodeEnum =
  (typeof InvalidCredentialTypeErrorHttpStatusCodeEnum)[keyof typeof InvalidCredentialTypeErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface InvalidIssuerWalletError
 */
export interface InvalidIssuerWalletError {
  /**
   *
   * @type {string}
   * @memberof InvalidIssuerWalletError
   */
  name: InvalidIssuerWalletErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof InvalidIssuerWalletError
   */
  message: InvalidIssuerWalletErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof InvalidIssuerWalletError
   */
  httpStatusCode: InvalidIssuerWalletErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof InvalidIssuerWalletError
   */
  traceId: string
  /**
   *
   * @type {Array<ActionForbiddenErrorDetailsInner>}
   * @memberof InvalidIssuerWalletError
   */
  details?: Array<ActionForbiddenErrorDetailsInner>
}

export const InvalidIssuerWalletErrorNameEnum = {
  InvalidIssuerWalletError: 'InvalidIssuerWalletError',
} as const

export type InvalidIssuerWalletErrorNameEnum =
  (typeof InvalidIssuerWalletErrorNameEnum)[keyof typeof InvalidIssuerWalletErrorNameEnum]
export const InvalidIssuerWalletErrorMessageEnum = {
  IssuerWalletIdIsInvalid: 'issuer wallet id is invalid',
} as const

export type InvalidIssuerWalletErrorMessageEnum =
  (typeof InvalidIssuerWalletErrorMessageEnum)[keyof typeof InvalidIssuerWalletErrorMessageEnum]
export const InvalidIssuerWalletErrorHttpStatusCodeEnum = {
  NUMBER_400: 400,
} as const

export type InvalidIssuerWalletErrorHttpStatusCodeEnum =
  (typeof InvalidIssuerWalletErrorHttpStatusCodeEnum)[keyof typeof InvalidIssuerWalletErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface InvalidJwtTokenError
 */
export interface InvalidJwtTokenError {
  /**
   *
   * @type {string}
   * @memberof InvalidJwtTokenError
   */
  name: InvalidJwtTokenErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof InvalidJwtTokenError
   */
  message: InvalidJwtTokenErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof InvalidJwtTokenError
   */
  httpStatusCode: InvalidJwtTokenErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof InvalidJwtTokenError
   */
  traceId: string
  /**
   *
   * @type {Array<ActionForbiddenErrorDetailsInner>}
   * @memberof InvalidJwtTokenError
   */
  details?: Array<ActionForbiddenErrorDetailsInner>
}

export const InvalidJwtTokenErrorNameEnum = {
  InvalidJwtTokenError: 'InvalidJwtTokenError',
} as const

export type InvalidJwtTokenErrorNameEnum =
  (typeof InvalidJwtTokenErrorNameEnum)[keyof typeof InvalidJwtTokenErrorNameEnum]
export const InvalidJwtTokenErrorMessageEnum = {
  JwtTokenIsInvalid: 'JWT token is invalid',
} as const

export type InvalidJwtTokenErrorMessageEnum =
  (typeof InvalidJwtTokenErrorMessageEnum)[keyof typeof InvalidJwtTokenErrorMessageEnum]
export const InvalidJwtTokenErrorHttpStatusCodeEnum = {
  NUMBER_401: 401,
} as const

export type InvalidJwtTokenErrorHttpStatusCodeEnum =
  (typeof InvalidJwtTokenErrorHttpStatusCodeEnum)[keyof typeof InvalidJwtTokenErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface InvalidParameterError
 */
export interface InvalidParameterError {
  /**
   *
   * @type {string}
   * @memberof InvalidParameterError
   */
  name: InvalidParameterErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof InvalidParameterError
   */
  message: InvalidParameterErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof InvalidParameterError
   */
  httpStatusCode: InvalidParameterErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof InvalidParameterError
   */
  traceId: string
  /**
   *
   * @type {Array<ActionForbiddenErrorDetailsInner>}
   * @memberof InvalidParameterError
   */
  details?: Array<ActionForbiddenErrorDetailsInner>
}

export const InvalidParameterErrorNameEnum = {
  InvalidParameterError: 'InvalidParameterError',
} as const

export type InvalidParameterErrorNameEnum =
  (typeof InvalidParameterErrorNameEnum)[keyof typeof InvalidParameterErrorNameEnum]
export const InvalidParameterErrorMessageEnum = {
  InvalidParameterParam: 'Invalid parameter: ${param}.',
} as const

export type InvalidParameterErrorMessageEnum =
  (typeof InvalidParameterErrorMessageEnum)[keyof typeof InvalidParameterErrorMessageEnum]
export const InvalidParameterErrorHttpStatusCodeEnum = {
  NUMBER_400: 400,
} as const

export type InvalidParameterErrorHttpStatusCodeEnum =
  (typeof InvalidParameterErrorHttpStatusCodeEnum)[keyof typeof InvalidParameterErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface InvalidProofError
 */
export interface InvalidProofError {
  /**
   *
   * @type {string}
   * @memberof InvalidProofError
   */
  name: InvalidProofErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof InvalidProofError
   */
  message: InvalidProofErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof InvalidProofError
   */
  httpStatusCode: InvalidProofErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof InvalidProofError
   */
  traceId: string
  /**
   *
   * @type {Array<ActionForbiddenErrorDetailsInner>}
   * @memberof InvalidProofError
   */
  details?: Array<ActionForbiddenErrorDetailsInner>
}

export const InvalidProofErrorNameEnum = {
  InvalidProofError: 'InvalidProofError',
} as const

export type InvalidProofErrorNameEnum =
  (typeof InvalidProofErrorNameEnum)[keyof typeof InvalidProofErrorNameEnum]
export const InvalidProofErrorMessageEnum = {
  TheProofInTheCredentialRequestIsInvalid:
    'The proof in the Credential Request is invalid',
} as const

export type InvalidProofErrorMessageEnum =
  (typeof InvalidProofErrorMessageEnum)[keyof typeof InvalidProofErrorMessageEnum]
export const InvalidProofErrorHttpStatusCodeEnum = {
  NUMBER_400: 400,
} as const

export type InvalidProofErrorHttpStatusCodeEnum =
  (typeof InvalidProofErrorHttpStatusCodeEnum)[keyof typeof InvalidProofErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface IssuanceConfigDto
 */
export interface IssuanceConfigDto {
  /**
   *
   * @type {string}
   * @memberof IssuanceConfigDto
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof IssuanceConfigDto
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof IssuanceConfigDto
   */
  description?: string
  /**
   * Issuer DID
   * @type {string}
   * @memberof IssuanceConfigDto
   */
  issuerDid?: string
  /**
   * Issuer Wallet id
   * @type {string}
   * @memberof IssuanceConfigDto
   */
  issuerWalletId?: string
  /**
   * credential offer duration in second
   * @type {number}
   * @memberof IssuanceConfigDto
   */
  credentialOfferDuration?: number
  /**
   * c_nonce duration in second
   * @type {number}
   * @memberof IssuanceConfigDto
   */
  cNonceDuration?: number
  /**
   * String identifying the format of this Credential, i.e., jwt_vc_json-ld or ldp_vc. Depending on the format value, the object contains further elements defining the type
   * @type {string}
   * @memberof IssuanceConfigDto
   */
  format?: IssuanceConfigDtoFormatEnum
  /**
   * Issuer URI
   * @type {string}
   * @memberof IssuanceConfigDto
   */
  issuerUri?: string
  /**
   *
   * @type {Array<IssuanceConfigDtoCredentialSupportedInner>}
   * @memberof IssuanceConfigDto
   */
  credentialSupported?: Array<IssuanceConfigDtoCredentialSupportedInner>
  /**
   * Issuer public information wallet may want to show to user during consent confirmation
   * @type {{ [key: string]: any; }}
   * @memberof IssuanceConfigDto
   */
  issuerMetadata?: { [key: string]: any }
  /**
   *
   * @type {number}
   * @memberof IssuanceConfigDto
   */
  version?: number
}

export const IssuanceConfigDtoFormatEnum = {
  LdpVc: 'ldp_vc',
  JwtVcJsonLd: 'jwt_vc_json-ld',
} as const

export type IssuanceConfigDtoFormatEnum =
  (typeof IssuanceConfigDtoFormatEnum)[keyof typeof IssuanceConfigDtoFormatEnum]

/**
 *
 * @export
 * @interface IssuanceConfigDtoCredentialSupportedInner
 */
export interface IssuanceConfigDtoCredentialSupportedInner {
  /**
   * It is a String that identifies a Credential that is being requested to be issued.
   * @type {string}
   * @memberof IssuanceConfigDtoCredentialSupportedInner
   */
  credentialTypeId: string
  /**
   * credential jsonLdContextUrl
   * @type {string}
   * @memberof IssuanceConfigDtoCredentialSupportedInner
   */
  jsonSchemaUrl: string
  /**
   * credential jsonSchemaUrl
   * @type {string}
   * @memberof IssuanceConfigDtoCredentialSupportedInner
   */
  jsonLdContextUrl: string
}
/**
 *
 * @export
 * @interface IssuanceConfigListResponse
 */
export interface IssuanceConfigListResponse {
  /**
   *
   * @type {Array<IssuanceConfigMiniDto>}
   * @memberof IssuanceConfigListResponse
   */
  configurations: Array<IssuanceConfigMiniDto>
}
/**
 *
 * @export
 * @interface IssuanceConfigMiniDto
 */
export interface IssuanceConfigMiniDto {
  /**
   *
   * @type {string}
   * @memberof IssuanceConfigMiniDto
   */
  id: string
  /**
   *
   * @type {string}
   * @memberof IssuanceConfigMiniDto
   */
  name?: string
  /**
   * Issuer DID
   * @type {string}
   * @memberof IssuanceConfigMiniDto
   */
  issuerDid?: string
  /**
   * Issuer Wallet id
   * @type {string}
   * @memberof IssuanceConfigMiniDto
   */
  issuerWalletId?: string
  /**
   * credential offer duration in second
   * @type {number}
   * @memberof IssuanceConfigMiniDto
   */
  credentialOfferDuration?: number
  /**
   * c_nonce duration in second
   * @type {number}
   * @memberof IssuanceConfigMiniDto
   */
  cNonceDuration?: number
  /**
   * String identifying the format of this Credential, i.e., jwt_vc_json-ld or ldp_vc. Depending on the format value, the object contains further elements defining the type
   * @type {string}
   * @memberof IssuanceConfigMiniDto
   */
  format?: IssuanceConfigMiniDtoFormatEnum
  /**
   * Issuer URI
   * @type {string}
   * @memberof IssuanceConfigMiniDto
   */
  issuerUri?: string
  /**
   * Issuer public information wallet may want to show to user during consent confirmation
   * @type {{ [key: string]: any; }}
   * @memberof IssuanceConfigMiniDto
   */
  issuerMetadata?: { [key: string]: any }
  /**
   *
   * @type {number}
   * @memberof IssuanceConfigMiniDto
   */
  version?: number
}

export const IssuanceConfigMiniDtoFormatEnum = {
  LdpVc: 'ldp_vc',
  JwtVcJsonLd: 'jwt_vc_json-ld',
} as const

export type IssuanceConfigMiniDtoFormatEnum =
  (typeof IssuanceConfigMiniDtoFormatEnum)[keyof typeof IssuanceConfigMiniDtoFormatEnum]

/**
 *
 * @export
 * @interface IssuanceStateResponse
 */
export interface IssuanceStateResponse {
  /**
   * Website\'s internal identifier. Website may use to get info about the status of issuance flow. If it is not provided, CIS will generate one.
   * @type {string}
   * @memberof IssuanceStateResponse
   */
  issuanceId: string
  /**
   * String describing the status of the issuance
   * @type {string}
   * @memberof IssuanceStateResponse
   */
  status: IssuanceStateResponseStatusEnum
}

export const IssuanceStateResponseStatusEnum = {
  Init: 'INIT',
  OfferDelivered: 'OFFER_DELIVERED',
  VcClaimed: 'VC_CLAIMED',
  Timeout: 'TIMEOUT',
} as const

export type IssuanceStateResponseStatusEnum =
  (typeof IssuanceStateResponseStatusEnum)[keyof typeof IssuanceStateResponseStatusEnum]

/**
 *
 * @export
 * @interface ListIssuanceResponse
 */
export interface ListIssuanceResponse {
  /**
   * The list of all issuances for the Project
   * @type {Array<ListIssuanceResponseIssuancesInner>}
   * @memberof ListIssuanceResponse
   */
  issuances: Array<ListIssuanceResponseIssuancesInner>
}
/**
 *
 * @export
 * @interface ListIssuanceResponseIssuancesInner
 */
export interface ListIssuanceResponseIssuancesInner {
  /**
   * issuance id
   * @type {string}
   * @memberof ListIssuanceResponseIssuancesInner
   */
  id: string
}
/**
 *
 * @export
 * @interface MissingHolderDidError
 */
export interface MissingHolderDidError {
  /**
   *
   * @type {string}
   * @memberof MissingHolderDidError
   */
  name: MissingHolderDidErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof MissingHolderDidError
   */
  message: MissingHolderDidErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof MissingHolderDidError
   */
  httpStatusCode: MissingHolderDidErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof MissingHolderDidError
   */
  traceId: string
  /**
   *
   * @type {Array<ActionForbiddenErrorDetailsInner>}
   * @memberof MissingHolderDidError
   */
  details?: Array<ActionForbiddenErrorDetailsInner>
}

export const MissingHolderDidErrorNameEnum = {
  MissingHolderDidError: 'MissingHolderDidError',
} as const

export type MissingHolderDidErrorNameEnum =
  (typeof MissingHolderDidErrorNameEnum)[keyof typeof MissingHolderDidErrorNameEnum]
export const MissingHolderDidErrorMessageEnum = {
  HolderDidIsRequiredInThisClaimMode: 'holderDID is required in this claimMode',
} as const

export type MissingHolderDidErrorMessageEnum =
  (typeof MissingHolderDidErrorMessageEnum)[keyof typeof MissingHolderDidErrorMessageEnum]
export const MissingHolderDidErrorHttpStatusCodeEnum = {
  NUMBER_400: 400,
} as const

export type MissingHolderDidErrorHttpStatusCodeEnum =
  (typeof MissingHolderDidErrorHttpStatusCodeEnum)[keyof typeof MissingHolderDidErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface NotFoundError
 */
export interface NotFoundError {
  /**
   *
   * @type {string}
   * @memberof NotFoundError
   */
  name: NotFoundErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof NotFoundError
   */
  message: NotFoundErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof NotFoundError
   */
  httpStatusCode: NotFoundErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof NotFoundError
   */
  traceId: string
  /**
   *
   * @type {Array<ActionForbiddenErrorDetailsInner>}
   * @memberof NotFoundError
   */
  details?: Array<ActionForbiddenErrorDetailsInner>
}

export const NotFoundErrorNameEnum = {
  NotFoundError: 'NotFoundError',
} as const

export type NotFoundErrorNameEnum =
  (typeof NotFoundErrorNameEnum)[keyof typeof NotFoundErrorNameEnum]
export const NotFoundErrorMessageEnum = {
  NotFoundParam: 'Not found: ${param}.',
} as const

export type NotFoundErrorMessageEnum =
  (typeof NotFoundErrorMessageEnum)[keyof typeof NotFoundErrorMessageEnum]
export const NotFoundErrorHttpStatusCodeEnum = {
  NUMBER_404: 404,
} as const

export type NotFoundErrorHttpStatusCodeEnum =
  (typeof NotFoundErrorHttpStatusCodeEnum)[keyof typeof NotFoundErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface ProjectCredentialConfigExistError
 */
export interface ProjectCredentialConfigExistError {
  /**
   *
   * @type {string}
   * @memberof ProjectCredentialConfigExistError
   */
  name: ProjectCredentialConfigExistErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof ProjectCredentialConfigExistError
   */
  message: ProjectCredentialConfigExistErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof ProjectCredentialConfigExistError
   */
  httpStatusCode: ProjectCredentialConfigExistErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof ProjectCredentialConfigExistError
   */
  traceId: string
  /**
   *
   * @type {Array<ActionForbiddenErrorDetailsInner>}
   * @memberof ProjectCredentialConfigExistError
   */
  details?: Array<ActionForbiddenErrorDetailsInner>
}

export const ProjectCredentialConfigExistErrorNameEnum = {
  ProjectCredentialConfigExistError: 'ProjectCredentialConfigExistError',
} as const

export type ProjectCredentialConfigExistErrorNameEnum =
  (typeof ProjectCredentialConfigExistErrorNameEnum)[keyof typeof ProjectCredentialConfigExistErrorNameEnum]
export const ProjectCredentialConfigExistErrorMessageEnum = {
  CredentialConfigIsExistForTheProjectOneConfigIsAllowedForEachProject:
    'Credential config is exist for the project, one config is allowed for each project',
} as const

export type ProjectCredentialConfigExistErrorMessageEnum =
  (typeof ProjectCredentialConfigExistErrorMessageEnum)[keyof typeof ProjectCredentialConfigExistErrorMessageEnum]
export const ProjectCredentialConfigExistErrorHttpStatusCodeEnum = {
  NUMBER_400: 400,
} as const

export type ProjectCredentialConfigExistErrorHttpStatusCodeEnum =
  (typeof ProjectCredentialConfigExistErrorHttpStatusCodeEnum)[keyof typeof ProjectCredentialConfigExistErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface ProjectCredentialConfigNotExistError
 */
export interface ProjectCredentialConfigNotExistError {
  /**
   *
   * @type {string}
   * @memberof ProjectCredentialConfigNotExistError
   */
  name: ProjectCredentialConfigNotExistErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof ProjectCredentialConfigNotExistError
   */
  message: ProjectCredentialConfigNotExistErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof ProjectCredentialConfigNotExistError
   */
  httpStatusCode: ProjectCredentialConfigNotExistErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof ProjectCredentialConfigNotExistError
   */
  traceId: string
  /**
   *
   * @type {Array<ActionForbiddenErrorDetailsInner>}
   * @memberof ProjectCredentialConfigNotExistError
   */
  details?: Array<ActionForbiddenErrorDetailsInner>
}

export const ProjectCredentialConfigNotExistErrorNameEnum = {
  ProjectCredentialConfigNotExistError: 'ProjectCredentialConfigNotExistError',
} as const

export type ProjectCredentialConfigNotExistErrorNameEnum =
  (typeof ProjectCredentialConfigNotExistErrorNameEnum)[keyof typeof ProjectCredentialConfigNotExistErrorNameEnum]
export const ProjectCredentialConfigNotExistErrorMessageEnum = {
  CredentialConfigIsNotAvailableForTheProject:
    'Credential config is not available for the project',
} as const

export type ProjectCredentialConfigNotExistErrorMessageEnum =
  (typeof ProjectCredentialConfigNotExistErrorMessageEnum)[keyof typeof ProjectCredentialConfigNotExistErrorMessageEnum]
export const ProjectCredentialConfigNotExistErrorHttpStatusCodeEnum = {
  NUMBER_400: 400,
} as const

export type ProjectCredentialConfigNotExistErrorHttpStatusCodeEnum =
  (typeof ProjectCredentialConfigNotExistErrorHttpStatusCodeEnum)[keyof typeof ProjectCredentialConfigNotExistErrorHttpStatusCodeEnum]

/**
 * @type StartIssuance400Response
 * @export
 */
export type StartIssuance400Response =
  | CredentialIssuanceIdExistError
  | CredentialSubjectNotValidError
  | InvalidCredentialTypeError
  | InvalidParameterError
  | MissingHolderDidError
  | ProjectCredentialConfigNotExistError

/**
 *
 * @export
 * @interface StartIssuanceInput
 */
export interface StartIssuanceInput {
  /**
   * In TX_CODE claim mode, additional transaction code will be generated and the Authorization Server expects presentation of the transaction Code by the end-user. If FIXED_HOLDER claim mode is defined, holderDid must be present and service will not generate additional transaction code (NORMAL claimMode is deprecated).
   * @type {string}
   * @memberof StartIssuanceInput
   */
  claimMode?: StartIssuanceInputClaimModeEnum
  /**
   * Holder DID
   * @type {string}
   * @memberof StartIssuanceInput
   */
  holderDid?: string
  /**
   * Website\'s internal identifier. Website may use to get info about the status of issuance flow. If it is not provided, CIS will generate one.
   * @type {string}
   * @memberof StartIssuanceInput
   */
  issuanceId?: string
  /**
   *
   * @type {Array<StartIssuanceInputDataInner>}
   * @memberof StartIssuanceInput
   */
  data: Array<StartIssuanceInputDataInner>
}

export const StartIssuanceInputClaimModeEnum = {
  Normal: 'NORMAL',
  TxCode: 'TX_CODE',
  FixedHolder: 'FIXED_HOLDER',
} as const

export type StartIssuanceInputClaimModeEnum =
  (typeof StartIssuanceInputClaimModeEnum)[keyof typeof StartIssuanceInputClaimModeEnum]

/**
 * Data to be included in issued credential
 * @export
 * @interface StartIssuanceInputDataInner
 */
export interface StartIssuanceInputDataInner {
  /**
   * It is a String that identifies a Credential that is being requested to be issued.
   * @type {string}
   * @memberof StartIssuanceInputDataInner
   */
  credentialTypeId: string
  /**
   * Object of data to be included in the issued credential ,should  match the credential type
   * @type {{ [key: string]: any; }}
   * @memberof StartIssuanceInputDataInner
   */
  credentialData: { [key: string]: any }
  /**
   *
   * @type {StartIssuanceInputDataInnerMetaData}
   * @memberof StartIssuanceInputDataInner
   */
  metaData?: StartIssuanceInputDataInnerMetaData
}
/**
 * Object of metadata to be included in the additionalProperties related to vc
 * @export
 * @interface StartIssuanceInputDataInnerMetaData
 */
export interface StartIssuanceInputDataInnerMetaData {
  /**
   * Date and time when the credential will expire
   * @type {string}
   * @memberof StartIssuanceInputDataInnerMetaData
   */
  expirationDate: string
}
/**
 *
 * @export
 * @interface StartIssuanceResponse
 */
export interface StartIssuanceResponse {
  /**
   * URL where wallet can view offer details
   * @type {string}
   * @memberof StartIssuanceResponse
   */
  credentialOfferUri: string
  /**
   * One time transaction code generated by CIS
   * @type {string}
   * @memberof StartIssuanceResponse
   */
  txCode?: string
  /**
   * Website\'s internal identifier. Website may use to get info about the status of issuance flow. If it is not provided, CIS will generate one.
   * @type {string}
   * @memberof StartIssuanceResponse
   */
  issuanceId: string
  /**
   * Expire time in seconds
   * @type {number}
   * @memberof StartIssuanceResponse
   */
  expiresIn: number
}
/**
 *
 * @export
 * @interface UpdateIssuanceConfigInput
 */
export interface UpdateIssuanceConfigInput {
  /**
   *
   * @type {string}
   * @memberof UpdateIssuanceConfigInput
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof UpdateIssuanceConfigInput
   */
  description?: string
  /**
   * Issuer Wallet id
   * @type {string}
   * @memberof UpdateIssuanceConfigInput
   */
  issuerWalletId?: string
  /**
   * credential offer duration in second
   * @type {number}
   * @memberof UpdateIssuanceConfigInput
   */
  credentialOfferDuration?: number
  /**
   * String identifying the format of this Credential, i.e., ldp_vc. Depending on the format value, the object contains further elements defining the type
   * @type {string}
   * @memberof UpdateIssuanceConfigInput
   */
  format?: UpdateIssuanceConfigInputFormatEnum
  /**
   * Issuer URI
   * @type {string}
   * @memberof UpdateIssuanceConfigInput
   */
  issuerUri?: string
  /**
   *
   * @type {Array<CreateIssuanceConfigInputCredentialSupportedInner>}
   * @memberof UpdateIssuanceConfigInput
   */
  credentialSupported?: Array<CreateIssuanceConfigInputCredentialSupportedInner>
  /**
   * Issuer public information wallet may want to show to user during consent confirmation
   * @type {{ [key: string]: any; }}
   * @memberof UpdateIssuanceConfigInput
   */
  issuerMetadata?: { [key: string]: any }
}

export const UpdateIssuanceConfigInputFormatEnum = {
  LdpVc: 'ldp_vc',
  JwtVcJsonLd: 'jwt_vc_json-ld',
} as const

export type UpdateIssuanceConfigInputFormatEnum =
  (typeof UpdateIssuanceConfigInputFormatEnum)[keyof typeof UpdateIssuanceConfigInputFormatEnum]

/**
 *
 * @export
 * @interface VcClaimedError
 */
export interface VcClaimedError {
  /**
   *
   * @type {string}
   * @memberof VcClaimedError
   */
  name: VcClaimedErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof VcClaimedError
   */
  message: VcClaimedErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof VcClaimedError
   */
  httpStatusCode: VcClaimedErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof VcClaimedError
   */
  traceId: string
  /**
   *
   * @type {Array<ActionForbiddenErrorDetailsInner>}
   * @memberof VcClaimedError
   */
  details?: Array<ActionForbiddenErrorDetailsInner>
}

export const VcClaimedErrorNameEnum = {
  VcClaimedError: 'VcClaimedError',
} as const

export type VcClaimedErrorNameEnum =
  (typeof VcClaimedErrorNameEnum)[keyof typeof VcClaimedErrorNameEnum]
export const VcClaimedErrorMessageEnum = {
  TheRequestedVcHasAlreadyBeenClaimedByTheUser:
    'The requested VC has already been claimed by the user',
} as const

export type VcClaimedErrorMessageEnum =
  (typeof VcClaimedErrorMessageEnum)[keyof typeof VcClaimedErrorMessageEnum]
export const VcClaimedErrorHttpStatusCodeEnum = {
  NUMBER_400: 400,
} as const

export type VcClaimedErrorHttpStatusCodeEnum =
  (typeof VcClaimedErrorHttpStatusCodeEnum)[keyof typeof VcClaimedErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface WellKnownOpenIdCredentialIssuerResponse
 */
export interface WellKnownOpenIdCredentialIssuerResponse {
  [key: string]: any

  /**
   *
   * @type {string}
   * @memberof WellKnownOpenIdCredentialIssuerResponse
   */
  authorization_endpoint?: string
  /**
   *
   * @type {string}
   * @memberof WellKnownOpenIdCredentialIssuerResponse
   */
  credential_endpoint?: string
  /**
   *
   * @type {string}
   * @memberof WellKnownOpenIdCredentialIssuerResponse
   */
  credential_issuer?: string
  /**
   *
   * @type {Array<IssuanceConfigDtoCredentialSupportedInner>}
   * @memberof WellKnownOpenIdCredentialIssuerResponse
   */
  credentials_supported?: Array<IssuanceConfigDtoCredentialSupportedInner>
  /**
   *
   * @type {string}
   * @memberof WellKnownOpenIdCredentialIssuerResponse
   */
  deferred_credential_endpoint?: string
  /**
   *
   * @type {Array<string>}
   * @memberof WellKnownOpenIdCredentialIssuerResponse
   */
  grant_types_supported?: Array<WellKnownOpenIdCredentialIssuerResponseGrantTypesSupportedEnum>
  /**
   *
   * @type {string}
   * @memberof WellKnownOpenIdCredentialIssuerResponse
   */
  jwks_uri?: string
  /**
   *
   * @type {Array<string>}
   * @memberof WellKnownOpenIdCredentialIssuerResponse
   */
  scopes_supported?: Array<WellKnownOpenIdCredentialIssuerResponseScopesSupportedEnum>
  /**
   *
   * @type {string}
   * @memberof WellKnownOpenIdCredentialIssuerResponse
   */
  token_endpoint?: string
  /**
   *
   * @type {Array<string>}
   * @memberof WellKnownOpenIdCredentialIssuerResponse
   */
  token_endpoint_auth_methods_supported?: Array<WellKnownOpenIdCredentialIssuerResponseTokenEndpointAuthMethodsSupportedEnum>
}

export const WellKnownOpenIdCredentialIssuerResponseGrantTypesSupportedEnum = {
  AuthorizationCode: 'authorization_code',
  UrnietfparamsoauthgrantTypepreAuthorizedCode:
    'urn:ietf:params:oauth:grant-type:pre-authorized_code',
} as const

export type WellKnownOpenIdCredentialIssuerResponseGrantTypesSupportedEnum =
  (typeof WellKnownOpenIdCredentialIssuerResponseGrantTypesSupportedEnum)[keyof typeof WellKnownOpenIdCredentialIssuerResponseGrantTypesSupportedEnum]
export const WellKnownOpenIdCredentialIssuerResponseScopesSupportedEnum = {
  Openid: 'openid',
} as const

export type WellKnownOpenIdCredentialIssuerResponseScopesSupportedEnum =
  (typeof WellKnownOpenIdCredentialIssuerResponseScopesSupportedEnum)[keyof typeof WellKnownOpenIdCredentialIssuerResponseScopesSupportedEnum]
export const WellKnownOpenIdCredentialIssuerResponseTokenEndpointAuthMethodsSupportedEnum =
  {
    ClientSecretPost: 'client_secret_post',
    ClientSecretBasic: 'client_secret_basic',
    None: 'none',
  } as const

export type WellKnownOpenIdCredentialIssuerResponseTokenEndpointAuthMethodsSupportedEnum =
  (typeof WellKnownOpenIdCredentialIssuerResponseTokenEndpointAuthMethodsSupportedEnum)[keyof typeof WellKnownOpenIdCredentialIssuerResponseTokenEndpointAuthMethodsSupportedEnum]

/**
 * ConfigurationApi - axios parameter creator
 * @export
 */
export const ConfigurationApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Create issuance configuration, project have only one configuration
     * @param {CreateIssuanceConfigInput} createIssuanceConfigInput Request body of create configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createIssuanceConfig: async (
      createIssuanceConfigInput: CreateIssuanceConfigInput,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createIssuanceConfigInput' is not null or undefined
      assertParamExists(
        'createIssuanceConfig',
        'createIssuanceConfigInput',
        createIssuanceConfigInput,
      )
      const localVarPath = `/v1/configurations`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        createIssuanceConfigInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete project issuance configuration
     * @param {string} configurationId The id of the issuance configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteIssuanceConfigById: async (
      configurationId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'configurationId' is not null or undefined
      assertParamExists(
        'deleteIssuanceConfigById',
        'configurationId',
        configurationId,
      )
      const localVarPath = `/v1/configurations/{configurationId}`.replace(
        `{${'configurationId'}}`,
        encodeURIComponent(String(configurationId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get issuance configuration by id
     * @param {string} configurationId The id of the issuance configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIssuanceConfigById: async (
      configurationId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'configurationId' is not null or undefined
      assertParamExists(
        'getIssuanceConfigById',
        'configurationId',
        configurationId,
      )
      const localVarPath = `/v1/configurations/{configurationId}`.replace(
        `{${'configurationId'}}`,
        encodeURIComponent(String(configurationId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get issuance configuration for my selected project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIssuanceConfigList: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/configurations`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update issuance configuration
     * @param {string} configurationId The id of the issuance configuration
     * @param {UpdateIssuanceConfigInput} updateIssuanceConfigInput Request body of update configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateIssuanceConfigById: async (
      configurationId: string,
      updateIssuanceConfigInput: UpdateIssuanceConfigInput,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'configurationId' is not null or undefined
      assertParamExists(
        'updateIssuanceConfigById',
        'configurationId',
        configurationId,
      )
      // verify required parameter 'updateIssuanceConfigInput' is not null or undefined
      assertParamExists(
        'updateIssuanceConfigById',
        'updateIssuanceConfigInput',
        updateIssuanceConfigInput,
      )
      const localVarPath = `/v1/configurations/{configurationId}`.replace(
        `{${'configurationId'}}`,
        encodeURIComponent(String(configurationId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateIssuanceConfigInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ConfigurationApi - functional programming interface
 * @export
 */
export const ConfigurationApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ConfigurationApiAxiosParamCreator(configuration)
  return {
    /**
     * Create issuance configuration, project have only one configuration
     * @param {CreateIssuanceConfigInput} createIssuanceConfigInput Request body of create configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createIssuanceConfig(
      createIssuanceConfigInput: CreateIssuanceConfigInput,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<IssuanceConfigDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createIssuanceConfig(
          createIssuanceConfigInput,
          options,
        )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['ConfigurationApi.createIssuanceConfig']?.[index]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
    /**
     * Delete project issuance configuration
     * @param {string} configurationId The id of the issuance configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteIssuanceConfigById(
      configurationId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteIssuanceConfigById(
          configurationId,
          options,
        )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['ConfigurationApi.deleteIssuanceConfigById']?.[index]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
    /**
     * Get issuance configuration by id
     * @param {string} configurationId The id of the issuance configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getIssuanceConfigById(
      configurationId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<IssuanceConfigDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getIssuanceConfigById(
          configurationId,
          options,
        )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['ConfigurationApi.getIssuanceConfigById']?.[index]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
    /**
     * Get issuance configuration for my selected project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getIssuanceConfigList(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<IssuanceConfigListResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getIssuanceConfigList(options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['ConfigurationApi.getIssuanceConfigList']?.[index]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
    /**
     * Update issuance configuration
     * @param {string} configurationId The id of the issuance configuration
     * @param {UpdateIssuanceConfigInput} updateIssuanceConfigInput Request body of update configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateIssuanceConfigById(
      configurationId: string,
      updateIssuanceConfigInput: UpdateIssuanceConfigInput,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<IssuanceConfigDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateIssuanceConfigById(
          configurationId,
          updateIssuanceConfigInput,
          options,
        )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['ConfigurationApi.updateIssuanceConfigById']?.[index]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
  }
}

/**
 * ConfigurationApi - factory interface
 * @export
 */
export const ConfigurationApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ConfigurationApiFp(configuration)
  return {
    /**
     * Create issuance configuration, project have only one configuration
     * @param {CreateIssuanceConfigInput} createIssuanceConfigInput Request body of create configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createIssuanceConfig(
      createIssuanceConfigInput: CreateIssuanceConfigInput,
      options?: any,
    ): AxiosPromise<IssuanceConfigDto> {
      return localVarFp
        .createIssuanceConfig(createIssuanceConfigInput, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete project issuance configuration
     * @param {string} configurationId The id of the issuance configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteIssuanceConfigById(
      configurationId: string,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .deleteIssuanceConfigById(configurationId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get issuance configuration by id
     * @param {string} configurationId The id of the issuance configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIssuanceConfigById(
      configurationId: string,
      options?: any,
    ): AxiosPromise<IssuanceConfigDto> {
      return localVarFp
        .getIssuanceConfigById(configurationId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get issuance configuration for my selected project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIssuanceConfigList(
      options?: any,
    ): AxiosPromise<IssuanceConfigListResponse> {
      return localVarFp
        .getIssuanceConfigList(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update issuance configuration
     * @param {string} configurationId The id of the issuance configuration
     * @param {UpdateIssuanceConfigInput} updateIssuanceConfigInput Request body of update configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateIssuanceConfigById(
      configurationId: string,
      updateIssuanceConfigInput: UpdateIssuanceConfigInput,
      options?: any,
    ): AxiosPromise<IssuanceConfigDto> {
      return localVarFp
        .updateIssuanceConfigById(
          configurationId,
          updateIssuanceConfigInput,
          options,
        )
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ConfigurationApi - object-oriented interface
 * @export
 * @class ConfigurationApi
 * @extends {BaseAPI}
 */
export class ConfigurationApi extends BaseAPI {
  /**
   * Create issuance configuration, project have only one configuration
   * @param {CreateIssuanceConfigInput} createIssuanceConfigInput Request body of create configuration
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConfigurationApi
   */
  public createIssuanceConfig(
    createIssuanceConfigInput: CreateIssuanceConfigInput,
    options?: RawAxiosRequestConfig,
  ) {
    return ConfigurationApiFp(this.configuration)
      .createIssuanceConfig(createIssuanceConfigInput, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete project issuance configuration
   * @param {string} configurationId The id of the issuance configuration
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConfigurationApi
   */
  public deleteIssuanceConfigById(
    configurationId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ConfigurationApiFp(this.configuration)
      .deleteIssuanceConfigById(configurationId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get issuance configuration by id
   * @param {string} configurationId The id of the issuance configuration
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConfigurationApi
   */
  public getIssuanceConfigById(
    configurationId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ConfigurationApiFp(this.configuration)
      .getIssuanceConfigById(configurationId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get issuance configuration for my selected project
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConfigurationApi
   */
  public getIssuanceConfigList(options?: RawAxiosRequestConfig) {
    return ConfigurationApiFp(this.configuration)
      .getIssuanceConfigList(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update issuance configuration
   * @param {string} configurationId The id of the issuance configuration
   * @param {UpdateIssuanceConfigInput} updateIssuanceConfigInput Request body of update configuration
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConfigurationApi
   */
  public updateIssuanceConfigById(
    configurationId: string,
    updateIssuanceConfigInput: UpdateIssuanceConfigInput,
    options?: RawAxiosRequestConfig,
  ) {
    return ConfigurationApiFp(this.configuration)
      .updateIssuanceConfigById(
        configurationId,
        updateIssuanceConfigInput,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * CredentialsApi - axios parameter creator
 * @export
 */
export const CredentialsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Issue credential for end user upon presentation a valid access token. Since we don\'t immediate issue credential It\'s expected to return `transaction_id` and use this `transaction_id` to get the deferred credentials
     * @param {string} projectId Affinidi project id
     * @param {CreateCredentialInput} createCredentialInput Request body to issue credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateCredentials: async (
      projectId: string,
      createCredentialInput: CreateCredentialInput,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists('generateCredentials', 'projectId', projectId)
      // verify required parameter 'createCredentialInput' is not null or undefined
      assertParamExists(
        'generateCredentials',
        'createCredentialInput',
        createCredentialInput,
      )
      const localVarPath = `/v1/{projectId}/credential`.replace(
        `{${'projectId'}}`,
        encodeURIComponent(String(projectId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration)

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        createCredentialInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * CredentialsApi - functional programming interface
 * @export
 */
export const CredentialsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    CredentialsApiAxiosParamCreator(configuration)
  return {
    /**
     * Issue credential for end user upon presentation a valid access token. Since we don\'t immediate issue credential It\'s expected to return `transaction_id` and use this `transaction_id` to get the deferred credentials
     * @param {string} projectId Affinidi project id
     * @param {CreateCredentialInput} createCredentialInput Request body to issue credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async generateCredentials(
      projectId: string,
      createCredentialInput: CreateCredentialInput,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<CredentialResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.generateCredentials(
          projectId,
          createCredentialInput,
          options,
        )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['CredentialsApi.generateCredentials']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
  }
}

/**
 * CredentialsApi - factory interface
 * @export
 */
export const CredentialsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = CredentialsApiFp(configuration)
  return {
    /**
     * Issue credential for end user upon presentation a valid access token. Since we don\'t immediate issue credential It\'s expected to return `transaction_id` and use this `transaction_id` to get the deferred credentials
     * @param {string} projectId Affinidi project id
     * @param {CreateCredentialInput} createCredentialInput Request body to issue credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateCredentials(
      projectId: string,
      createCredentialInput: CreateCredentialInput,
      options?: any,
    ): AxiosPromise<CredentialResponse> {
      return localVarFp
        .generateCredentials(projectId, createCredentialInput, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * CredentialsApi - object-oriented interface
 * @export
 * @class CredentialsApi
 * @extends {BaseAPI}
 */
export class CredentialsApi extends BaseAPI {
  /**
   * Issue credential for end user upon presentation a valid access token. Since we don\'t immediate issue credential It\'s expected to return `transaction_id` and use this `transaction_id` to get the deferred credentials
   * @param {string} projectId Affinidi project id
   * @param {CreateCredentialInput} createCredentialInput Request body to issue credentials
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CredentialsApi
   */
  public generateCredentials(
    projectId: string,
    createCredentialInput: CreateCredentialInput,
    options?: RawAxiosRequestConfig,
  ) {
    return CredentialsApiFp(this.configuration)
      .generateCredentials(projectId, createCredentialInput, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * IssuanceApi - axios parameter creator
 * @export
 */
export const IssuanceApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Get issuance status
     * @param {string} issuanceId
     * @param {string} projectId Affinidi project id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    issuanceState: async (
      issuanceId: string,
      projectId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'issuanceId' is not null or undefined
      assertParamExists('issuanceState', 'issuanceId', issuanceId)
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists('issuanceState', 'projectId', projectId)
      const localVarPath = `/v1/{projectId}/issuance/state/{issuanceId}`
        .replace(`{${'issuanceId'}}`, encodeURIComponent(String(issuanceId)))
        .replace(`{${'projectId'}}`, encodeURIComponent(String(projectId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List all issuances for Project
     * @param {string} projectId Affinidi project id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listIssuance: async (
      projectId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists('listIssuance', 'projectId', projectId)
      const localVarPath = `/v1/{projectId}/issuance`.replace(
        `{${'projectId'}}`,
        encodeURIComponent(String(projectId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Endpoint used b websites to start the issuance process
     * @param {string} projectId Affinidi project id
     * @param {StartIssuanceInput} startIssuanceInput Request body to start issuance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startIssuance: async (
      projectId: string,
      startIssuanceInput: StartIssuanceInput,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists('startIssuance', 'projectId', projectId)
      // verify required parameter 'startIssuanceInput' is not null or undefined
      assertParamExists(
        'startIssuance',
        'startIssuanceInput',
        startIssuanceInput,
      )
      const localVarPath = `/v1/{projectId}/issuance/start`.replace(
        `{${'projectId'}}`,
        encodeURIComponent(String(projectId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        startIssuanceInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * IssuanceApi - functional programming interface
 * @export
 */
export const IssuanceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = IssuanceApiAxiosParamCreator(configuration)
  return {
    /**
     * Get issuance status
     * @param {string} issuanceId
     * @param {string} projectId Affinidi project id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async issuanceState(
      issuanceId: string,
      projectId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<IssuanceStateResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.issuanceState(
        issuanceId,
        projectId,
        options,
      )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['IssuanceApi.issuanceState']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
    /**
     * List all issuances for Project
     * @param {string} projectId Affinidi project id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listIssuance(
      projectId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ListIssuanceResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listIssuance(
        projectId,
        options,
      )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['IssuanceApi.listIssuance']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
    /**
     * Endpoint used b websites to start the issuance process
     * @param {string} projectId Affinidi project id
     * @param {StartIssuanceInput} startIssuanceInput Request body to start issuance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async startIssuance(
      projectId: string,
      startIssuanceInput: StartIssuanceInput,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<StartIssuanceResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.startIssuance(
        projectId,
        startIssuanceInput,
        options,
      )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['IssuanceApi.startIssuance']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
  }
}

/**
 * IssuanceApi - factory interface
 * @export
 */
export const IssuanceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = IssuanceApiFp(configuration)
  return {
    /**
     * Get issuance status
     * @param {string} issuanceId
     * @param {string} projectId Affinidi project id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    issuanceState(
      issuanceId: string,
      projectId: string,
      options?: any,
    ): AxiosPromise<IssuanceStateResponse> {
      return localVarFp
        .issuanceState(issuanceId, projectId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * List all issuances for Project
     * @param {string} projectId Affinidi project id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listIssuance(
      projectId: string,
      options?: any,
    ): AxiosPromise<ListIssuanceResponse> {
      return localVarFp
        .listIssuance(projectId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Endpoint used b websites to start the issuance process
     * @param {string} projectId Affinidi project id
     * @param {StartIssuanceInput} startIssuanceInput Request body to start issuance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startIssuance(
      projectId: string,
      startIssuanceInput: StartIssuanceInput,
      options?: any,
    ): AxiosPromise<StartIssuanceResponse> {
      return localVarFp
        .startIssuance(projectId, startIssuanceInput, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * IssuanceApi - object-oriented interface
 * @export
 * @class IssuanceApi
 * @extends {BaseAPI}
 */
export class IssuanceApi extends BaseAPI {
  /**
   * Get issuance status
   * @param {string} issuanceId
   * @param {string} projectId Affinidi project id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IssuanceApi
   */
  public issuanceState(
    issuanceId: string,
    projectId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return IssuanceApiFp(this.configuration)
      .issuanceState(issuanceId, projectId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List all issuances for Project
   * @param {string} projectId Affinidi project id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IssuanceApi
   */
  public listIssuance(projectId: string, options?: RawAxiosRequestConfig) {
    return IssuanceApiFp(this.configuration)
      .listIssuance(projectId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Endpoint used b websites to start the issuance process
   * @param {string} projectId Affinidi project id
   * @param {StartIssuanceInput} startIssuanceInput Request body to start issuance
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IssuanceApi
   */
  public startIssuance(
    projectId: string,
    startIssuanceInput: StartIssuanceInput,
    options?: RawAxiosRequestConfig,
  ) {
    return IssuanceApiFp(this.configuration)
      .startIssuance(projectId, startIssuanceInput, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * OfferApi - axios parameter creator
 * @export
 */
export const OfferApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Endpoint used to return Credential Offer details, used with `credential_offer_uri` response
     * @param {string} projectId Affinidi project id
     * @param {string} issuanceId issuanceId from credential_offer_uri
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCredentialOffer: async (
      projectId: string,
      issuanceId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists('getCredentialOffer', 'projectId', projectId)
      // verify required parameter 'issuanceId' is not null or undefined
      assertParamExists('getCredentialOffer', 'issuanceId', issuanceId)
      const localVarPath = `/v1/{projectId}/offers/{issuanceId}`
        .replace(`{${'projectId'}}`, encodeURIComponent(String(projectId)))
        .replace(`{${'issuanceId'}}`, encodeURIComponent(String(issuanceId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * OfferApi - functional programming interface
 * @export
 */
export const OfferApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = OfferApiAxiosParamCreator(configuration)
  return {
    /**
     * Endpoint used to return Credential Offer details, used with `credential_offer_uri` response
     * @param {string} projectId Affinidi project id
     * @param {string} issuanceId issuanceId from credential_offer_uri
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCredentialOffer(
      projectId: string,
      issuanceId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<CredentialOfferResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCredentialOffer(
          projectId,
          issuanceId,
          options,
        )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['OfferApi.getCredentialOffer']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
  }
}

/**
 * OfferApi - factory interface
 * @export
 */
export const OfferApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = OfferApiFp(configuration)
  return {
    /**
     * Endpoint used to return Credential Offer details, used with `credential_offer_uri` response
     * @param {string} projectId Affinidi project id
     * @param {string} issuanceId issuanceId from credential_offer_uri
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCredentialOffer(
      projectId: string,
      issuanceId: string,
      options?: any,
    ): AxiosPromise<CredentialOfferResponse> {
      return localVarFp
        .getCredentialOffer(projectId, issuanceId, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * OfferApi - object-oriented interface
 * @export
 * @class OfferApi
 * @extends {BaseAPI}
 */
export class OfferApi extends BaseAPI {
  /**
   * Endpoint used to return Credential Offer details, used with `credential_offer_uri` response
   * @param {string} projectId Affinidi project id
   * @param {string} issuanceId issuanceId from credential_offer_uri
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OfferApi
   */
  public getCredentialOffer(
    projectId: string,
    issuanceId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return OfferApiFp(this.configuration)
      .getCredentialOffer(projectId, issuanceId, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * WellKnownApi - axios parameter creator
 * @export
 */
export const WellKnownApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {string} projectId Affinidi project id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWellKnownOpenIdCredentialIssuer: async (
      projectId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists(
        'getWellKnownOpenIdCredentialIssuer',
        'projectId',
        projectId,
      )
      const localVarPath =
        `/v1/{projectId}/.well-known/openid-credential-issuer`.replace(
          `{${'projectId'}}`,
          encodeURIComponent(String(projectId)),
        )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * WellKnownApi - functional programming interface
 * @export
 */
export const WellKnownApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = WellKnownApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {string} projectId Affinidi project id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getWellKnownOpenIdCredentialIssuer(
      projectId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<WellKnownOpenIdCredentialIssuerResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getWellKnownOpenIdCredentialIssuer(
          projectId,
          options,
        )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['WellKnownApi.getWellKnownOpenIdCredentialIssuer']?.[
          index
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
  }
}

/**
 * WellKnownApi - factory interface
 * @export
 */
export const WellKnownApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = WellKnownApiFp(configuration)
  return {
    /**
     *
     * @param {string} projectId Affinidi project id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWellKnownOpenIdCredentialIssuer(
      projectId: string,
      options?: any,
    ): AxiosPromise<WellKnownOpenIdCredentialIssuerResponse> {
      return localVarFp
        .getWellKnownOpenIdCredentialIssuer(projectId, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * WellKnownApi - object-oriented interface
 * @export
 * @class WellKnownApi
 * @extends {BaseAPI}
 */
export class WellKnownApi extends BaseAPI {
  /**
   *
   * @param {string} projectId Affinidi project id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WellKnownApi
   */
  public getWellKnownOpenIdCredentialIssuer(
    projectId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return WellKnownApiFp(this.configuration)
      .getWellKnownOpenIdCredentialIssuer(projectId, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
