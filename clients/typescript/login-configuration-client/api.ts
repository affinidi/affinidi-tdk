/* tslint:disable */
/* eslint-disable */
/**
 * OidcVpAdapterBackend
 * Affinidi OIDC VP Adapter Backend  An authorization token is necessary to create or obtain a project Access Token and access Admin APIs. Follow these step-by-step [instructions](https://lemmatree.atlassian.net/wiki/spaces/NETCORE/pages/2735317648020/ASA+Developer+Flow#Instructions-on-how-to-create-the-Project.) to set up an authorization token
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: nucleus.team@affinidi.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration'
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios'
import globalAxios from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common'
import type { RequestArgs } from './base'
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  BaseAPI,
  RequiredError,
  operationServerMap,
} from './base'

/**
 *
 * @export
 * @interface ActionForbiddenError
 */
export interface ActionForbiddenError {
  /**
   *
   * @type {string}
   * @memberof ActionForbiddenError
   */
  name: ActionForbiddenErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof ActionForbiddenError
   */
  message: ActionForbiddenErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof ActionForbiddenError
   */
  httpStatusCode: ActionForbiddenErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof ActionForbiddenError
   */
  traceId: string
  /**
   *
   * @type {Array<InvalidParameterErrorDetailsInner>}
   * @memberof ActionForbiddenError
   */
  details?: Array<InvalidParameterErrorDetailsInner>
}

export const ActionForbiddenErrorNameEnum = {
  ActionForbiddenError: 'ActionForbiddenError',
} as const

export type ActionForbiddenErrorNameEnum =
  (typeof ActionForbiddenErrorNameEnum)[keyof typeof ActionForbiddenErrorNameEnum]
export const ActionForbiddenErrorMessageEnum = {
  PrincipalCanNotExecuteActionOnGivenResource:
    'Principal can not execute action on given resource',
} as const

export type ActionForbiddenErrorMessageEnum =
  (typeof ActionForbiddenErrorMessageEnum)[keyof typeof ActionForbiddenErrorMessageEnum]
export const ActionForbiddenErrorHttpStatusCodeEnum = {
  NUMBER_403: 403,
} as const

export type ActionForbiddenErrorHttpStatusCodeEnum =
  (typeof ActionForbiddenErrorHttpStatusCodeEnum)[keyof typeof ActionForbiddenErrorHttpStatusCodeEnum]

/**
 * input used to add a user to a group
 * @export
 * @interface AddUserToGroupInput
 */
export interface AddUserToGroupInput {
  /**
   *
   * @type {string}
   * @memberof AddUserToGroupInput
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof AddUserToGroupInput
   */
  description?: string
  /**
   * Unique identifier of the user
   * @type {string}
   * @memberof AddUserToGroupInput
   */
  userId: string
}
/**
 *
 * @export
 * @interface BlockedUsers
 */
export interface BlockedUsers {
  /**
   *
   * @type {Array<string>}
   * @memberof BlockedUsers
   */
  userIds: Array<string>
  /**
   *
   * @type {object}
   * @memberof BlockedUsers
   */
  pageToken?: object
}
/**
 *
 * @export
 * @interface BlockedUsersInput
 */
export interface BlockedUsersInput {
  /**
   *
   * @type {string}
   * @memberof BlockedUsersInput
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof BlockedUsersInput
   */
  description?: string
  /**
   *
   * @type {Array<string>}
   * @memberof BlockedUsersInput
   */
  userIds: Array<string>
}
/**
 *
 * @export
 * @interface CorsLoginSessionAcceptResponseOK
 */
export interface CorsLoginSessionAcceptResponseOK {
  /**
   *
   * @type {string}
   * @memberof CorsLoginSessionAcceptResponseOK
   */
  corsLoginSessionAcceptResponseOk?: string
}
/**
 *
 * @export
 * @interface CorsLoginSessionForIdpOK
 */
export interface CorsLoginSessionForIdpOK {
  /**
   *
   * @type {string}
   * @memberof CorsLoginSessionForIdpOK
   */
  corsLoginSessionForIdpOk?: string
}
/**
 *
 * @export
 * @interface CorsLoginSessionRejectResponseOK
 */
export interface CorsLoginSessionRejectResponseOK {
  /**
   *
   * @type {string}
   * @memberof CorsLoginSessionRejectResponseOK
   */
  corsLoginSessionRejectResponseOk?: string
}
/**
 *
 * @export
 * @interface CreateGroupInput
 */
export interface CreateGroupInput {
  /**
   * name of the group for users, used as an id
   * @type {string}
   * @memberof CreateGroupInput
   */
  groupName: string
  /**
   *
   * @type {string}
   * @memberof CreateGroupInput
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof CreateGroupInput
   */
  description?: string
}
/**
 *
 * @export
 * @interface CreateHydraNetworkError
 */
export interface CreateHydraNetworkError {
  /**
   *
   * @type {string}
   * @memberof CreateHydraNetworkError
   */
  name: CreateHydraNetworkErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof CreateHydraNetworkError
   */
  message: CreateHydraNetworkErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof CreateHydraNetworkError
   */
  httpStatusCode: CreateHydraNetworkErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof CreateHydraNetworkError
   */
  traceId: string
  /**
   *
   * @type {Array<InvalidParameterErrorDetailsInner>}
   * @memberof CreateHydraNetworkError
   */
  details?: Array<InvalidParameterErrorDetailsInner>
}

export const CreateHydraNetworkErrorNameEnum = {
  CreateHydraNetworkError: 'CreateHydraNetworkError',
} as const

export type CreateHydraNetworkErrorNameEnum =
  (typeof CreateHydraNetworkErrorNameEnum)[keyof typeof CreateHydraNetworkErrorNameEnum]
export const CreateHydraNetworkErrorMessageEnum = {
  CreateHydraNetworkError: 'CreateHydraNetworkError',
} as const

export type CreateHydraNetworkErrorMessageEnum =
  (typeof CreateHydraNetworkErrorMessageEnum)[keyof typeof CreateHydraNetworkErrorMessageEnum]
export const CreateHydraNetworkErrorHttpStatusCodeEnum = {
  NUMBER_400: 400,
} as const

export type CreateHydraNetworkErrorHttpStatusCodeEnum =
  (typeof CreateHydraNetworkErrorHttpStatusCodeEnum)[keyof typeof CreateHydraNetworkErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface CreateLoginConfigurationInput
 */
export interface CreateLoginConfigurationInput {
  /**
   * User defined login configuration name
   * @type {string}
   * @memberof CreateLoginConfigurationInput
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof CreateLoginConfigurationInput
   */
  description?: string
  /**
   * OAuth 2.0 Redirect URIs
   * @type {Array<string>}
   * @memberof CreateLoginConfigurationInput
   */
  redirectUris: Array<string>
  /**
   * Post Logout Redirect URIs, Used to redirect the user\'s browser to a specified URL after the logout process is complete. Must match the domain, port, scheme of at least one of the registered redirect URIs
   * @type {Array<string>}
   * @memberof CreateLoginConfigurationInput
   */
  postLogoutRedirectUris?: Array<string>
  /**
   * VP definition in JSON stringify format
   * @type {string}
   * @memberof CreateLoginConfigurationInput
   */
  vpDefinition?: string
  /**
   * Presentation Definition
   * @type {object}
   * @memberof CreateLoginConfigurationInput
   */
  presentationDefinition?: object
  /**
   *
   * @type {IdTokenMapping}
   * @memberof CreateLoginConfigurationInput
   */
  idTokenMapping?: IdTokenMapping
  /**
   *
   * @type {LoginConfigurationClientMetadataInput}
   * @memberof CreateLoginConfigurationInput
   */
  clientMetadata?: LoginConfigurationClientMetadataInput
  /**
   * ID token claims output format. Default is array.
   * @type {string}
   * @memberof CreateLoginConfigurationInput
   */
  claimFormat?: CreateLoginConfigurationInputClaimFormatEnum
  /**
   * Interrupts login process if duplications of data fields names will be found
   * @type {boolean}
   * @memberof CreateLoginConfigurationInput
   */
  failOnMappingConflict?: boolean
  /**
   * List of groups separated by space
   * @type {string}
   * @memberof CreateLoginConfigurationInput
   */
  scope?: string
  /**
   *
   * @type {TokenEndpointAuthMethod}
   * @memberof CreateLoginConfigurationInput
   */
  tokenEndpointAuthMethod?: TokenEndpointAuthMethod
}

export const CreateLoginConfigurationInputClaimFormatEnum = {
  Array: 'array',
  Map: 'map',
} as const

export type CreateLoginConfigurationInputClaimFormatEnum =
  (typeof CreateLoginConfigurationInputClaimFormatEnum)[keyof typeof CreateLoginConfigurationInputClaimFormatEnum]

/**
 *
 * @export
 * @interface CreateLoginConfigurationOutput
 */
export interface CreateLoginConfigurationOutput {
  /**
   * Configuration ari
   * @type {string}
   * @memberof CreateLoginConfigurationOutput
   */
  ari: string
  /**
   * Project id
   * @type {string}
   * @memberof CreateLoginConfigurationOutput
   */
  projectId: string
  /**
   * Configuration id
   * @type {string}
   * @memberof CreateLoginConfigurationOutput
   */
  configurationId?: string
  /**
   * User defined login configuration name
   * @type {string}
   * @memberof CreateLoginConfigurationOutput
   */
  name: string
  /**
   *
   * @type {CreateLoginConfigurationOutputAuth}
   * @memberof CreateLoginConfigurationOutput
   */
  auth: CreateLoginConfigurationOutputAuth
  /**
   * OAuth 2.0 Redirect URIs
   * @type {Array<string>}
   * @memberof CreateLoginConfigurationOutput
   */
  redirectUris: Array<string>
  /**
   *
   * @type {LoginConfigurationClientMetadataOutput}
   * @memberof CreateLoginConfigurationOutput
   */
  clientMetadata: LoginConfigurationClientMetadataOutput
  /**
   * OAuth 2.0 Client Creation Date
   * @type {string}
   * @memberof CreateLoginConfigurationOutput
   */
  creationDate: string
  /**
   * Post Logout Redirect URIs, Used to redirect the user\'s browser to a specified URL after the logout process is complete. Must match the domain, port, scheme of at least one of the registered redirect URIs
   * @type {Array<string>}
   * @memberof CreateLoginConfigurationOutput
   */
  postLogoutRedirectUris?: Array<string>
}
/**
 * OIDC Auth Credentials
 * @export
 * @interface CreateLoginConfigurationOutputAuth
 */
export interface CreateLoginConfigurationOutputAuth {
  /**
   * OAuth 2.0 Client ID
   * @type {string}
   * @memberof CreateLoginConfigurationOutputAuth
   */
  clientId: string
  /**
   * OAuth 2.0 Client Secret
   * @type {string}
   * @memberof CreateLoginConfigurationOutputAuth
   */
  clientSecret?: string
  /**
   * OAuth 2.0 Client Scope
   * @type {string}
   * @memberof CreateLoginConfigurationOutputAuth
   */
  scope?: string
  /**
   * Issuer URL
   * @type {string}
   * @memberof CreateLoginConfigurationOutputAuth
   */
  issuer?: string
}
/**
 * @type CreateLoginConfigurations400Response
 * @export
 */
export type CreateLoginConfigurations400Response =
  | CreateHydraNetworkError
  | CreateProjectNetworkError
  | InvalidParameterError

/**
 *
 * @export
 * @interface CreateProjectNetworkError
 */
export interface CreateProjectNetworkError {
  /**
   *
   * @type {string}
   * @memberof CreateProjectNetworkError
   */
  name: CreateProjectNetworkErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof CreateProjectNetworkError
   */
  message: CreateProjectNetworkErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof CreateProjectNetworkError
   */
  httpStatusCode: CreateProjectNetworkErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof CreateProjectNetworkError
   */
  traceId: string
  /**
   *
   * @type {Array<InvalidParameterErrorDetailsInner>}
   * @memberof CreateProjectNetworkError
   */
  details?: Array<InvalidParameterErrorDetailsInner>
}

export const CreateProjectNetworkErrorNameEnum = {
  CreateProjectNetworkError: 'CreateProjectNetworkError',
} as const

export type CreateProjectNetworkErrorNameEnum =
  (typeof CreateProjectNetworkErrorNameEnum)[keyof typeof CreateProjectNetworkErrorNameEnum]
export const CreateProjectNetworkErrorMessageEnum = {
  CreateProjectNetworkError: 'CreateProjectNetworkError',
} as const

export type CreateProjectNetworkErrorMessageEnum =
  (typeof CreateProjectNetworkErrorMessageEnum)[keyof typeof CreateProjectNetworkErrorMessageEnum]
export const CreateProjectNetworkErrorHttpStatusCodeEnum = {
  NUMBER_400: 400,
} as const

export type CreateProjectNetworkErrorHttpStatusCodeEnum =
  (typeof CreateProjectNetworkErrorHttpStatusCodeEnum)[keyof typeof CreateProjectNetworkErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface ErrorOAuth2
 */
export interface ErrorOAuth2 {
  /**
   * Error
   * @type {string}
   * @memberof ErrorOAuth2
   */
  error: string
  /**
   * Error Debug Information. Only available in dev mode.
   * @type {string}
   * @memberof ErrorOAuth2
   */
  error_debug?: string
  /**
   * Error Description
   * @type {string}
   * @memberof ErrorOAuth2
   */
  error_description: string
  /**
   * Error Hint. Helps the user identify the error cause.
   * @type {string}
   * @memberof ErrorOAuth2
   */
  error_hint?: string
  /**
   * HTTP Status Code
   * @type {string}
   * @memberof ErrorOAuth2
   */
  status_code: string
}
/**
 *
 * @export
 * @interface GetUserInfo
 */
export interface GetUserInfo {
  /**
   * End-User\'s birthday, represented as an ISO 8601:2004 [ISO8601‑2004] YYYY-MM-DD format.  The year MAY be 0000, indicating that it is omitted. To represent only the year,  YYYY format is allowed. Note that depending on the underlying platform\'s date related  function, providing just year can result in varying month and day, so the implementers  need to take this factor into account to correctly process the dates.
   * @type {string}
   * @memberof GetUserInfo
   */
  birthdate?: string
  /**
   * End-User\'s preferred e-mail address. Its value MUST conform to the RFC 5322 [RFC5322]  addr-spec syntax. The RP MUST NOT rely upon this value being unique, as discussed in Section 5.7.
   * @type {string}
   * @memberof GetUserInfo
   */
  email?: string
  /**
   * True if the End-User\'s e-mail address has been verified; otherwise false. When this  Claim Value is true, this means that the OP took affirmative steps to ensure that  this e-mail address was controlled by the End-User at the time the verification was  performed. The means by which an e-mail address is verified is context-specific, and  dependent upon the trust framework or contractual agreements within which the parties  are operating.
   * @type {boolean}
   * @memberof GetUserInfo
   */
  email_verified?: boolean
  /**
   * Surname(s) or last name(s) of the End-User. Note that in some cultures, people can have  multiple family names or no family name; all can be present, with the names being  separated by space characters.
   * @type {string}
   * @memberof GetUserInfo
   */
  family_name?: string
  /**
   * End-User\'s gender. Values defined by this specification are female and male.  Other values MAY be used when neither of the defined values are applicable.
   * @type {string}
   * @memberof GetUserInfo
   */
  gender?: string
  /**
   * Given name(s) or first name(s) of the End-User. Note that in some cultures,  people can have multiple given names; all can be present, with the names being  separated by space characters.
   * @type {string}
   * @memberof GetUserInfo
   */
  given_name?: string
  /**
   * End-User\'s locale, represented as a BCP47 [RFC5646] language tag. This is  typically an ISO 639-1 Alpha-2 [ISO639‑1] language code in lowercase and an  ISO 3166-1 Alpha-2 [ISO3166‑1] country code in uppercase, separated by a dash.  For example, en-US or fr-CA. As a compatibility note, some implementations have  used an underscore as the separator rather than a dash, for example, en_US;  Relying Parties MAY choose to accept this locale syntax as well.
   * @type {string}
   * @memberof GetUserInfo
   */
  locale?: string
  /**
   * Middle name(s) of the End-User. Note that in some cultures, people can have  multiple middle names; all can be present, with the names being separated by  space characters. Also note that in some cultures, middle names are not used.
   * @type {string}
   * @memberof GetUserInfo
   */
  middle_name?: string
  /**
   * End-User\'s full name in displayable form including all name parts, possibly  including titles and suffixes, ordered according to the End-User\'s locale and preferences.
   * @type {string}
   * @memberof GetUserInfo
   */
  name?: string
  /**
   * Casual name of the End-User that may or may not be the same as the given_name.  For instance, a nickname value of Mike might be returned alongside a given_name value of Michael.
   * @type {string}
   * @memberof GetUserInfo
   */
  nickname?: string
  /**
   * End-User\'s preferred telephone number. E.164 [E.164] is RECOMMENDED as the format of this Claim,  for example, +1 (425) 555-1212 or +56 (2) 687 2400. If the phone number contains an extension,  it is RECOMMENDED that the extension be represented using the RFC 3966 [RFC3966] extension syntax,  for example, +1 (604) 555-1234;ext=5678.
   * @type {string}
   * @memberof GetUserInfo
   */
  phone_number?: string
  /**
   * True if the End-User\'s phone number has been verified; otherwise false. When this Claim  Value is true, this means that the OP took affirmative steps to ensure that this phone  number was controlled by the End-User at the time the verification was performed. The means  by which a phone number is verified is context-specific, and dependent upon the trust framework  or contractual agreements within which the parties are operating. When true, the phone_number  Claim MUST be in E.164 format and any extensions MUST be represented in RFC 3966 format.
   * @type {boolean}
   * @memberof GetUserInfo
   */
  phone_number_verified?: boolean
  /**
   * URL of the End-User\'s profile picture. This URL MUST refer to an image file (for example, a PNG,  JPEG, or GIF image file), rather than to a Web page containing an image. Note that this URL SHOULD specifically reference a profile photo of the End-User suitable for displaying when describing the  End-User, rather than an arbitrary photo taken by the End-User.
   * @type {string}
   * @memberof GetUserInfo
   */
  picture?: string
  /**
   * Non-unique shorthand name by which the End-User wishes to be referred to at the RP, such as  janedoe or j.doe. This value MAY be any valid JSON string including special characters  such as @, /, or whitespace.
   * @type {string}
   * @memberof GetUserInfo
   */
  preferred_username?: string
  /**
   * URL of the End-User\'s profile page. The contents of this Web page SHOULD be about the End-User.
   * @type {string}
   * @memberof GetUserInfo
   */
  profile?: string
  /**
   * Subject - Identifier for the End-User at the IssuerURL.
   * @type {string}
   * @memberof GetUserInfo
   */
  sub?: string
  /**
   * Time the End-User\'s information was last updated. Its value is a JSON number  representing the number of seconds from 1970-01-01T0:0:0Z as measured in UTC until the date/time.
   * @type {number}
   * @memberof GetUserInfo
   */
  updated_at?: number
  /**
   * URL of the End-User\'s Web page or blog. This Web page SHOULD contain information  published by the End-User or an organization that the End-User is affiliated with.
   * @type {string}
   * @memberof GetUserInfo
   */
  website?: string
  /**
   * String from zoneinfo [zoneinfo] time zone database representing the End-User\'s  time zone. For example, Europe/Paris or America/Los_Angeles.
   * @type {string}
   * @memberof GetUserInfo
   */
  zoneinfo?: string
}
/**
 *
 * @export
 * @interface GroupDto
 */
export interface GroupDto {
  /**
   * Group ari
   * @type {string}
   * @memberof GroupDto
   */
  ari: string
  /**
   * Project id
   * @type {string}
   * @memberof GroupDto
   */
  projectId: string
  /**
   * name of the group, identifier within a project
   * @type {string}
   * @memberof GroupDto
   */
  groupName: string
  /**
   * Group creation date
   * @type {string}
   * @memberof GroupDto
   */
  creationDate: string
}
/**
 *
 * @export
 * @interface GroupNames
 */
export interface GroupNames {
  /**
   *
   * @type {Array<string>}
   * @memberof GroupNames
   */
  groupNames: Array<string>
  /**
   *
   * @type {object}
   * @memberof GroupNames
   */
  pageToken?: object
}
/**
 *
 * @export
 * @interface GroupNamesInput
 */
export interface GroupNamesInput {
  /**
   *
   * @type {Array<string>}
   * @memberof GroupNamesInput
   */
  groupNames: Array<string>
}
/**
 *
 * @export
 * @interface GroupUserMappingDto
 */
export interface GroupUserMappingDto {
  /**
   * Unique identifier of the user
   * @type {string}
   * @memberof GroupUserMappingDto
   */
  userId: string
  /**
   * Group to user mapping creation date
   * @type {string}
   * @memberof GroupUserMappingDto
   */
  addedAt: string
}
/**
 *
 * @export
 * @interface GroupUserMappingsList
 */
export interface GroupUserMappingsList {
  /**
   *
   * @type {Array<GroupUserMappingDto>}
   * @memberof GroupUserMappingsList
   */
  users?: Array<GroupUserMappingDto>
  /**
   *
   * @type {string}
   * @memberof GroupUserMappingsList
   */
  lastEvaluatedKey?: string
  /**
   *
   * @type {number}
   * @memberof GroupUserMappingsList
   */
  totalUserCount?: number
}
/**
 *
 * @export
 * @interface GroupsList
 */
export interface GroupsList {
  /**
   *
   * @type {Array<GroupDto>}
   * @memberof GroupsList
   */
  groups?: Array<GroupDto>
}
/**
 *
 * @export
 * @interface GroupsPerUserLimitExceededError
 */
export interface GroupsPerUserLimitExceededError {
  /**
   *
   * @type {string}
   * @memberof GroupsPerUserLimitExceededError
   */
  name: GroupsPerUserLimitExceededErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof GroupsPerUserLimitExceededError
   */
  message: GroupsPerUserLimitExceededErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof GroupsPerUserLimitExceededError
   */
  httpStatusCode: GroupsPerUserLimitExceededErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof GroupsPerUserLimitExceededError
   */
  traceId: string
  /**
   *
   * @type {Array<InvalidParameterErrorDetailsInner>}
   * @memberof GroupsPerUserLimitExceededError
   */
  details?: Array<InvalidParameterErrorDetailsInner>
}

export const GroupsPerUserLimitExceededErrorNameEnum = {
  GroupsPerUserLimitExceededError: 'GroupsPerUserLimitExceededError',
} as const

export type GroupsPerUserLimitExceededErrorNameEnum =
  (typeof GroupsPerUserLimitExceededErrorNameEnum)[keyof typeof GroupsPerUserLimitExceededErrorNameEnum]
export const GroupsPerUserLimitExceededErrorMessageEnum = {
  AmountOfGroupsPerUserIsLimited: 'Amount of groups per user is limited.',
} as const

export type GroupsPerUserLimitExceededErrorMessageEnum =
  (typeof GroupsPerUserLimitExceededErrorMessageEnum)[keyof typeof GroupsPerUserLimitExceededErrorMessageEnum]
export const GroupsPerUserLimitExceededErrorHttpStatusCodeEnum = {
  NUMBER_409: 409,
} as const

export type GroupsPerUserLimitExceededErrorHttpStatusCodeEnum =
  (typeof GroupsPerUserLimitExceededErrorHttpStatusCodeEnum)[keyof typeof GroupsPerUserLimitExceededErrorHttpStatusCodeEnum]

/**
 * Fields name/path mapping between the vp_token and the id_token
 * @export
 * @interface IdTokenMapping
 */
export interface IdTokenMapping extends Array<IdTokenMappingInner> {}
/**
 *
 * @export
 * @interface IdTokenMappingInner
 */
export interface IdTokenMappingInner {
  /**
   * Name(path) of the corresponding field in the vp_token
   * @type {string}
   * @memberof IdTokenMappingInner
   */
  sourceField: string
  /**
   * Name of the corresponding field in the id_token
   * @type {string}
   * @memberof IdTokenMappingInner
   */
  idTokenClaim: string
  /**
   * Id of related input descriptor from presentation definition
   * @type {string}
   * @memberof IdTokenMappingInner
   */
  inputDescriptorId?: string
}
/**
 *
 * @export
 * @interface InvalidClaimContextError
 */
export interface InvalidClaimContextError {
  /**
   *
   * @type {string}
   * @memberof InvalidClaimContextError
   */
  name: InvalidClaimContextErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof InvalidClaimContextError
   */
  message: InvalidClaimContextErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof InvalidClaimContextError
   */
  httpStatusCode: InvalidClaimContextErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof InvalidClaimContextError
   */
  traceId: string
  /**
   *
   * @type {Array<InvalidParameterErrorDetailsInner>}
   * @memberof InvalidClaimContextError
   */
  details?: Array<InvalidParameterErrorDetailsInner>
}

export const InvalidClaimContextErrorNameEnum = {
  InvalidClaimContextError: 'InvalidClaimContextError',
} as const

export type InvalidClaimContextErrorNameEnum =
  (typeof InvalidClaimContextErrorNameEnum)[keyof typeof InvalidClaimContextErrorNameEnum]
export const InvalidClaimContextErrorMessageEnum = {
  InvalidClaimContext: 'Invalid Claim Context',
} as const

export type InvalidClaimContextErrorMessageEnum =
  (typeof InvalidClaimContextErrorMessageEnum)[keyof typeof InvalidClaimContextErrorMessageEnum]
export const InvalidClaimContextErrorHttpStatusCodeEnum = {
  NUMBER_400: 400,
} as const

export type InvalidClaimContextErrorHttpStatusCodeEnum =
  (typeof InvalidClaimContextErrorHttpStatusCodeEnum)[keyof typeof InvalidClaimContextErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface InvalidGroupsError
 */
export interface InvalidGroupsError {
  /**
   *
   * @type {string}
   * @memberof InvalidGroupsError
   */
  name: InvalidGroupsErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof InvalidGroupsError
   */
  message: InvalidGroupsErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof InvalidGroupsError
   */
  httpStatusCode: InvalidGroupsErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof InvalidGroupsError
   */
  traceId: string
  /**
   *
   * @type {Array<InvalidParameterErrorDetailsInner>}
   * @memberof InvalidGroupsError
   */
  details?: Array<InvalidParameterErrorDetailsInner>
}

export const InvalidGroupsErrorNameEnum = {
  InvalidGroupsError: 'InvalidGroupsError',
} as const

export type InvalidGroupsErrorNameEnum =
  (typeof InvalidGroupsErrorNameEnum)[keyof typeof InvalidGroupsErrorNameEnum]
export const InvalidGroupsErrorMessageEnum = {
  InvalidGroupsNames: 'Invalid groups names',
} as const

export type InvalidGroupsErrorMessageEnum =
  (typeof InvalidGroupsErrorMessageEnum)[keyof typeof InvalidGroupsErrorMessageEnum]
export const InvalidGroupsErrorHttpStatusCodeEnum = {
  NUMBER_400: 400,
} as const

export type InvalidGroupsErrorHttpStatusCodeEnum =
  (typeof InvalidGroupsErrorHttpStatusCodeEnum)[keyof typeof InvalidGroupsErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface InvalidParameterError
 */
export interface InvalidParameterError {
  /**
   *
   * @type {string}
   * @memberof InvalidParameterError
   */
  name: InvalidParameterErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof InvalidParameterError
   */
  message: InvalidParameterErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof InvalidParameterError
   */
  httpStatusCode: InvalidParameterErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof InvalidParameterError
   */
  traceId: string
  /**
   *
   * @type {Array<InvalidParameterErrorDetailsInner>}
   * @memberof InvalidParameterError
   */
  details?: Array<InvalidParameterErrorDetailsInner>
}

export const InvalidParameterErrorNameEnum = {
  InvalidParameterError: 'InvalidParameterError',
} as const

export type InvalidParameterErrorNameEnum =
  (typeof InvalidParameterErrorNameEnum)[keyof typeof InvalidParameterErrorNameEnum]
export const InvalidParameterErrorMessageEnum = {
  InvalidParameterParam: 'Invalid parameter: ${param}.',
} as const

export type InvalidParameterErrorMessageEnum =
  (typeof InvalidParameterErrorMessageEnum)[keyof typeof InvalidParameterErrorMessageEnum]
export const InvalidParameterErrorHttpStatusCodeEnum = {
  NUMBER_400: 400,
} as const

export type InvalidParameterErrorHttpStatusCodeEnum =
  (typeof InvalidParameterErrorHttpStatusCodeEnum)[keyof typeof InvalidParameterErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface InvalidParameterErrorDetailsInner
 */
export interface InvalidParameterErrorDetailsInner {
  /**
   *
   * @type {string}
   * @memberof InvalidParameterErrorDetailsInner
   */
  issue: string
  /**
   *
   * @type {string}
   * @memberof InvalidParameterErrorDetailsInner
   */
  field?: string
  /**
   *
   * @type {string}
   * @memberof InvalidParameterErrorDetailsInner
   */
  value?: string
  /**
   *
   * @type {string}
   * @memberof InvalidParameterErrorDetailsInner
   */
  location?: string
}
/**
 *
 * @export
 * @interface JsonWebKey
 */
export interface JsonWebKey {
  /**
   * The value of the \"keys\" parameter is an array of JSON Web Key (JWK) values.  By default, the order of the JWK values within the array does not imply an  order of preference among them, although applications of JWK Sets can choose  to assign a meaning to the order for their purposes, if desired.
   * @type {Array<JsonWebKeyKeysInner>}
   * @memberof JsonWebKey
   */
  keys?: Array<JsonWebKeyKeysInner>
}
/**
 *
 * @export
 * @interface JsonWebKeyKeysInner
 */
export interface JsonWebKeyKeysInner {
  /**
   * The \"alg\" (algorithm) parameter identifies the algorithm intended for use  with the key. The values used should either be registered in the IANA  \"JSON Web Signature and Encryption Algorithms\" registry established  by [JWA] or be a value that contains a Collision- Resistant Name.
   * @type {string}
   * @memberof JsonWebKeyKeysInner
   */
  alg: string
  /**
   *
   * @type {string}
   * @memberof JsonWebKeyKeysInner
   */
  crv?: string
  /**
   *
   * @type {string}
   * @memberof JsonWebKeyKeysInner
   */
  d?: string
  /**
   *
   * @type {string}
   * @memberof JsonWebKeyKeysInner
   */
  dp?: string
  /**
   *
   * @type {string}
   * @memberof JsonWebKeyKeysInner
   */
  dq?: string
  /**
   *
   * @type {string}
   * @memberof JsonWebKeyKeysInner
   */
  e?: string
  /**
   *
   * @type {string}
   * @memberof JsonWebKeyKeysInner
   */
  k?: string
  /**
   * The \"kid\" (key ID) parameter is used to match a specific key. This is used,  for instance, to choose among a set of keys within a JWK Set during key  rollover. The structure of the \"kid\" value is unspecified. When \"kid\"  values are used within a JWK Set, different keys within the JWK Set SHOULD  use distinct \"kid\" values. (One example in which different keys might use  the same \"kid\" value is if they have different \"kty\" (key type) values but  are considered to be equivalent alternatives by the application using them.)  The \"kid\" value is a case-sensitive string.
   * @type {string}
   * @memberof JsonWebKeyKeysInner
   */
  kid: string
  /**
   * The \"kty\" (key type) parameter identifies the cryptographic algorithm family  used with the key, such as \"RSA\" or \"EC\". \"kty\" values should either be  registered in the IANA \"JSON Web Key Types\" registry established by [JWA]  or be a value that contains a Collision- Resistant Name. The \"kty\" value  is a case-sensitive string.
   * @type {string}
   * @memberof JsonWebKeyKeysInner
   */
  kty: string
  /**
   *
   * @type {string}
   * @memberof JsonWebKeyKeysInner
   */
  n?: string
  /**
   *
   * @type {string}
   * @memberof JsonWebKeyKeysInner
   */
  p?: string
  /**
   *
   * @type {string}
   * @memberof JsonWebKeyKeysInner
   */
  q?: string
  /**
   *
   * @type {string}
   * @memberof JsonWebKeyKeysInner
   */
  qi?: string
  /**
   * Use (\"public key use\") identifies the intended use of the public key. The  \"use\" parameter is employed to indicate whether a public key is used for  encrypting data or verifying the signature on data. Values are commonly  \"sig\" (signature) or \"enc\" (encryption).
   * @type {string}
   * @memberof JsonWebKeyKeysInner
   */
  use: string
  /**
   *
   * @type {string}
   * @memberof JsonWebKeyKeysInner
   */
  x?: string
  /**
   * The \"x5c\" (X.509 certificate chain) parameter contains a chain of one  or more PKIX certificates [RFC5280]. The certificate chain is represented  as a JSON array of certificate value strings. Each string in the array is  a base64-encoded (Section 4 of [RFC4648] -- not base64url-encoded) DER [ITU.X690.1994] PKIX certificate value. The PKIX certificate containing the  key value MUST be the first certificate.
   * @type {Array<string>}
   * @memberof JsonWebKeyKeysInner
   */
  x5c: Array<string>
  /**
   *
   * @type {string}
   * @memberof JsonWebKeyKeysInner
   */
  y?: string
}
/**
 *
 * @export
 * @interface ListLoginConfigurationOutput
 */
export interface ListLoginConfigurationOutput {
  /**
   *
   * @type {Array<LoginConfigurationObject>}
   * @memberof ListLoginConfigurationOutput
   */
  configurations: Array<LoginConfigurationObject>
  /**
   *
   * @type {string}
   * @memberof ListLoginConfigurationOutput
   */
  lastEvaluatedKey?: string
}
/**
 * login configuration client metadata
 * @export
 * @interface LoginConfigurationClientMetadataInput
 */
export interface LoginConfigurationClientMetadataInput {
  /**
   * application name that will be displayed in consent page
   * @type {string}
   * @memberof LoginConfigurationClientMetadataInput
   */
  name: string
  /**
   * origin url that will be displayed in consent page
   * @type {string}
   * @memberof LoginConfigurationClientMetadataInput
   */
  origin: string
  /**
   * logo url that will be displayed in consent page
   * @type {string}
   * @memberof LoginConfigurationClientMetadataInput
   */
  logo: string
}
/**
 * login configuration client metadata
 * @export
 * @interface LoginConfigurationClientMetadataOutput
 */
export interface LoginConfigurationClientMetadataOutput {
  [key: string]: any

  /**
   * application name that will be displayed in consent page
   * @type {string}
   * @memberof LoginConfigurationClientMetadataOutput
   */
  name: string
  /**
   * origin url that will be displayed in consent page
   * @type {string}
   * @memberof LoginConfigurationClientMetadataOutput
   */
  origin: string
  /**
   * logo url that will be displayed in consent page
   * @type {string}
   * @memberof LoginConfigurationClientMetadataOutput
   */
  logo: string
  /**
   * indicates if the developer\'s ownership of the domain has been verified
   * @type {boolean}
   * @memberof LoginConfigurationClientMetadataOutput
   */
  domainVerified?: boolean
}
/**
 *
 * @export
 * @interface LoginConfigurationObject
 */
export interface LoginConfigurationObject {
  [key: string]: any

  /**
   * Configuration ari
   * @type {string}
   * @memberof LoginConfigurationObject
   */
  ari: string
  /**
   * Configuration id
   * @type {string}
   * @memberof LoginConfigurationObject
   */
  configurationId?: string
  /**
   * Project id
   * @type {string}
   * @memberof LoginConfigurationObject
   */
  projectId: string
  /**
   * User defined login configuration name
   * @type {string}
   * @memberof LoginConfigurationObject
   */
  name: string
  /**
   * OAuth 2.0 Redirect URIs
   * @type {Array<string>}
   * @memberof LoginConfigurationObject
   */
  redirectUris?: Array<string>
  /**
   * Post Logout Redirect URIs, Used to redirect the user\'s browser to a specified URL after the logout process is complete. Must match the domain, port, scheme of at least one of the registered redirect URIs
   * @type {Array<string>}
   * @memberof LoginConfigurationObject
   */
  postLogoutRedirectUris?: Array<string>
  /**
   * OAuth 2.0 Client Scope
   * @type {string}
   * @memberof LoginConfigurationObject
   */
  scope?: string
  /**
   * OAuth 2.0 Client ID
   * @type {string}
   * @memberof LoginConfigurationObject
   */
  clientId: string
  /**
   * OAuth 2.0 Client Creation Date
   * @type {string}
   * @memberof LoginConfigurationObject
   */
  creationDate: string
  /**
   * VP definition in JSON stringify format
   * @type {string}
   * @memberof LoginConfigurationObject
   */
  vpDefinition: string
  /**
   * Presentation Definition
   * @type {object}
   * @memberof LoginConfigurationObject
   */
  presentationDefinition?: object
  /**
   *
   * @type {IdTokenMapping}
   * @memberof LoginConfigurationObject
   */
  idTokenMapping: IdTokenMapping
  /**
   *
   * @type {LoginConfigurationClientMetadataOutput}
   * @memberof LoginConfigurationObject
   */
  clientMetadata: LoginConfigurationClientMetadataOutput
  /**
   *
   * @type {TokenEndpointAuthMethod}
   * @memberof LoginConfigurationObject
   */
  tokenEndpointAuthMethod: TokenEndpointAuthMethod
}

/**
 *
 * @export
 * @interface LoginConfigurationReadInvalidClientIdError
 */
export interface LoginConfigurationReadInvalidClientIdError {
  /**
   *
   * @type {string}
   * @memberof LoginConfigurationReadInvalidClientIdError
   */
  name: LoginConfigurationReadInvalidClientIdErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof LoginConfigurationReadInvalidClientIdError
   */
  message: LoginConfigurationReadInvalidClientIdErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof LoginConfigurationReadInvalidClientIdError
   */
  httpStatusCode: LoginConfigurationReadInvalidClientIdErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof LoginConfigurationReadInvalidClientIdError
   */
  traceId: string
  /**
   *
   * @type {Array<InvalidParameterErrorDetailsInner>}
   * @memberof LoginConfigurationReadInvalidClientIdError
   */
  details?: Array<InvalidParameterErrorDetailsInner>
}

export const LoginConfigurationReadInvalidClientIdErrorNameEnum = {
  LoginConfigurationReadInvalidClientIdError:
    'LoginConfigurationReadInvalidClientIdError',
} as const

export type LoginConfigurationReadInvalidClientIdErrorNameEnum =
  (typeof LoginConfigurationReadInvalidClientIdErrorNameEnum)[keyof typeof LoginConfigurationReadInvalidClientIdErrorNameEnum]
export const LoginConfigurationReadInvalidClientIdErrorMessageEnum = {
  LoginConfigurationReadInvalidClientIdError:
    'LoginConfigurationReadInvalidClientIdError',
} as const

export type LoginConfigurationReadInvalidClientIdErrorMessageEnum =
  (typeof LoginConfigurationReadInvalidClientIdErrorMessageEnum)[keyof typeof LoginConfigurationReadInvalidClientIdErrorMessageEnum]
export const LoginConfigurationReadInvalidClientIdErrorHttpStatusCodeEnum = {
  NUMBER_400: 400,
} as const

export type LoginConfigurationReadInvalidClientIdErrorHttpStatusCodeEnum =
  (typeof LoginConfigurationReadInvalidClientIdErrorHttpStatusCodeEnum)[keyof typeof LoginConfigurationReadInvalidClientIdErrorHttpStatusCodeEnum]

/**
 * Authorization Response per OpenID for Verifiable Presentations Specification
 * @export
 * @interface LoginSessionAcceptResponseInput
 */
export interface LoginSessionAcceptResponseInput {
  [key: string]: any
}
/**
 * Direct Post Response URI endpoint result
 * @export
 * @interface LoginSessionAcceptResponseOutput
 */
export interface LoginSessionAcceptResponseOutput {
  [key: string]: any
}
/**
 *
 * @export
 * @interface LoginSessionDto
 */
export interface LoginSessionDto {
  /**
   * Session primary identifier
   * @type {string}
   * @memberof LoginSessionDto
   */
  id: string
  /**
   *
   * @type {LoginSessionDtoAuthorizationRequest}
   * @memberof LoginSessionDto
   */
  authorizationRequest: LoginSessionDtoAuthorizationRequest
}
/**
 *
 * @export
 * @interface LoginSessionDtoAuthorizationRequest
 */
export interface LoginSessionDtoAuthorizationRequest {
  /**
   * State parameter
   * @type {string}
   * @memberof LoginSessionDtoAuthorizationRequest
   */
  state: string
  /**
   * Presentation Definition to ask from the user. In JSON Stringify format.
   * @type {string}
   * @memberof LoginSessionDtoAuthorizationRequest
   */
  presentationDefinition: string
  /**
   * ARI is used for analytics proposals.
   * @type {string}
   * @memberof LoginSessionDtoAuthorizationRequest
   */
  ari?: string
  /**
   * clientId used for detect origin.
   * @type {string}
   * @memberof LoginSessionDtoAuthorizationRequest
   */
  clientId?: string
}
/**
 * Input for Creating a Login Session
 * @export
 * @interface LoginSessionForIDPInput
 */
export interface LoginSessionForIDPInput {
  /**
   * IDP Login Challenge to Associate the Session with
   * @type {string}
   * @memberof LoginSessionForIDPInput
   */
  loginChallenge: string
  /**
   * IDP client id to Associate the Session with
   * @type {string}
   * @memberof LoginSessionForIDPInput
   */
  clientId: string
}
/**
 * Authorization Response per OpenID for Verifiable Presentations Specification
 * @export
 * @interface LoginSessionRejectResponseInput
 */
export interface LoginSessionRejectResponseInput {
  [key: string]: any

  /**
   * The error should follow the OAuth2 error format (e.g. invalid_request, login_required). Defaults to request_denied
   * @type {string}
   * @memberof LoginSessionRejectResponseInput
   */
  error?: string
  /**
   * Description of the error in a human readable format
   * @type {string}
   * @memberof LoginSessionRejectResponseInput
   */
  errorDescription?: string
  /**
   * Random state associated to the Session
   * @type {string}
   * @memberof LoginSessionRejectResponseInput
   */
  state: string
}
/**
 * Direct Post Response URI endpoint result
 * @export
 * @interface LoginSessionRejectResponseOutput
 */
export interface LoginSessionRejectResponseOutput {
  [key: string]: any
}
/**
 *
 * @export
 * @interface NotFoundError
 */
export interface NotFoundError {
  /**
   *
   * @type {string}
   * @memberof NotFoundError
   */
  name: NotFoundErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof NotFoundError
   */
  message: NotFoundErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof NotFoundError
   */
  httpStatusCode: NotFoundErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof NotFoundError
   */
  traceId: string
  /**
   *
   * @type {Array<InvalidParameterErrorDetailsInner>}
   * @memberof NotFoundError
   */
  details?: Array<InvalidParameterErrorDetailsInner>
}

export const NotFoundErrorNameEnum = {
  NotFoundError: 'NotFoundError',
} as const

export type NotFoundErrorNameEnum =
  (typeof NotFoundErrorNameEnum)[keyof typeof NotFoundErrorNameEnum]
export const NotFoundErrorMessageEnum = {
  NotFoundParam: 'Not found: ${param}.',
} as const

export type NotFoundErrorMessageEnum =
  (typeof NotFoundErrorMessageEnum)[keyof typeof NotFoundErrorMessageEnum]
export const NotFoundErrorHttpStatusCodeEnum = {
  NUMBER_404: 404,
} as const

export type NotFoundErrorHttpStatusCodeEnum =
  (typeof NotFoundErrorHttpStatusCodeEnum)[keyof typeof NotFoundErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface OAuth2Token
 */
export interface OAuth2Token {
  /**
   * The access token issued by the authorization server.
   * @type {string}
   * @memberof OAuth2Token
   */
  access_token?: string
  /**
   * The lifetime in seconds of the access token.  For example, the value \"3600\" denotes that the access  token will expire in one hour from the time the response was generated.
   * @type {number}
   * @memberof OAuth2Token
   */
  expires_in?: number
  /**
   * To retrieve a refresh token request the id_token scope.
   * @type {number}
   * @memberof OAuth2Token
   */
  id_token?: number
  /**
   * The refresh token, which can be used to obtain new access tokens. To retrieve it add the scope \"offline\" to your access token request.
   * @type {string}
   * @memberof OAuth2Token
   */
  refresh_token?: string
  /**
   * The scope of the access token
   * @type {string}
   * @memberof OAuth2Token
   */
  scope?: string
  /**
   * The type of the token issued
   * @type {string}
   * @memberof OAuth2Token
   */
  token_type?: string
}
/**
 *
 * @export
 * @interface OIDCConfig
 */
export interface OIDCConfig {
  /**
   * OAuth 2.0 Authorization Endpoint URL
   * @type {string}
   * @memberof OIDCConfig
   */
  authorization_endpoint: string
  /**
   * OpenID Connect Back-Channel Logout Session Required. Boolean value specifying whether the OP can pass a sid (session ID)  Claim in the Logout Token to identify the RP session with the OP. If  supported, the sid Claim is also included in ID Tokens issued by the OP
   * @type {boolean}
   * @memberof OIDCConfig
   */
  backchannel_logout_session_supported?: boolean
  /**
   * OpenID Connect Back-Channel Logout Supported. Boolean value specifying whether the OP supports  back-channel logout, with true indicating support.
   * @type {boolean}
   * @memberof OIDCConfig
   */
  backchannel_logout_supported?: boolean
  /**
   * OpenID Connect Claims Parameter Parameter Supported Boolean value specifying whether the OP supports use  of the claims parameter, with true indicating support.
   * @type {boolean}
   * @memberof OIDCConfig
   */
  claims_parameter_supported?: boolean
  /**
   * OpenID Connect Supported Claims   JSON array containing a list of the Claim Names of the  Claims that the OpenID Provider MAY be able to supply  values for. Note that for privacy or other reasons,  this might not be an exhaustive list.
   * @type {Array<string>}
   * @memberof OIDCConfig
   */
  claims_supported?: Array<string>
  /**
   * OAuth 2.0 PKCE Supported Code Challenge Methods JSON array containing a list of Proof Key for Code  Exchange (PKCE) [RFC7636] code challenge methods  supported by this authorization server.
   * @type {Array<string>}
   * @memberof OIDCConfig
   */
  code_challenge_methods_supported?: Array<string>
  /**
   * OpenID Connect Verifiable Credentials Endpoint Contains the URL of the Verifiable Credentials Endpoint.
   * @type {string}
   * @memberof OIDCConfig
   */
  credentials_endpoint_draft_00?: string
  /**
   * OpenID Connect Verifiable Credentials Supported JSON array containing a list of the Verifiable  Credentials supported by this authorization server.
   * @type {Array<OIDCConfigCredentialsSupportedDraft00Inner>}
   * @memberof OIDCConfig
   */
  credentials_supported_draft_00?: Array<OIDCConfigCredentialsSupportedDraft00Inner>
  /**
   * OpenID Connect End-Session Endpoint URL at the OP to which an RP can perform  a redirect to request that the End-User be  logged out at the OP.
   * @type {string}
   * @memberof OIDCConfig
   */
  end_session_endpoint?: string
  /**
   * OpenID Connect Front-Channel Logout Session Required Boolean value specifying whether the OP can pass iss  (issuer) and sid (session ID) query parameters to identify  the RP session with the OP when the frontchannel_logout_uri  is used. If supported, the sid Claim is also included in ID  Tokens issued by the OP.
   * @type {boolean}
   * @memberof OIDCConfig
   */
  frontchannel_logout_session_supported?: boolean
  /**
   * OpenID Connect Front-Channel Logout Supported Boolean value specifying whether the OP supports HTTP-based logout, with true indicating support.
   * @type {boolean}
   * @memberof OIDCConfig
   */
  frontchannel_logout_supported?: boolean
  /**
   * OAuth 2.0 Supported Grant Types JSON array containing a list of the OAuth 2.0 Grant Type values that this OP supports.
   * @type {Array<string>}
   * @memberof OIDCConfig
   */
  grant_types_supported?: Array<string>
  /**
   * OpenID Connect Default ID Token Signing Algorithms Algorithm used to sign OpenID Connect ID Tokens.
   * @type {Array<string>}
   * @memberof OIDCConfig
   */
  id_token_signed_response_alg: Array<string>
  /**
   * OpenID Connect Supported ID Token Signing Algorithms JSON array containing a list of the JWS signing algorithms  (alg values) supported by the OP for the ID Token to encode the Claims in a JWT.
   * @type {Array<string>}
   * @memberof OIDCConfig
   */
  id_token_signing_alg_values_supported: Array<string>
  /**
   * OpenID Connect Issuer URL An URL using the https scheme with no query or fragment component that the OP asserts as its IssuerURL Identifier. If IssuerURL discovery  is supported , this value MUST be identical to the issuer value returned by WebFinger.  This also MUST be identical to the iss Claim value in ID Tokens issued from this IssuerURL.
   * @type {string}
   * @memberof OIDCConfig
   */
  issuer: string
  /**
   * OpenID Connect Well-Known JSON Web Keys URL URL of the OP\'s JSON Web Key Set [JWK] document. This contains the signing key(s) the RP  uses to validate signatures from the OP. The JWK Set MAY also contain the Server\'s  encryption key(s), which are used by RPs to encrypt requests to the Server. When both  signing and encryption keys are made available, a use (Key Use) parameter value is REQUIRED  for all keys in the referenced JWK Set to indicate each key\'s intended usage. Although some  algorithms allow the same key to be used for both signatures and encryption, doing so is  NOT RECOMMENDED, as it is less secure. The JWK x5c parameter MAY be used to provide X.509  representations of keys provided. When used, the bare key values MUST still be present and  MUST match those in the certificate.
   * @type {string}
   * @memberof OIDCConfig
   */
  jwks_uri: string
  /**
   * OpenID Connect Dynamic Client Registration Endpoint URL
   * @type {string}
   * @memberof OIDCConfig
   */
  registration_endpoint?: string
  /**
   * OpenID Connect Supported Request Object Signing Algorithms JSON array containing a list of the JWS signing algorithms (alg values) supported by  the OP for Request Objects, which are described in Section 6.1 of  OpenID Connect Core 1.0 [OpenID.Core]. These algorithms are used both when the  Request Object is passed by value (using the request parameter) and when it is  passed by reference (using the request_uri parameter).
   * @type {Array<string>}
   * @memberof OIDCConfig
   */
  request_object_signing_alg_values_supported?: Array<string>
  /**
   * OpenID Connect Request Parameter Supported Boolean value specifying whether the OP supports use of the request parameter, with true indicating support.
   * @type {boolean}
   * @memberof OIDCConfig
   */
  request_parameter_supported?: boolean
  /**
   * OpenID Connect Request URI Parameter Supported Boolean value specifying whether the OP supports use of the request_uri parameter, with true indicating support.
   * @type {boolean}
   * @memberof OIDCConfig
   */
  request_uri_parameter_supported?: boolean
  /**
   * OpenID Connect Requires Request URI Registration Boolean value specifying whether the OP requires any request_uri values used to be  pre-registered using the request_uris registration parameter.
   * @type {boolean}
   * @memberof OIDCConfig
   */
  require_request_uri_registration?: boolean
  /**
   * OAuth 2.0 Supported Response Modes JSON array containing a list of the OAuth 2.0 response_mode values that this OP supports.
   * @type {Array<string>}
   * @memberof OIDCConfig
   */
  response_modes_supported?: Array<string>
  /**
   * OAuth 2.0 Supported Response Types JSON array containing a list of the OAuth 2.0 response_type values that this OP supports.  Dynamic OpenID Providers MUST support the code, id_token, and the token id_token Response Type values.
   * @type {Array<string>}
   * @memberof OIDCConfig
   */
  response_types_supported: Array<string>
  /**
   * OAuth 2.0 Token Revocation URL URL of the authorization server\'s OAuth 2.0 revocation endpoint.
   * @type {string}
   * @memberof OIDCConfig
   */
  revocation_endpoint?: string
  /**
   * OAuth 2.0 Supported Scope Values JSON array containing a list of the OAuth 2.0 [RFC6749] scope values that this server supports.  The server MUST support the openid scope value. Servers MAY choose not to advertise  some supported scope values even when this parameter is used
   * @type {Array<string>}
   * @memberof OIDCConfig
   */
  scopes_supported?: Array<string>
  /**
   * OpenID Connect Supported Subject Types JSON array containing a list of the Subject Identifier types that this OP supports.  Valid types include pairwise and public.
   * @type {Array<string>}
   * @memberof OIDCConfig
   */
  subject_types_supported: Array<string>
  /**
   * OAuth 2.0 Token Endpoint URL
   * @type {string}
   * @memberof OIDCConfig
   */
  token_endpoint: string
  /**
   * OAuth 2.0 Supported Client Authentication Methods JSON array containing a list of Client Authentication methods supported by this Token Endpoint.  The options are client_secret_post, client_secret_basic, client_secret_jwt,  and private_key_jwt, as described in Section 9 of OpenID Connect Core 1.0
   * @type {Array<string>}
   * @memberof OIDCConfig
   */
  token_endpoint_auth_methods_supported?: Array<string>
  /**
   * OpenID Connect Userinfo URL URL of the OP\'s UserInfo Endpoint.
   * @type {string}
   * @memberof OIDCConfig
   */
  userinfo_endpoint?: string
  /**
   * OpenID Connect User Userinfo Signing Algorithm Algorithm used to sign OpenID Connect Userinfo Responses.
   * @type {Array<string>}
   * @memberof OIDCConfig
   */
  userinfo_signed_response_alg: Array<string>
  /**
   * OpenID Connect Supported Userinfo Signing Algorithm JSON array containing a list of the JWS [JWS] signing algorithms (alg values) [JWA]  supported by the UserInfo Endpoint to encode the Claims in a JWT [JWT].
   * @type {Array<string>}
   * @memberof OIDCConfig
   */
  userinfo_signing_alg_values_supported?: Array<string>
}
/**
 *
 * @export
 * @interface OIDCConfigCredentialsSupportedDraft00Inner
 */
export interface OIDCConfigCredentialsSupportedDraft00Inner {
  /**
   *
   * @type {Array<string>}
   * @memberof OIDCConfigCredentialsSupportedDraft00Inner
   */
  cryptographic_binding_methods_supported?: Array<string>
  /**
   *
   * @type {Array<string>}
   * @memberof OIDCConfigCredentialsSupportedDraft00Inner
   */
  cryptographic_suites_supported?: Array<string>
  /**
   *
   * @type {string}
   * @memberof OIDCConfigCredentialsSupportedDraft00Inner
   */
  format?: string
  /**
   *
   * @type {Array<string>}
   * @memberof OIDCConfigCredentialsSupportedDraft00Inner
   */
  types?: Array<string>
}
/**
 * Redirect Response
 * @export
 * @interface RedirectResponse
 */
export interface RedirectResponse {
  /**
   * type
   * @type {string}
   * @memberof RedirectResponse
   */
  type: RedirectResponseTypeEnum
  /**
   * URL to redirect to
   * @type {string}
   * @memberof RedirectResponse
   */
  to: string
}

export const RedirectResponseTypeEnum = {
  RedirectResponse: 'REDIRECT_RESPONSE',
} as const

export type RedirectResponseTypeEnum =
  (typeof RedirectResponseTypeEnum)[keyof typeof RedirectResponseTypeEnum]

/**
 * input used to remove a user from a group
 * @export
 * @interface RemoveUserFromGroupInput
 */
export interface RemoveUserFromGroupInput {
  /**
   * Unique identifier of the user
   * @type {string}
   * @memberof RemoveUserFromGroupInput
   */
  userId: string
}
/**
 *
 * @export
 * @interface ResourceCreationError
 */
export interface ResourceCreationError {
  /**
   *
   * @type {string}
   * @memberof ResourceCreationError
   */
  name: ResourceCreationErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof ResourceCreationError
   */
  message: ResourceCreationErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof ResourceCreationError
   */
  httpStatusCode: ResourceCreationErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof ResourceCreationError
   */
  traceId: string
  /**
   *
   * @type {Array<InvalidParameterErrorDetailsInner>}
   * @memberof ResourceCreationError
   */
  details?: Array<InvalidParameterErrorDetailsInner>
}

export const ResourceCreationErrorNameEnum = {
  ResourceCreationError: 'ResourceCreationError',
} as const

export type ResourceCreationErrorNameEnum =
  (typeof ResourceCreationErrorNameEnum)[keyof typeof ResourceCreationErrorNameEnum]
export const ResourceCreationErrorMessageEnum = {
  FailedToCreateResources: 'Failed to create resources.',
} as const

export type ResourceCreationErrorMessageEnum =
  (typeof ResourceCreationErrorMessageEnum)[keyof typeof ResourceCreationErrorMessageEnum]
export const ResourceCreationErrorHttpStatusCodeEnum = {
  NUMBER_424: 424,
} as const

export type ResourceCreationErrorHttpStatusCodeEnum =
  (typeof ResourceCreationErrorHttpStatusCodeEnum)[keyof typeof ResourceCreationErrorHttpStatusCodeEnum]

/**
 * Service Error Response
 * @export
 * @interface ServiceErrorResponse
 */
export interface ServiceErrorResponse {
  /**
   * unique id for correlating this specific error to logs
   * @type {string}
   * @memberof ServiceErrorResponse
   */
  debugId: string
  /**
   * name of the error
   * @type {string}
   * @memberof ServiceErrorResponse
   */
  name: string
  /**
   * backwards compatible Affinidi error code
   * @type {string}
   * @memberof ServiceErrorResponse
   */
  code: string
  /**
   * error details
   * @type {Array<ServiceErrorResponseDetailsInner>}
   * @memberof ServiceErrorResponse
   */
  details?: Array<ServiceErrorResponseDetailsInner>
}
/**
 *
 * @export
 * @interface ServiceErrorResponseDetailsInner
 */
export interface ServiceErrorResponseDetailsInner {
  /**
   * issue
   * @type {string}
   * @memberof ServiceErrorResponseDetailsInner
   */
  issue: string
  /**
   * fields
   * @type {string}
   * @memberof ServiceErrorResponseDetailsInner
   */
  field?: string
  /**
   * value
   * @type {string}
   * @memberof ServiceErrorResponseDetailsInner
   */
  value?: string
  /**
   * location
   * @type {string}
   * @memberof ServiceErrorResponseDetailsInner
   */
  location?: string
}
/**
 * Requested Client Authentication method for the Token Endpoint. The options are: `client_secret_post`: (default) Send client_id and client_secret as application/x-www-form-urlencoded in the HTTP body. `client_secret_basic`: Send client_id and client_secret as application/x-www-form-urlencoded encoded in the HTTP Authorization header. `none`: For public clients (native/mobile apps) which can not have secret.
 * @export
 * @enum {string}
 */

export const TokenEndpointAuthMethod = {
  ClientSecretBasic: 'client_secret_basic',
  ClientSecretPost: 'client_secret_post',
  None: 'none',
} as const

export type TokenEndpointAuthMethod =
  (typeof TokenEndpointAuthMethod)[keyof typeof TokenEndpointAuthMethod]

/**
 *
 * @export
 * @interface UnauthorizedError
 */
export interface UnauthorizedError {
  /**
   *
   * @type {string}
   * @memberof UnauthorizedError
   */
  name: UnauthorizedErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof UnauthorizedError
   */
  message: UnauthorizedErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof UnauthorizedError
   */
  httpStatusCode: UnauthorizedErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof UnauthorizedError
   */
  traceId: string
  /**
   *
   * @type {Array<InvalidParameterErrorDetailsInner>}
   * @memberof UnauthorizedError
   */
  details?: Array<InvalidParameterErrorDetailsInner>
}

export const UnauthorizedErrorNameEnum = {
  UnauthorizedError: 'UnauthorizedError',
} as const

export type UnauthorizedErrorNameEnum =
  (typeof UnauthorizedErrorNameEnum)[keyof typeof UnauthorizedErrorNameEnum]
export const UnauthorizedErrorMessageEnum = {
  Unauthorized: 'Unauthorized',
} as const

export type UnauthorizedErrorMessageEnum =
  (typeof UnauthorizedErrorMessageEnum)[keyof typeof UnauthorizedErrorMessageEnum]
export const UnauthorizedErrorHttpStatusCodeEnum = {
  NUMBER_401: 401,
} as const

export type UnauthorizedErrorHttpStatusCodeEnum =
  (typeof UnauthorizedErrorHttpStatusCodeEnum)[keyof typeof UnauthorizedErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface UpdateLoginConfigurationInput
 */
export interface UpdateLoginConfigurationInput {
  /**
   * User defined login configuration name
   * @type {string}
   * @memberof UpdateLoginConfigurationInput
   */
  name?: string
  /**
   * OAuth 2.0 Redirect URIs
   * @type {Array<string>}
   * @memberof UpdateLoginConfigurationInput
   */
  redirectUris?: Array<string>
  /**
   * Post Logout Redirect URIs, Used to redirect the user\'s browser to a specified URL after the logout process is complete. Must match the domain, port, scheme of at least one of the registered redirect URIs
   * @type {Array<string>}
   * @memberof UpdateLoginConfigurationInput
   */
  postLogoutRedirectUris?: Array<string>
  /**
   * OAuth2 client secret
   * @type {string}
   * @memberof UpdateLoginConfigurationInput
   */
  clientSecret?: string
  /**
   * VP definition in JSON stringify format
   * @type {string}
   * @memberof UpdateLoginConfigurationInput
   */
  vpDefinition?: string
  /**
   * Presentation Definition
   * @type {object}
   * @memberof UpdateLoginConfigurationInput
   */
  presentationDefinition?: object
  /**
   *
   * @type {IdTokenMapping}
   * @memberof UpdateLoginConfigurationInput
   */
  idTokenMapping?: IdTokenMapping
  /**
   *
   * @type {LoginConfigurationClientMetadataInput}
   * @memberof UpdateLoginConfigurationInput
   */
  clientMetadata?: LoginConfigurationClientMetadataInput
  /**
   *
   * @type {TokenEndpointAuthMethod}
   * @memberof UpdateLoginConfigurationInput
   */
  tokenEndpointAuthMethod?: TokenEndpointAuthMethod
  /**
   * Interrupts login process if duplications of data fields names will be found
   * @type {boolean}
   * @memberof UpdateLoginConfigurationInput
   */
  failOnMappingConflict?: boolean
}

/**
 *
 * @export
 * @interface VPTokenValidationError
 */
export interface VPTokenValidationError {
  /**
   *
   * @type {string}
   * @memberof VPTokenValidationError
   */
  name: VPTokenValidationErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof VPTokenValidationError
   */
  message: VPTokenValidationErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof VPTokenValidationError
   */
  httpStatusCode: VPTokenValidationErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof VPTokenValidationError
   */
  traceId: string
  /**
   *
   * @type {Array<InvalidParameterErrorDetailsInner>}
   * @memberof VPTokenValidationError
   */
  details?: Array<InvalidParameterErrorDetailsInner>
}

export const VPTokenValidationErrorNameEnum = {
  VpTokenValidationError: 'VPTokenValidationError',
} as const

export type VPTokenValidationErrorNameEnum =
  (typeof VPTokenValidationErrorNameEnum)[keyof typeof VPTokenValidationErrorNameEnum]
export const VPTokenValidationErrorMessageEnum = {
  VpTokenValidationEndedWithAnError: 'VP token validation ended with an error',
} as const

export type VPTokenValidationErrorMessageEnum =
  (typeof VPTokenValidationErrorMessageEnum)[keyof typeof VPTokenValidationErrorMessageEnum]
export const VPTokenValidationErrorHttpStatusCodeEnum = {
  NUMBER_400: 400,
} as const

export type VPTokenValidationErrorHttpStatusCodeEnum =
  (typeof VPTokenValidationErrorHttpStatusCodeEnum)[keyof typeof VPTokenValidationErrorHttpStatusCodeEnum]

/**
 * AllowListApi - axios parameter creator
 * @export
 */
export const AllowListApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Allow Single or Multiple Groups
     * @param {GroupNamesInput} [groupNamesInput] List of group names as input
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    allowGroups: async (
      groupNamesInput?: GroupNamesInput,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/allow-list/groups/add`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        groupNamesInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Disallow Single or Multiple Groups
     * @param {GroupNamesInput} [groupNamesInput] List of group names as input
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    disallowGroups: async (
      groupNamesInput?: GroupNamesInput,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/allow-list/groups/remove`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        groupNamesInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get Allowed Groups
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAllowedGroups: async (
      pageToken?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/allow-list/groups`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * AllowListApi - functional programming interface
 * @export
 */
export const AllowListApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AllowListApiAxiosParamCreator(configuration)
  return {
    /**
     * Allow Single or Multiple Groups
     * @param {GroupNamesInput} [groupNamesInput] List of group names as input
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async allowGroups(
      groupNamesInput?: GroupNamesInput,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.allowGroups(
        groupNamesInput,
        options,
      )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['AllowListApi.allowGroups']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
    /**
     * Disallow Single or Multiple Groups
     * @param {GroupNamesInput} [groupNamesInput] List of group names as input
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async disallowGroups(
      groupNamesInput?: GroupNamesInput,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.disallowGroups(
        groupNamesInput,
        options,
      )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['AllowListApi.disallowGroups']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
    /**
     * Get Allowed Groups
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listAllowedGroups(
      pageToken?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupNames>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listAllowedGroups(pageToken, options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['AllowListApi.listAllowedGroups']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
  }
}

/**
 * AllowListApi - factory interface
 * @export
 */
export const AllowListApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AllowListApiFp(configuration)
  return {
    /**
     * Allow Single or Multiple Groups
     * @param {GroupNamesInput} [groupNamesInput] List of group names as input
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    allowGroups(
      groupNamesInput?: GroupNamesInput,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .allowGroups(groupNamesInput, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Disallow Single or Multiple Groups
     * @param {GroupNamesInput} [groupNamesInput] List of group names as input
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    disallowGroups(
      groupNamesInput?: GroupNamesInput,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .disallowGroups(groupNamesInput, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get Allowed Groups
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAllowedGroups(
      pageToken?: string,
      options?: any,
    ): AxiosPromise<GroupNames> {
      return localVarFp
        .listAllowedGroups(pageToken, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * AllowListApi - object-oriented interface
 * @export
 * @class AllowListApi
 * @extends {BaseAPI}
 */
export class AllowListApi extends BaseAPI {
  /**
   * Allow Single or Multiple Groups
   * @param {GroupNamesInput} [groupNamesInput] List of group names as input
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AllowListApi
   */
  public allowGroups(
    groupNamesInput?: GroupNamesInput,
    options?: RawAxiosRequestConfig,
  ) {
    return AllowListApiFp(this.configuration)
      .allowGroups(groupNamesInput, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Disallow Single or Multiple Groups
   * @param {GroupNamesInput} [groupNamesInput] List of group names as input
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AllowListApi
   */
  public disallowGroups(
    groupNamesInput?: GroupNamesInput,
    options?: RawAxiosRequestConfig,
  ) {
    return AllowListApiFp(this.configuration)
      .disallowGroups(groupNamesInput, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get Allowed Groups
   * @param {string} [pageToken]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AllowListApi
   */
  public listAllowedGroups(
    pageToken?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return AllowListApiFp(this.configuration)
      .listAllowedGroups(pageToken, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ConfigurationApi - axios parameter creator
 * @export
 */
export const ConfigurationApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Create a new login configuration  `vpDefinition` and `idTokenMapping` have default settings that provide user email VP presentation definitions.  An essential default definition is in place when it comes to the login process for end users using the Chrome extension.  This definition requires users to input their email address as OIDCVP compliant, which is then verified by the Affinidi verification service.
     * @summary Create a new login configuration
     * @param {CreateLoginConfigurationInput} [createLoginConfigurationInput] CreateLoginConfigurations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLoginConfigurations: async (
      createLoginConfigurationInput?: CreateLoginConfigurationInput,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/login/configurations`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        createLoginConfigurationInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete login configurations by ID
     * @summary Delete login configurations by ID
     * @param {string} configurationId The id of the login configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLoginConfigurationsById: async (
      configurationId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'configurationId' is not null or undefined
      assertParamExists(
        'deleteLoginConfigurationsById',
        'configurationId',
        configurationId,
      )
      const localVarPath = `/v1/login/configurations/{configurationId}`.replace(
        `{${'configurationId'}}`,
        encodeURIComponent(String(configurationId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get Client Metadata By  OAuth 2.0 Client ID
     * @summary Get Client Metadata By  OAuth 2.0 Client ID
     * @param {string} clientId OAuth 2.0 Client ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getClientMetadataByClientId: async (
      clientId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'clientId' is not null or undefined
      assertParamExists('getClientMetadataByClientId', 'clientId', clientId)
      const localVarPath =
        `/v1/login/configurations/metadata/{clientId}`.replace(
          `{${'clientId'}}`,
          encodeURIComponent(String(clientId)),
        )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get login configuration by ID
     * @summary Get login configuration by ID
     * @param {string} configurationId The id of the login configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoginConfigurationsById: async (
      configurationId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'configurationId' is not null or undefined
      assertParamExists(
        'getLoginConfigurationsById',
        'configurationId',
        configurationId,
      )
      const localVarPath = `/v1/login/configurations/{configurationId}`.replace(
        `{${'configurationId'}}`,
        encodeURIComponent(String(configurationId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Endpoint to retrieve list of login configurations
     * @summary List login configurations
     * @param {number} [limit] Maximum number of records to fetch in a list
     * @param {string} [exclusiveStartKey] The base64url encoded key of the first item that this operation will evaluate (it is not returned). Use the value that was returned in the previous operation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listLoginConfigurations: async (
      limit?: number,
      exclusiveStartKey?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/login/configurations`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (exclusiveStartKey !== undefined) {
        localVarQueryParameter['exclusiveStartKey'] = exclusiveStartKey
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update login configurations by ID
     * @summary Update login configurations by ID
     * @param {string} configurationId The id of the login configuration
     * @param {UpdateLoginConfigurationInput} [updateLoginConfigurationInput] UpdateLoginConfigurationsById
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLoginConfigurationsById: async (
      configurationId: string,
      updateLoginConfigurationInput?: UpdateLoginConfigurationInput,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'configurationId' is not null or undefined
      assertParamExists(
        'updateLoginConfigurationsById',
        'configurationId',
        configurationId,
      )
      const localVarPath = `/v1/login/configurations/{configurationId}`.replace(
        `{${'configurationId'}}`,
        encodeURIComponent(String(configurationId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateLoginConfigurationInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ConfigurationApi - functional programming interface
 * @export
 */
export const ConfigurationApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ConfigurationApiAxiosParamCreator(configuration)
  return {
    /**
     * Create a new login configuration  `vpDefinition` and `idTokenMapping` have default settings that provide user email VP presentation definitions.  An essential default definition is in place when it comes to the login process for end users using the Chrome extension.  This definition requires users to input their email address as OIDCVP compliant, which is then verified by the Affinidi verification service.
     * @summary Create a new login configuration
     * @param {CreateLoginConfigurationInput} [createLoginConfigurationInput] CreateLoginConfigurations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createLoginConfigurations(
      createLoginConfigurationInput?: CreateLoginConfigurationInput,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<CreateLoginConfigurationOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createLoginConfigurations(
          createLoginConfigurationInput,
          options,
        )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['ConfigurationApi.createLoginConfigurations']?.[
          index
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
    /**
     * Delete login configurations by ID
     * @summary Delete login configurations by ID
     * @param {string} configurationId The id of the login configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteLoginConfigurationsById(
      configurationId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteLoginConfigurationsById(
          configurationId,
          options,
        )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['ConfigurationApi.deleteLoginConfigurationsById']?.[
          index
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
    /**
     * Get Client Metadata By  OAuth 2.0 Client ID
     * @summary Get Client Metadata By  OAuth 2.0 Client ID
     * @param {string} clientId OAuth 2.0 Client ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getClientMetadataByClientId(
      clientId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<LoginConfigurationClientMetadataOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getClientMetadataByClientId(
          clientId,
          options,
        )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['ConfigurationApi.getClientMetadataByClientId']?.[
          index
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
    /**
     * Get login configuration by ID
     * @summary Get login configuration by ID
     * @param {string} configurationId The id of the login configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLoginConfigurationsById(
      configurationId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<LoginConfigurationObject>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getLoginConfigurationsById(
          configurationId,
          options,
        )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['ConfigurationApi.getLoginConfigurationsById']?.[
          index
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
    /**
     * Endpoint to retrieve list of login configurations
     * @summary List login configurations
     * @param {number} [limit] Maximum number of records to fetch in a list
     * @param {string} [exclusiveStartKey] The base64url encoded key of the first item that this operation will evaluate (it is not returned). Use the value that was returned in the previous operation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listLoginConfigurations(
      limit?: number,
      exclusiveStartKey?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ListLoginConfigurationOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listLoginConfigurations(
          limit,
          exclusiveStartKey,
          options,
        )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['ConfigurationApi.listLoginConfigurations']?.[index]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
    /**
     * Update login configurations by ID
     * @summary Update login configurations by ID
     * @param {string} configurationId The id of the login configuration
     * @param {UpdateLoginConfigurationInput} [updateLoginConfigurationInput] UpdateLoginConfigurationsById
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateLoginConfigurationsById(
      configurationId: string,
      updateLoginConfigurationInput?: UpdateLoginConfigurationInput,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<LoginConfigurationObject>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateLoginConfigurationsById(
          configurationId,
          updateLoginConfigurationInput,
          options,
        )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['ConfigurationApi.updateLoginConfigurationsById']?.[
          index
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
  }
}

/**
 * ConfigurationApi - factory interface
 * @export
 */
export const ConfigurationApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ConfigurationApiFp(configuration)
  return {
    /**
     * Create a new login configuration  `vpDefinition` and `idTokenMapping` have default settings that provide user email VP presentation definitions.  An essential default definition is in place when it comes to the login process for end users using the Chrome extension.  This definition requires users to input their email address as OIDCVP compliant, which is then verified by the Affinidi verification service.
     * @summary Create a new login configuration
     * @param {CreateLoginConfigurationInput} [createLoginConfigurationInput] CreateLoginConfigurations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLoginConfigurations(
      createLoginConfigurationInput?: CreateLoginConfigurationInput,
      options?: any,
    ): AxiosPromise<CreateLoginConfigurationOutput> {
      return localVarFp
        .createLoginConfigurations(createLoginConfigurationInput, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete login configurations by ID
     * @summary Delete login configurations by ID
     * @param {string} configurationId The id of the login configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLoginConfigurationsById(
      configurationId: string,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .deleteLoginConfigurationsById(configurationId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get Client Metadata By  OAuth 2.0 Client ID
     * @summary Get Client Metadata By  OAuth 2.0 Client ID
     * @param {string} clientId OAuth 2.0 Client ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getClientMetadataByClientId(
      clientId: string,
      options?: any,
    ): AxiosPromise<LoginConfigurationClientMetadataOutput> {
      return localVarFp
        .getClientMetadataByClientId(clientId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get login configuration by ID
     * @summary Get login configuration by ID
     * @param {string} configurationId The id of the login configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLoginConfigurationsById(
      configurationId: string,
      options?: any,
    ): AxiosPromise<LoginConfigurationObject> {
      return localVarFp
        .getLoginConfigurationsById(configurationId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Endpoint to retrieve list of login configurations
     * @summary List login configurations
     * @param {number} [limit] Maximum number of records to fetch in a list
     * @param {string} [exclusiveStartKey] The base64url encoded key of the first item that this operation will evaluate (it is not returned). Use the value that was returned in the previous operation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listLoginConfigurations(
      limit?: number,
      exclusiveStartKey?: string,
      options?: any,
    ): AxiosPromise<ListLoginConfigurationOutput> {
      return localVarFp
        .listLoginConfigurations(limit, exclusiveStartKey, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update login configurations by ID
     * @summary Update login configurations by ID
     * @param {string} configurationId The id of the login configuration
     * @param {UpdateLoginConfigurationInput} [updateLoginConfigurationInput] UpdateLoginConfigurationsById
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLoginConfigurationsById(
      configurationId: string,
      updateLoginConfigurationInput?: UpdateLoginConfigurationInput,
      options?: any,
    ): AxiosPromise<LoginConfigurationObject> {
      return localVarFp
        .updateLoginConfigurationsById(
          configurationId,
          updateLoginConfigurationInput,
          options,
        )
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ConfigurationApi - object-oriented interface
 * @export
 * @class ConfigurationApi
 * @extends {BaseAPI}
 */
export class ConfigurationApi extends BaseAPI {
  /**
   * Create a new login configuration  `vpDefinition` and `idTokenMapping` have default settings that provide user email VP presentation definitions.  An essential default definition is in place when it comes to the login process for end users using the Chrome extension.  This definition requires users to input their email address as OIDCVP compliant, which is then verified by the Affinidi verification service.
   * @summary Create a new login configuration
   * @param {CreateLoginConfigurationInput} [createLoginConfigurationInput] CreateLoginConfigurations
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConfigurationApi
   */
  public createLoginConfigurations(
    createLoginConfigurationInput?: CreateLoginConfigurationInput,
    options?: RawAxiosRequestConfig,
  ) {
    return ConfigurationApiFp(this.configuration)
      .createLoginConfigurations(createLoginConfigurationInput, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete login configurations by ID
   * @summary Delete login configurations by ID
   * @param {string} configurationId The id of the login configuration
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConfigurationApi
   */
  public deleteLoginConfigurationsById(
    configurationId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ConfigurationApiFp(this.configuration)
      .deleteLoginConfigurationsById(configurationId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get Client Metadata By  OAuth 2.0 Client ID
   * @summary Get Client Metadata By  OAuth 2.0 Client ID
   * @param {string} clientId OAuth 2.0 Client ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConfigurationApi
   */
  public getClientMetadataByClientId(
    clientId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ConfigurationApiFp(this.configuration)
      .getClientMetadataByClientId(clientId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get login configuration by ID
   * @summary Get login configuration by ID
   * @param {string} configurationId The id of the login configuration
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConfigurationApi
   */
  public getLoginConfigurationsById(
    configurationId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ConfigurationApiFp(this.configuration)
      .getLoginConfigurationsById(configurationId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Endpoint to retrieve list of login configurations
   * @summary List login configurations
   * @param {number} [limit] Maximum number of records to fetch in a list
   * @param {string} [exclusiveStartKey] The base64url encoded key of the first item that this operation will evaluate (it is not returned). Use the value that was returned in the previous operation.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConfigurationApi
   */
  public listLoginConfigurations(
    limit?: number,
    exclusiveStartKey?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ConfigurationApiFp(this.configuration)
      .listLoginConfigurations(limit, exclusiveStartKey, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update login configurations by ID
   * @summary Update login configurations by ID
   * @param {string} configurationId The id of the login configuration
   * @param {UpdateLoginConfigurationInput} [updateLoginConfigurationInput] UpdateLoginConfigurationsById
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConfigurationApi
   */
  public updateLoginConfigurationsById(
    configurationId: string,
    updateLoginConfigurationInput?: UpdateLoginConfigurationInput,
    options?: RawAxiosRequestConfig,
  ) {
    return ConfigurationApiFp(this.configuration)
      .updateLoginConfigurationsById(
        configurationId,
        updateLoginConfigurationInput,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * DenyListApi - axios parameter creator
 * @export
 */
export const DenyListApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Block Single or Multiple Groups
     * @param {GroupNamesInput} [groupNamesInput] List of group names as input
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    blockGroups: async (
      groupNamesInput?: GroupNamesInput,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/deny-list/groups/add`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        groupNamesInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Block Single or Multiple user ids
     * @param {BlockedUsersInput} [blockedUsersInput] List of blocked users as input
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    blockUsers: async (
      blockedUsersInput?: BlockedUsersInput,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/deny-list/users/add`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        blockedUsersInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get Blocked Groups
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBlockedGroups: async (
      pageToken?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/deny-list/groups`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get List of Blocked Users
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBlockedUsers: async (
      pageToken?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/deny-list/users`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      if (pageToken !== undefined) {
        localVarQueryParameter['pageToken'] = pageToken
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Unblock Single or Multiple Groups
     * @param {GroupNamesInput} [groupNamesInput] List of group names as input
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unblockGroups: async (
      groupNamesInput?: GroupNamesInput,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/deny-list/groups/remove`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        groupNamesInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Unblock Single or Multiple user ids
     * @param {BlockedUsersInput} [blockedUsersInput] List of blocked users as input
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unblockUsers: async (
      blockedUsersInput?: BlockedUsersInput,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/deny-list/users/remove`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        blockedUsersInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * DenyListApi - functional programming interface
 * @export
 */
export const DenyListApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DenyListApiAxiosParamCreator(configuration)
  return {
    /**
     * Block Single or Multiple Groups
     * @param {GroupNamesInput} [groupNamesInput] List of group names as input
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async blockGroups(
      groupNamesInput?: GroupNamesInput,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.blockGroups(
        groupNamesInput,
        options,
      )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['DenyListApi.blockGroups']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
    /**
     * Block Single or Multiple user ids
     * @param {BlockedUsersInput} [blockedUsersInput] List of blocked users as input
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async blockUsers(
      blockedUsersInput?: BlockedUsersInput,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.blockUsers(
        blockedUsersInput,
        options,
      )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['DenyListApi.blockUsers']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
    /**
     * Get Blocked Groups
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listBlockedGroups(
      pageToken?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupNames>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listBlockedGroups(pageToken, options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['DenyListApi.listBlockedGroups']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
    /**
     * Get List of Blocked Users
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listBlockedUsers(
      pageToken?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlockedUsers>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listBlockedUsers(pageToken, options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['DenyListApi.listBlockedUsers']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
    /**
     * Unblock Single or Multiple Groups
     * @param {GroupNamesInput} [groupNamesInput] List of group names as input
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async unblockGroups(
      groupNamesInput?: GroupNamesInput,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.unblockGroups(
        groupNamesInput,
        options,
      )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['DenyListApi.unblockGroups']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
    /**
     * Unblock Single or Multiple user ids
     * @param {BlockedUsersInput} [blockedUsersInput] List of blocked users as input
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async unblockUsers(
      blockedUsersInput?: BlockedUsersInput,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.unblockUsers(
        blockedUsersInput,
        options,
      )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['DenyListApi.unblockUsers']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
  }
}

/**
 * DenyListApi - factory interface
 * @export
 */
export const DenyListApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DenyListApiFp(configuration)
  return {
    /**
     * Block Single or Multiple Groups
     * @param {GroupNamesInput} [groupNamesInput] List of group names as input
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    blockGroups(
      groupNamesInput?: GroupNamesInput,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .blockGroups(groupNamesInput, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Block Single or Multiple user ids
     * @param {BlockedUsersInput} [blockedUsersInput] List of blocked users as input
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    blockUsers(
      blockedUsersInput?: BlockedUsersInput,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .blockUsers(blockedUsersInput, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get Blocked Groups
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBlockedGroups(
      pageToken?: string,
      options?: any,
    ): AxiosPromise<GroupNames> {
      return localVarFp
        .listBlockedGroups(pageToken, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get List of Blocked Users
     * @param {string} [pageToken]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBlockedUsers(
      pageToken?: string,
      options?: any,
    ): AxiosPromise<BlockedUsers> {
      return localVarFp
        .listBlockedUsers(pageToken, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Unblock Single or Multiple Groups
     * @param {GroupNamesInput} [groupNamesInput] List of group names as input
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unblockGroups(
      groupNamesInput?: GroupNamesInput,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .unblockGroups(groupNamesInput, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Unblock Single or Multiple user ids
     * @param {BlockedUsersInput} [blockedUsersInput] List of blocked users as input
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unblockUsers(
      blockedUsersInput?: BlockedUsersInput,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .unblockUsers(blockedUsersInput, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * DenyListApi - object-oriented interface
 * @export
 * @class DenyListApi
 * @extends {BaseAPI}
 */
export class DenyListApi extends BaseAPI {
  /**
   * Block Single or Multiple Groups
   * @param {GroupNamesInput} [groupNamesInput] List of group names as input
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DenyListApi
   */
  public blockGroups(
    groupNamesInput?: GroupNamesInput,
    options?: RawAxiosRequestConfig,
  ) {
    return DenyListApiFp(this.configuration)
      .blockGroups(groupNamesInput, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Block Single or Multiple user ids
   * @param {BlockedUsersInput} [blockedUsersInput] List of blocked users as input
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DenyListApi
   */
  public blockUsers(
    blockedUsersInput?: BlockedUsersInput,
    options?: RawAxiosRequestConfig,
  ) {
    return DenyListApiFp(this.configuration)
      .blockUsers(blockedUsersInput, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get Blocked Groups
   * @param {string} [pageToken]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DenyListApi
   */
  public listBlockedGroups(
    pageToken?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return DenyListApiFp(this.configuration)
      .listBlockedGroups(pageToken, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get List of Blocked Users
   * @param {string} [pageToken]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DenyListApi
   */
  public listBlockedUsers(pageToken?: string, options?: RawAxiosRequestConfig) {
    return DenyListApiFp(this.configuration)
      .listBlockedUsers(pageToken, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Unblock Single or Multiple Groups
   * @param {GroupNamesInput} [groupNamesInput] List of group names as input
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DenyListApi
   */
  public unblockGroups(
    groupNamesInput?: GroupNamesInput,
    options?: RawAxiosRequestConfig,
  ) {
    return DenyListApiFp(this.configuration)
      .unblockGroups(groupNamesInput, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Unblock Single or Multiple user ids
   * @param {BlockedUsersInput} [blockedUsersInput] List of blocked users as input
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DenyListApi
   */
  public unblockUsers(
    blockedUsersInput?: BlockedUsersInput,
    options?: RawAxiosRequestConfig,
  ) {
    return DenyListApiFp(this.configuration)
      .unblockUsers(blockedUsersInput, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * GroupApi - axios parameter creator
 * @export
 */
export const GroupApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {string} groupName
     * @param {AddUserToGroupInput} addUserToGroupInput AddUserToGroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUserToGroup: async (
      groupName: string,
      addUserToGroupInput: AddUserToGroupInput,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'groupName' is not null or undefined
      assertParamExists('addUserToGroup', 'groupName', groupName)
      // verify required parameter 'addUserToGroupInput' is not null or undefined
      assertParamExists(
        'addUserToGroup',
        'addUserToGroupInput',
        addUserToGroupInput,
      )
      const localVarPath = `/v1/groups/{groupName}/users`.replace(
        `{${'groupName'}}`,
        encodeURIComponent(String(groupName)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        addUserToGroupInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {CreateGroupInput} createGroupInput CreateGroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGroup: async (
      createGroupInput: CreateGroupInput,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createGroupInput' is not null or undefined
      assertParamExists('createGroup', 'createGroupInput', createGroupInput)
      const localVarPath = `/v1/groups`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        createGroupInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} groupName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGroup: async (
      groupName: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'groupName' is not null or undefined
      assertParamExists('deleteGroup', 'groupName', groupName)
      const localVarPath = `/v1/groups/{groupName}`.replace(
        `{${'groupName'}}`,
        encodeURIComponent(String(groupName)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} groupName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupById: async (
      groupName: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'groupName' is not null or undefined
      assertParamExists('getGroupById', 'groupName', groupName)
      const localVarPath = `/v1/groups/{groupName}`.replace(
        `{${'groupName'}}`,
        encodeURIComponent(String(groupName)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} groupName
     * @param {number} [limit] Maximum number of records to fetch in a list
     * @param {string} [exclusiveStartKey] The base64url encoded key of the first item that this operation will evaluate (it is not returned). Use the value that was returned in the previous operation.
     * @param {ListGroupUserMappingsSortOrderEnum} [sortOrder] sort response in specific order. By default it is in desc order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGroupUserMappings: async (
      groupName: string,
      limit?: number,
      exclusiveStartKey?: string,
      sortOrder?: ListGroupUserMappingsSortOrderEnum,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'groupName' is not null or undefined
      assertParamExists('listGroupUserMappings', 'groupName', groupName)
      const localVarPath = `/v1/groups/{groupName}/users`.replace(
        `{${'groupName'}}`,
        encodeURIComponent(String(groupName)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (exclusiveStartKey !== undefined) {
        localVarQueryParameter['exclusiveStartKey'] = exclusiveStartKey
      }

      if (sortOrder !== undefined) {
        localVarQueryParameter['sortOrder'] = sortOrder
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGroups: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/groups`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} groupName
     * @param {RemoveUserFromGroupInput} removeUserFromGroupInput Remove user from group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeUserFromGroup: async (
      groupName: string,
      removeUserFromGroupInput: RemoveUserFromGroupInput,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'groupName' is not null or undefined
      assertParamExists('removeUserFromGroup', 'groupName', groupName)
      // verify required parameter 'removeUserFromGroupInput' is not null or undefined
      assertParamExists(
        'removeUserFromGroup',
        'removeUserFromGroupInput',
        removeUserFromGroupInput,
      )
      const localVarPath = `/v1/groups/{groupName}/users`.replace(
        `{${'groupName'}}`,
        encodeURIComponent(String(groupName)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        removeUserFromGroupInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * GroupApi - functional programming interface
 * @export
 */
export const GroupApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = GroupApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {string} groupName
     * @param {AddUserToGroupInput} addUserToGroupInput AddUserToGroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addUserToGroup(
      groupName: string,
      addUserToGroupInput: AddUserToGroupInput,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<GroupUserMappingDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addUserToGroup(
        groupName,
        addUserToGroupInput,
        options,
      )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['GroupApi.addUserToGroup']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
    /**
     *
     * @param {CreateGroupInput} createGroupInput CreateGroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createGroup(
      createGroupInput: CreateGroupInput,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createGroup(
        createGroupInput,
        options,
      )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['GroupApi.createGroup']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
    /**
     *
     * @param {string} groupName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteGroup(
      groupName: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroup(
        groupName,
        options,
      )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['GroupApi.deleteGroup']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
    /**
     *
     * @param {string} groupName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getGroupById(
      groupName: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupById(
        groupName,
        options,
      )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['GroupApi.getGroupById']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
    /**
     *
     * @param {string} groupName
     * @param {number} [limit] Maximum number of records to fetch in a list
     * @param {string} [exclusiveStartKey] The base64url encoded key of the first item that this operation will evaluate (it is not returned). Use the value that was returned in the previous operation.
     * @param {ListGroupUserMappingsSortOrderEnum} [sortOrder] sort response in specific order. By default it is in desc order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listGroupUserMappings(
      groupName: string,
      limit?: number,
      exclusiveStartKey?: string,
      sortOrder?: ListGroupUserMappingsSortOrderEnum,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<GroupUserMappingsList>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listGroupUserMappings(
          groupName,
          limit,
          exclusiveStartKey,
          sortOrder,
          options,
        )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['GroupApi.listGroupUserMappings']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listGroups(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupsList>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listGroups(options)
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['GroupApi.listGroups']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
    /**
     *
     * @param {string} groupName
     * @param {RemoveUserFromGroupInput} removeUserFromGroupInput Remove user from group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeUserFromGroup(
      groupName: string,
      removeUserFromGroupInput: RemoveUserFromGroupInput,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.removeUserFromGroup(
          groupName,
          removeUserFromGroupInput,
          options,
        )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['GroupApi.removeUserFromGroup']?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
  }
}

/**
 * GroupApi - factory interface
 * @export
 */
export const GroupApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = GroupApiFp(configuration)
  return {
    /**
     *
     * @param {string} groupName
     * @param {AddUserToGroupInput} addUserToGroupInput AddUserToGroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUserToGroup(
      groupName: string,
      addUserToGroupInput: AddUserToGroupInput,
      options?: any,
    ): AxiosPromise<GroupUserMappingDto> {
      return localVarFp
        .addUserToGroup(groupName, addUserToGroupInput, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {CreateGroupInput} createGroupInput CreateGroup
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createGroup(
      createGroupInput: CreateGroupInput,
      options?: any,
    ): AxiosPromise<GroupDto> {
      return localVarFp
        .createGroup(createGroupInput, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} groupName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGroup(groupName: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteGroup(groupName, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} groupName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupById(groupName: string, options?: any): AxiosPromise<GroupDto> {
      return localVarFp
        .getGroupById(groupName, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} groupName
     * @param {number} [limit] Maximum number of records to fetch in a list
     * @param {string} [exclusiveStartKey] The base64url encoded key of the first item that this operation will evaluate (it is not returned). Use the value that was returned in the previous operation.
     * @param {ListGroupUserMappingsSortOrderEnum} [sortOrder] sort response in specific order. By default it is in desc order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGroupUserMappings(
      groupName: string,
      limit?: number,
      exclusiveStartKey?: string,
      sortOrder?: ListGroupUserMappingsSortOrderEnum,
      options?: any,
    ): AxiosPromise<GroupUserMappingsList> {
      return localVarFp
        .listGroupUserMappings(
          groupName,
          limit,
          exclusiveStartKey,
          sortOrder,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listGroups(options?: any): AxiosPromise<GroupsList> {
      return localVarFp
        .listGroups(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} groupName
     * @param {RemoveUserFromGroupInput} removeUserFromGroupInput Remove user from group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeUserFromGroup(
      groupName: string,
      removeUserFromGroupInput: RemoveUserFromGroupInput,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .removeUserFromGroup(groupName, removeUserFromGroupInput, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * GroupApi - object-oriented interface
 * @export
 * @class GroupApi
 * @extends {BaseAPI}
 */
export class GroupApi extends BaseAPI {
  /**
   *
   * @param {string} groupName
   * @param {AddUserToGroupInput} addUserToGroupInput AddUserToGroup
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GroupApi
   */
  public addUserToGroup(
    groupName: string,
    addUserToGroupInput: AddUserToGroupInput,
    options?: RawAxiosRequestConfig,
  ) {
    return GroupApiFp(this.configuration)
      .addUserToGroup(groupName, addUserToGroupInput, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {CreateGroupInput} createGroupInput CreateGroup
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GroupApi
   */
  public createGroup(
    createGroupInput: CreateGroupInput,
    options?: RawAxiosRequestConfig,
  ) {
    return GroupApiFp(this.configuration)
      .createGroup(createGroupInput, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} groupName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GroupApi
   */
  public deleteGroup(groupName: string, options?: RawAxiosRequestConfig) {
    return GroupApiFp(this.configuration)
      .deleteGroup(groupName, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} groupName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GroupApi
   */
  public getGroupById(groupName: string, options?: RawAxiosRequestConfig) {
    return GroupApiFp(this.configuration)
      .getGroupById(groupName, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} groupName
   * @param {number} [limit] Maximum number of records to fetch in a list
   * @param {string} [exclusiveStartKey] The base64url encoded key of the first item that this operation will evaluate (it is not returned). Use the value that was returned in the previous operation.
   * @param {ListGroupUserMappingsSortOrderEnum} [sortOrder] sort response in specific order. By default it is in desc order
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GroupApi
   */
  public listGroupUserMappings(
    groupName: string,
    limit?: number,
    exclusiveStartKey?: string,
    sortOrder?: ListGroupUserMappingsSortOrderEnum,
    options?: RawAxiosRequestConfig,
  ) {
    return GroupApiFp(this.configuration)
      .listGroupUserMappings(
        groupName,
        limit,
        exclusiveStartKey,
        sortOrder,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GroupApi
   */
  public listGroups(options?: RawAxiosRequestConfig) {
    return GroupApiFp(this.configuration)
      .listGroups(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} groupName
   * @param {RemoveUserFromGroupInput} removeUserFromGroupInput Remove user from group
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GroupApi
   */
  public removeUserFromGroup(
    groupName: string,
    removeUserFromGroupInput: RemoveUserFromGroupInput,
    options?: RawAxiosRequestConfig,
  ) {
    return GroupApiFp(this.configuration)
      .removeUserFromGroup(groupName, removeUserFromGroupInput, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * @export
 */
export const ListGroupUserMappingsSortOrderEnum = {
  Asc: 'asc',
  Desc: 'desc',
} as const
export type ListGroupUserMappingsSortOrderEnum =
  (typeof ListGroupUserMappingsSortOrderEnum)[keyof typeof ListGroupUserMappingsSortOrderEnum]

/**
 * IdpApi - axios parameter creator
 * @export
 */
export const IdpApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * The authorization endpoint is one of the components in the OAuth 2.0 flow. It\'s the URL where a user is redirected to grant or deny access to their resources. When a user tries to access a service that requires OAuth 2.0 authorization, the application will redirect the user to this authorization endpoint. Here, the user can log in (if necessary) and then decide whether to grant the application access.
     * @summary OAuth 2.0 Authorize Endpoint
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1LoginProjectProjectIdOauth2AuthGet: async (
      projectId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists(
        'v1LoginProjectProjectIdOauth2AuthGet',
        'projectId',
        projectId,
      )
      const localVarPath = `/v1/login/project/{projectId}/oauth2/auth`.replace(
        `{${'projectId'}}`,
        encodeURIComponent(String(projectId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Revoking a token (both access and refresh) means that the tokens will be invalid.  A revoked access token can no longer be used to make access requests, and a revoked  refresh token can no longer be used to refresh an access token. Revoking a refresh  token also invalidates the access token that was created with it. A token may only  be revoked by the client the token was generated for.
     * @summary Revoke OAuth 2.0 Access or Refresh Token
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1LoginProjectProjectIdOauth2RevokePost: async (
      projectId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists(
        'v1LoginProjectProjectIdOauth2RevokePost',
        'projectId',
        projectId,
      )
      const localVarPath =
        `/v1/login/project/{projectId}/oauth2/revoke`.replace(
          `{${'projectId'}}`,
          encodeURIComponent(String(projectId)),
        )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * This endpoint initiates and completes user logout at the IdP OAuth2 & OpenID provider and initiates OpenID Connect Front- / Back-channel logout: https://openid.net/specs/openid-connect-frontchannel-1_0.html https://openid.net/specs/openid-connect-backchannel-1_0.html Back-channel logout is performed asynchronously and does not affect logout flow.
     * @summary OpenID Connect Front- and Back-channel Enabled Logout
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1LoginProjectProjectIdOauth2SessionsLogoutGet: async (
      projectId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists(
        'v1LoginProjectProjectIdOauth2SessionsLogoutGet',
        'projectId',
        projectId,
      )
      const localVarPath =
        `/v1/login/project/{projectId}/oauth2/sessions/logout`.replace(
          `{${'projectId'}}`,
          encodeURIComponent(String(projectId)),
        )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * The token endpoint is a critical component in the OAuth 2.0 protocol. It\'s the URL where a client application makes a request to exchange an authorization grant (such as an authorization code) for an access token. After a user grants authorization at the authorization endpoint, the client application receives an authorization grant, which is then exchanged for an access token at the token endpoint. This access token is then used to access the user\'s resources on the protected server.
     * @summary The OAuth 2.0 Token Endpoint
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1LoginProjectProjectIdOauth2TokenPost: async (
      projectId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists(
        'v1LoginProjectProjectIdOauth2TokenPost',
        'projectId',
        projectId,
      )
      const localVarPath = `/v1/login/project/{projectId}/oauth2/token`.replace(
        `{${'projectId'}}`,
        encodeURIComponent(String(projectId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * This endpoint returns the payload of the ID Token,  including session.id_token values, of the provided  OAuth 2.0 Access Token\'s consent request. In the case of authentication error, a WWW-Authenticate  header might be set in the response with more information  about the error. See the spec for more details about  header format.
     * @summary OpenID Connect Userinfo
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1LoginProjectProjectIdUserinfoGet: async (
      projectId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists(
        'v1LoginProjectProjectIdUserinfoGet',
        'projectId',
        projectId,
      )
      const localVarPath = `/v1/login/project/{projectId}/userinfo`.replace(
        `{${'projectId'}}`,
        encodeURIComponent(String(projectId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * This endpoint returns JSON Web Keys required to verifying OpenID Connect ID Tokens and, if enabled, OAuth 2.0 JWT Access Tokens. This endpoint can be used with client libraries like node-jwks-rsa among others.
     * @summary Discover Well-Known JSON Web Keys
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1LoginProjectProjectIdWellKnownJwksJsonGet: async (
      projectId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists(
        'v1LoginProjectProjectIdWellKnownJwksJsonGet',
        'projectId',
        projectId,
      )
      const localVarPath =
        `/v1/login/project/{projectId}/.well-known/jwks.json`.replace(
          `{${'projectId'}}`,
          encodeURIComponent(String(projectId)),
        )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * A mechanism for an OpenID Connect Relying Party to discover the End-User\'s  OpenID Provider and obtain information needed to interact with it, including  its OAuth 2.0 endpoint locations.
     * @summary OpenID Connect Discovery
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1LoginProjectProjectIdWellKnownOpenidConfigurationGet: async (
      projectId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists(
        'v1LoginProjectProjectIdWellKnownOpenidConfigurationGet',
        'projectId',
        projectId,
      )
      const localVarPath =
        `/v1/login/project/{projectId}/.well-known/openid-configuration`.replace(
          `{${'projectId'}}`,
          encodeURIComponent(String(projectId)),
        )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * IdpApi - functional programming interface
 * @export
 */
export const IdpApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = IdpApiAxiosParamCreator(configuration)
  return {
    /**
     * The authorization endpoint is one of the components in the OAuth 2.0 flow. It\'s the URL where a user is redirected to grant or deny access to their resources. When a user tries to access a service that requires OAuth 2.0 authorization, the application will redirect the user to this authorization endpoint. Here, the user can log in (if necessary) and then decide whether to grant the application access.
     * @summary OAuth 2.0 Authorize Endpoint
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1LoginProjectProjectIdOauth2AuthGet(
      projectId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.v1LoginProjectProjectIdOauth2AuthGet(
          projectId,
          options,
        )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['IdpApi.v1LoginProjectProjectIdOauth2AuthGet']?.[
          index
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
    /**
     * Revoking a token (both access and refresh) means that the tokens will be invalid.  A revoked access token can no longer be used to make access requests, and a revoked  refresh token can no longer be used to refresh an access token. Revoking a refresh  token also invalidates the access token that was created with it. A token may only  be revoked by the client the token was generated for.
     * @summary Revoke OAuth 2.0 Access or Refresh Token
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1LoginProjectProjectIdOauth2RevokePost(
      projectId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.v1LoginProjectProjectIdOauth2RevokePost(
          projectId,
          options,
        )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['IdpApi.v1LoginProjectProjectIdOauth2RevokePost']?.[
          index
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
    /**
     * This endpoint initiates and completes user logout at the IdP OAuth2 & OpenID provider and initiates OpenID Connect Front- / Back-channel logout: https://openid.net/specs/openid-connect-frontchannel-1_0.html https://openid.net/specs/openid-connect-backchannel-1_0.html Back-channel logout is performed asynchronously and does not affect logout flow.
     * @summary OpenID Connect Front- and Back-channel Enabled Logout
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1LoginProjectProjectIdOauth2SessionsLogoutGet(
      projectId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.v1LoginProjectProjectIdOauth2SessionsLogoutGet(
          projectId,
          options,
        )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap[
          'IdpApi.v1LoginProjectProjectIdOauth2SessionsLogoutGet'
        ]?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
    /**
     * The token endpoint is a critical component in the OAuth 2.0 protocol. It\'s the URL where a client application makes a request to exchange an authorization grant (such as an authorization code) for an access token. After a user grants authorization at the authorization endpoint, the client application receives an authorization grant, which is then exchanged for an access token at the token endpoint. This access token is then used to access the user\'s resources on the protected server.
     * @summary The OAuth 2.0 Token Endpoint
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1LoginProjectProjectIdOauth2TokenPost(
      projectId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OAuth2Token>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.v1LoginProjectProjectIdOauth2TokenPost(
          projectId,
          options,
        )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['IdpApi.v1LoginProjectProjectIdOauth2TokenPost']?.[
          index
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
    /**
     * This endpoint returns the payload of the ID Token,  including session.id_token values, of the provided  OAuth 2.0 Access Token\'s consent request. In the case of authentication error, a WWW-Authenticate  header might be set in the response with more information  about the error. See the spec for more details about  header format.
     * @summary OpenID Connect Userinfo
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1LoginProjectProjectIdUserinfoGet(
      projectId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserInfo>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.v1LoginProjectProjectIdUserinfoGet(
          projectId,
          options,
        )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap['IdpApi.v1LoginProjectProjectIdUserinfoGet']?.[index]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
    /**
     * This endpoint returns JSON Web Keys required to verifying OpenID Connect ID Tokens and, if enabled, OAuth 2.0 JWT Access Tokens. This endpoint can be used with client libraries like node-jwks-rsa among others.
     * @summary Discover Well-Known JSON Web Keys
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1LoginProjectProjectIdWellKnownJwksJsonGet(
      projectId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonWebKey>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.v1LoginProjectProjectIdWellKnownJwksJsonGet(
          projectId,
          options,
        )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap[
          'IdpApi.v1LoginProjectProjectIdWellKnownJwksJsonGet'
        ]?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
    /**
     * A mechanism for an OpenID Connect Relying Party to discover the End-User\'s  OpenID Provider and obtain information needed to interact with it, including  its OAuth 2.0 endpoint locations.
     * @summary OpenID Connect Discovery
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1LoginProjectProjectIdWellKnownOpenidConfigurationGet(
      projectId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OIDCConfig>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.v1LoginProjectProjectIdWellKnownOpenidConfigurationGet(
          projectId,
          options,
        )
      const index = configuration?.serverIndex ?? 0
      const operationBasePath =
        operationServerMap[
          'IdpApi.v1LoginProjectProjectIdWellKnownOpenidConfigurationGet'
        ]?.[index]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, operationBasePath || basePath)
    },
  }
}

/**
 * IdpApi - factory interface
 * @export
 */
export const IdpApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = IdpApiFp(configuration)
  return {
    /**
     * The authorization endpoint is one of the components in the OAuth 2.0 flow. It\'s the URL where a user is redirected to grant or deny access to their resources. When a user tries to access a service that requires OAuth 2.0 authorization, the application will redirect the user to this authorization endpoint. Here, the user can log in (if necessary) and then decide whether to grant the application access.
     * @summary OAuth 2.0 Authorize Endpoint
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1LoginProjectProjectIdOauth2AuthGet(
      projectId: string,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .v1LoginProjectProjectIdOauth2AuthGet(projectId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Revoking a token (both access and refresh) means that the tokens will be invalid.  A revoked access token can no longer be used to make access requests, and a revoked  refresh token can no longer be used to refresh an access token. Revoking a refresh  token also invalidates the access token that was created with it. A token may only  be revoked by the client the token was generated for.
     * @summary Revoke OAuth 2.0 Access or Refresh Token
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1LoginProjectProjectIdOauth2RevokePost(
      projectId: string,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .v1LoginProjectProjectIdOauth2RevokePost(projectId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * This endpoint initiates and completes user logout at the IdP OAuth2 & OpenID provider and initiates OpenID Connect Front- / Back-channel logout: https://openid.net/specs/openid-connect-frontchannel-1_0.html https://openid.net/specs/openid-connect-backchannel-1_0.html Back-channel logout is performed asynchronously and does not affect logout flow.
     * @summary OpenID Connect Front- and Back-channel Enabled Logout
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1LoginProjectProjectIdOauth2SessionsLogoutGet(
      projectId: string,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .v1LoginProjectProjectIdOauth2SessionsLogoutGet(projectId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * The token endpoint is a critical component in the OAuth 2.0 protocol. It\'s the URL where a client application makes a request to exchange an authorization grant (such as an authorization code) for an access token. After a user grants authorization at the authorization endpoint, the client application receives an authorization grant, which is then exchanged for an access token at the token endpoint. This access token is then used to access the user\'s resources on the protected server.
     * @summary The OAuth 2.0 Token Endpoint
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1LoginProjectProjectIdOauth2TokenPost(
      projectId: string,
      options?: any,
    ): AxiosPromise<OAuth2Token> {
      return localVarFp
        .v1LoginProjectProjectIdOauth2TokenPost(projectId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * This endpoint returns the payload of the ID Token,  including session.id_token values, of the provided  OAuth 2.0 Access Token\'s consent request. In the case of authentication error, a WWW-Authenticate  header might be set in the response with more information  about the error. See the spec for more details about  header format.
     * @summary OpenID Connect Userinfo
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1LoginProjectProjectIdUserinfoGet(
      projectId: string,
      options?: any,
    ): AxiosPromise<GetUserInfo> {
      return localVarFp
        .v1LoginProjectProjectIdUserinfoGet(projectId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * This endpoint returns JSON Web Keys required to verifying OpenID Connect ID Tokens and, if enabled, OAuth 2.0 JWT Access Tokens. This endpoint can be used with client libraries like node-jwks-rsa among others.
     * @summary Discover Well-Known JSON Web Keys
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1LoginProjectProjectIdWellKnownJwksJsonGet(
      projectId: string,
      options?: any,
    ): AxiosPromise<JsonWebKey> {
      return localVarFp
        .v1LoginProjectProjectIdWellKnownJwksJsonGet(projectId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * A mechanism for an OpenID Connect Relying Party to discover the End-User\'s  OpenID Provider and obtain information needed to interact with it, including  its OAuth 2.0 endpoint locations.
     * @summary OpenID Connect Discovery
     * @param {string} projectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1LoginProjectProjectIdWellKnownOpenidConfigurationGet(
      projectId: string,
      options?: any,
    ): AxiosPromise<OIDCConfig> {
      return localVarFp
        .v1LoginProjectProjectIdWellKnownOpenidConfigurationGet(
          projectId,
          options,
        )
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * IdpApi - object-oriented interface
 * @export
 * @class IdpApi
 * @extends {BaseAPI}
 */
export class IdpApi extends BaseAPI {
  /**
   * The authorization endpoint is one of the components in the OAuth 2.0 flow. It\'s the URL where a user is redirected to grant or deny access to their resources. When a user tries to access a service that requires OAuth 2.0 authorization, the application will redirect the user to this authorization endpoint. Here, the user can log in (if necessary) and then decide whether to grant the application access.
   * @summary OAuth 2.0 Authorize Endpoint
   * @param {string} projectId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IdpApi
   */
  public v1LoginProjectProjectIdOauth2AuthGet(
    projectId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return IdpApiFp(this.configuration)
      .v1LoginProjectProjectIdOauth2AuthGet(projectId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Revoking a token (both access and refresh) means that the tokens will be invalid.  A revoked access token can no longer be used to make access requests, and a revoked  refresh token can no longer be used to refresh an access token. Revoking a refresh  token also invalidates the access token that was created with it. A token may only  be revoked by the client the token was generated for.
   * @summary Revoke OAuth 2.0 Access or Refresh Token
   * @param {string} projectId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IdpApi
   */
  public v1LoginProjectProjectIdOauth2RevokePost(
    projectId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return IdpApiFp(this.configuration)
      .v1LoginProjectProjectIdOauth2RevokePost(projectId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * This endpoint initiates and completes user logout at the IdP OAuth2 & OpenID provider and initiates OpenID Connect Front- / Back-channel logout: https://openid.net/specs/openid-connect-frontchannel-1_0.html https://openid.net/specs/openid-connect-backchannel-1_0.html Back-channel logout is performed asynchronously and does not affect logout flow.
   * @summary OpenID Connect Front- and Back-channel Enabled Logout
   * @param {string} projectId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IdpApi
   */
  public v1LoginProjectProjectIdOauth2SessionsLogoutGet(
    projectId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return IdpApiFp(this.configuration)
      .v1LoginProjectProjectIdOauth2SessionsLogoutGet(projectId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * The token endpoint is a critical component in the OAuth 2.0 protocol. It\'s the URL where a client application makes a request to exchange an authorization grant (such as an authorization code) for an access token. After a user grants authorization at the authorization endpoint, the client application receives an authorization grant, which is then exchanged for an access token at the token endpoint. This access token is then used to access the user\'s resources on the protected server.
   * @summary The OAuth 2.0 Token Endpoint
   * @param {string} projectId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IdpApi
   */
  public v1LoginProjectProjectIdOauth2TokenPost(
    projectId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return IdpApiFp(this.configuration)
      .v1LoginProjectProjectIdOauth2TokenPost(projectId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * This endpoint returns the payload of the ID Token,  including session.id_token values, of the provided  OAuth 2.0 Access Token\'s consent request. In the case of authentication error, a WWW-Authenticate  header might be set in the response with more information  about the error. See the spec for more details about  header format.
   * @summary OpenID Connect Userinfo
   * @param {string} projectId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IdpApi
   */
  public v1LoginProjectProjectIdUserinfoGet(
    projectId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return IdpApiFp(this.configuration)
      .v1LoginProjectProjectIdUserinfoGet(projectId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * This endpoint returns JSON Web Keys required to verifying OpenID Connect ID Tokens and, if enabled, OAuth 2.0 JWT Access Tokens. This endpoint can be used with client libraries like node-jwks-rsa among others.
   * @summary Discover Well-Known JSON Web Keys
   * @param {string} projectId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IdpApi
   */
  public v1LoginProjectProjectIdWellKnownJwksJsonGet(
    projectId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return IdpApiFp(this.configuration)
      .v1LoginProjectProjectIdWellKnownJwksJsonGet(projectId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * A mechanism for an OpenID Connect Relying Party to discover the End-User\'s  OpenID Provider and obtain information needed to interact with it, including  its OAuth 2.0 endpoint locations.
   * @summary OpenID Connect Discovery
   * @param {string} projectId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IdpApi
   */
  public v1LoginProjectProjectIdWellKnownOpenidConfigurationGet(
    projectId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return IdpApiFp(this.configuration)
      .v1LoginProjectProjectIdWellKnownOpenidConfigurationGet(
        projectId,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }
}
