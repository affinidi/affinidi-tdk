/* tslint:disable */
/* eslint-disable */
/**
 * KeyManagementService
 * Affinidi Key Management Service
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: nucleus.team@affinidi.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  BaseAPI,
  RequiredError,
  operationServerMap,
} from './base';

/**
 * DTO contains configuration to create a key from the seed
 * @export
 * @interface CreateKeysConfigInputDto
 */
export interface CreateKeysConfigInputDto {
  /**
   *
   * @type {string}
   * @memberof CreateKeysConfigInputDto
   */
  derivationPath: string;
  /**
   * method of the DID, default is key
   * @type {string}
   * @memberof CreateKeysConfigInputDto
   */
  didMethod?: CreateKeysConfigInputDtoDidMethodEnum;
  /**
   *
   * @type {string}
   * @memberof CreateKeysConfigInputDto
   */
  didWebUrl?: string;
}

export const CreateKeysConfigInputDtoDidMethodEnum = {
  Key: 'key',
  Web: 'web',
} as const;

export type CreateKeysConfigInputDtoDidMethodEnum =
  (typeof CreateKeysConfigInputDtoDidMethodEnum)[keyof typeof CreateKeysConfigInputDtoDidMethodEnum];

/**
 * DTO contains result of key config creation
 * @export
 * @interface CreateKeysConfigResultDto
 */
export interface CreateKeysConfigResultDto {
  /**
   * id of the key record
   * @type {string}
   * @memberof CreateKeysConfigResultDto
   */
  id?: string;
  /**
   * ARI of the key record
   * @type {string}
   * @memberof CreateKeysConfigResultDto
   */
  ari?: string;
  /**
   * id of the parent seed record
   * @type {string}
   * @memberof CreateKeysConfigResultDto
   */
  seedId?: string;
  /**
   * ARI of the parent seed record
   * @type {string}
   * @memberof CreateKeysConfigResultDto
   */
  seedAri?: string;
  /**
   * public key of the key config in HEX format
   * @type {string}
   * @memberof CreateKeysConfigResultDto
   */
  publicKeyHex?: string;
  /**
   * did method of the key record
   * @type {string}
   * @memberof CreateKeysConfigResultDto
   */
  didMethod?: CreateKeysConfigResultDtoDidMethodEnum;
}

export const CreateKeysConfigResultDtoDidMethodEnum = {
  Key: 'key',
  Web: 'web',
} as const;

export type CreateKeysConfigResultDtoDidMethodEnum =
  (typeof CreateKeysConfigResultDtoDidMethodEnum)[keyof typeof CreateKeysConfigResultDtoDidMethodEnum];

/**
 * DTO contains a result of the seed record creation
 * @export
 * @interface CreateSeedResultDto
 */
export interface CreateSeedResultDto {
  /**
   * id of the seed record
   * @type {string}
   * @memberof CreateSeedResultDto
   */
  id?: string;
  /**
   * ARI of the seed record
   * @type {string}
   * @memberof CreateSeedResultDto
   */
  ari?: string;
}
/**
 * DTO contains data to be decrypted
 * @export
 * @interface DecryptByPrivateKeyInputDto
 */
export interface DecryptByPrivateKeyInputDto {
  /**
   *
   * @type {string}
   * @memberof DecryptByPrivateKeyInputDto
   */
  encryptedData: string;
}
/**
 * DTO contains decrypted data
 * @export
 * @interface DecryptByPrivateKeyResultDto
 */
export interface DecryptByPrivateKeyResultDto {
  /**
   *
   * @type {string}
   * @memberof DecryptByPrivateKeyResultDto
   */
  decryptedData: string;
}
/**
 *
 * @export
 * @interface EmptyInput
 */
export interface EmptyInput {
  /**
   *
   * @type {string}
   * @memberof EmptyInput
   */
  emptyInput?: string;
}
/**
 * Detail of an error
 * @export
 * @interface ErrorDetail
 */
export interface ErrorDetail {
  /**
   *
   * @type {string}
   * @memberof ErrorDetail
   */
  message?: string;
}
/**
 * DTO contains a result of the seed exporting
 * @export
 * @interface ExportSeedResultDto
 */
export interface ExportSeedResultDto {
  /**
   * mnemonic of the seed
   * @type {string}
   * @memberof ExportSeedResultDto
   */
  mnemonic?: string;
}
/**
 * DTO contains key record
 * @export
 * @interface GetKeyResultDto
 */
export interface GetKeyResultDto {
  /**
   * id of the key record
   * @type {string}
   * @memberof GetKeyResultDto
   */
  id?: string;
  /**
   * id of the project
   * @type {string}
   * @memberof GetKeyResultDto
   */
  projectId?: string;
  /**
   * ARI of the key record
   * @type {string}
   * @memberof GetKeyResultDto
   */
  ari?: string;
  /**
   * algorithm of the key record
   * @type {string}
   * @memberof GetKeyResultDto
   */
  algorithm?: string;
  /**
   * did method of the key record
   * @type {string}
   * @memberof GetKeyResultDto
   */
  didMethod?: string;
  /**
   * derivation path of the key record
   * @type {string}
   * @memberof GetKeyResultDto
   */
  derivationPath?: string;
  /**
   * id of the parent seed record
   * @type {string}
   * @memberof GetKeyResultDto
   */
  seedId?: string;
  /**
   * ARI of the parent seed record
   * @type {string}
   * @memberof GetKeyResultDto
   */
  seedAri?: string;
  /**
   * public key of the key config in HEX format
   * @type {string}
   * @memberof GetKeyResultDto
   */
  publicKeyHex?: string;
}
/**
 * DTO contains seed record
 * @export
 * @interface GetSeedResultDto
 */
export interface GetSeedResultDto {
  /**
   *
   * @type {string}
   * @memberof GetSeedResultDto
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof GetSeedResultDto
   */
  projectId?: string;
  /**
   * ARI of the seed record
   * @type {string}
   * @memberof GetSeedResultDto
   */
  ari?: string;
}
/**
 * DTO contains the seed entropy as mnemonic that is imported into the system
 * @export
 * @interface ImportSeedMnemonicInputDto
 */
export interface ImportSeedMnemonicInputDto {
  /**
   *
   * @type {string}
   * @memberof ImportSeedMnemonicInputDto
   */
  mnemonic?: string;
}
/**
 * DTO contains the seed entropy as hex string that is imported into the system
 * @export
 * @interface ImportSeedRawInputDto
 */
export interface ImportSeedRawInputDto {
  /**
   *
   * @type {string}
   * @memberof ImportSeedRawInputDto
   */
  seedHex?: string;
}
/**
 * @type ImportSeedRequest
 * @export
 */
export type ImportSeedRequest =
  | ImportSeedMnemonicInputDto
  | ImportSeedRawInputDto;

/**
 * DTO contains list of seed records
 * @export
 * @interface ListSeedResultDto
 */
export interface ListSeedResultDto {
  /**
   *
   * @type {Array<ListSeedResultDtoRecordsInner>}
   * @memberof ListSeedResultDto
   */
  records?: Array<ListSeedResultDtoRecordsInner>;
}
/**
 *
 * @export
 * @interface ListSeedResultDtoRecordsInner
 */
export interface ListSeedResultDtoRecordsInner {
  /**
   *
   * @type {string}
   * @memberof ListSeedResultDtoRecordsInner
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof ListSeedResultDtoRecordsInner
   */
  projectId?: string;
  /**
   * ARI of the seed record
   * @type {string}
   * @memberof ListSeedResultDtoRecordsInner
   */
  ari?: string;
}
/**
 * Error object
 * @export
 * @interface ModelError
 */
export interface ModelError {
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  errorCode?: string;
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  errorMessage?: string;
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  message?: string;
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  traceId?: string;
  /**
   *
   * @type {Array<ErrorDetail>}
   * @memberof ModelError
   */
  details?: Array<ErrorDetail>;
}
/**
 * DTO contains params to sign credential
 * @export
 * @interface SignCredentialInputDto
 */
export interface SignCredentialInputDto {
  /**
   *
   * @type {object}
   * @memberof SignCredentialInputDto
   */
  unsignedCredential: object;
}
/**
 * DTO contains signed credential
 * @export
 * @interface SignCredentialResultDto
 */
export interface SignCredentialResultDto {
  /**
   *
   * @type {object}
   * @memberof SignCredentialResultDto
   */
  signedCredential: object;
}
/**
 * DTO contains buffer in hex format to be signed
 * @export
 * @interface SignInputDto
 */
export interface SignInputDto {
  /**
   * data in hex format to be signed
   * @type {string}
   * @memberof SignInputDto
   */
  buffer: string;
  /**
   * type of returned signature, default is hex
   * @type {string}
   * @memberof SignInputDto
   */
  signatureType?: SignInputDtoSignatureTypeEnum;
}

export const SignInputDtoSignatureTypeEnum = {
  Hex: 'HEX',
  Rsv: 'RSV',
} as const;

export type SignInputDtoSignatureTypeEnum =
  (typeof SignInputDtoSignatureTypeEnum)[keyof typeof SignInputDtoSignatureTypeEnum];

/**
 * DTO contains parts of JWT to be signed
 * @export
 * @interface SignJwtInputDto
 */
export interface SignJwtInputDto {
  /**
   *
   * @type {object}
   * @memberof SignJwtInputDto
   */
  header: object;
  /**
   *
   * @type {object}
   * @memberof SignJwtInputDto
   */
  payload: object;
}
/**
 * DTO contains signed jwt
 * @export
 * @interface SignJwtResultDto
 */
export interface SignJwtResultDto {
  /**
   *
   * @type {string}
   * @memberof SignJwtResultDto
   */
  jwt: string;
}
/**
 * DTO contains signed buffer
 * @export
 * @interface SignResultDto
 */
export interface SignResultDto {
  /**
   * signature in hex format or RSV jsoned format
   * @type {string}
   * @memberof SignResultDto
   */
  signature: string;
}

/**
 * KeyApi - axios parameter creator
 * @export
 */
export const KeyApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {string} id id of seed record
     * @param {CreateKeysConfigInputDto} createKeysConfigInputDto CreateKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createKey: async (
      id: string,
      createKeysConfigInputDto: CreateKeysConfigInputDto,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('createKey', 'id', id);
      // verify required parameter 'createKeysConfigInputDto' is not null or undefined
      assertParamExists(
        'createKey',
        'createKeysConfigInputDto',
        createKeysConfigInputDto
      );
      const localVarPath = `/v1/seeds/{id}/keys`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createKeysConfigInputDto,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id id of seed
     * @param {DecryptByPrivateKeyInputDto} decryptByPrivateKeyInputDto DecryptByPrivateKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    decryptByPrivateKey: async (
      id: string,
      decryptByPrivateKeyInputDto: DecryptByPrivateKeyInputDto,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('decryptByPrivateKey', 'id', id);
      // verify required parameter 'decryptByPrivateKeyInputDto' is not null or undefined
      assertParamExists(
        'decryptByPrivateKey',
        'decryptByPrivateKeyInputDto',
        decryptByPrivateKeyInputDto
      );
      const localVarPath = `/v1/keys/{id}/decrypt-by-private-key`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        decryptByPrivateKeyInputDto,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id id of key
     * @param {SignCredentialInputDto} signCredentialInputDto SignCredential
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    kmssignCredential: async (
      id: string,
      signCredentialInputDto: SignCredentialInputDto,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('kmssignCredential', 'id', id);
      // verify required parameter 'signCredentialInputDto' is not null or undefined
      assertParamExists(
        'kmssignCredential',
        'signCredentialInputDto',
        signCredentialInputDto
      );
      const localVarPath = `/v1/keys/{id}/sign-credential`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        signCredentialInputDto,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id id of signing key configuration
     * @param {SignInputDto} signInputDto Sign
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sign: async (
      id: string,
      signInputDto: SignInputDto,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('sign', 'id', id);
      // verify required parameter 'signInputDto' is not null or undefined
      assertParamExists('sign', 'signInputDto', signInputDto);
      const localVarPath = `/v1/keys/{id}/sign`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        signInputDto,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id id of seed
     * @param {SignJwtInputDto} signJwtInputDto SignJwt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signJwt: async (
      id: string,
      signJwtInputDto: SignJwtInputDto,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('signJwt', 'id', id);
      // verify required parameter 'signJwtInputDto' is not null or undefined
      assertParamExists('signJwt', 'signJwtInputDto', signJwtInputDto);
      const localVarPath = `/v1/keys/{id}/sign-jwt`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        signJwtInputDto,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * KeyApi - functional programming interface
 * @export
 */
export const KeyApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = KeyApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {string} id id of seed record
     * @param {CreateKeysConfigInputDto} createKeysConfigInputDto CreateKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createKey(
      id: string,
      createKeysConfigInputDto: CreateKeysConfigInputDto,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CreateKeysConfigResultDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createKey(
        id,
        createKeysConfigInputDto,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['KeyApi.createKey']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {string} id id of seed
     * @param {DecryptByPrivateKeyInputDto} decryptByPrivateKeyInputDto DecryptByPrivateKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async decryptByPrivateKey(
      id: string,
      decryptByPrivateKeyInputDto: DecryptByPrivateKeyInputDto,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<DecryptByPrivateKeyResultDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.decryptByPrivateKey(
          id,
          decryptByPrivateKeyInputDto,
          options
        );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['KeyApi.decryptByPrivateKey']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {string} id id of key
     * @param {SignCredentialInputDto} signCredentialInputDto SignCredential
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async kmssignCredential(
      id: string,
      signCredentialInputDto: SignCredentialInputDto,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SignCredentialResultDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.kmssignCredential(
          id,
          signCredentialInputDto,
          options
        );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['KeyApi.kmssignCredential']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {string} id id of signing key configuration
     * @param {SignInputDto} signInputDto Sign
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sign(
      id: string,
      signInputDto: SignInputDto,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignResultDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.sign(
        id,
        signInputDto,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['KeyApi.sign']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {string} id id of seed
     * @param {SignJwtInputDto} signJwtInputDto SignJwt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signJwt(
      id: string,
      signJwtInputDto: SignJwtInputDto,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SignJwtResultDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.signJwt(
        id,
        signJwtInputDto,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['KeyApi.signJwt']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
  };
};

/**
 * KeyApi - factory interface
 * @export
 */
export const KeyApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = KeyApiFp(configuration);
  return {
    /**
     *
     * @param {string} id id of seed record
     * @param {CreateKeysConfigInputDto} createKeysConfigInputDto CreateKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createKey(
      id: string,
      createKeysConfigInputDto: CreateKeysConfigInputDto,
      options?: any
    ): AxiosPromise<CreateKeysConfigResultDto> {
      return localVarFp
        .createKey(id, createKeysConfigInputDto, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} id id of seed
     * @param {DecryptByPrivateKeyInputDto} decryptByPrivateKeyInputDto DecryptByPrivateKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    decryptByPrivateKey(
      id: string,
      decryptByPrivateKeyInputDto: DecryptByPrivateKeyInputDto,
      options?: any
    ): AxiosPromise<DecryptByPrivateKeyResultDto> {
      return localVarFp
        .decryptByPrivateKey(id, decryptByPrivateKeyInputDto, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} id id of key
     * @param {SignCredentialInputDto} signCredentialInputDto SignCredential
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    kmssignCredential(
      id: string,
      signCredentialInputDto: SignCredentialInputDto,
      options?: any
    ): AxiosPromise<SignCredentialResultDto> {
      return localVarFp
        .kmssignCredential(id, signCredentialInputDto, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} id id of signing key configuration
     * @param {SignInputDto} signInputDto Sign
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sign(
      id: string,
      signInputDto: SignInputDto,
      options?: any
    ): AxiosPromise<SignResultDto> {
      return localVarFp
        .sign(id, signInputDto, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} id id of seed
     * @param {SignJwtInputDto} signJwtInputDto SignJwt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signJwt(
      id: string,
      signJwtInputDto: SignJwtInputDto,
      options?: any
    ): AxiosPromise<SignJwtResultDto> {
      return localVarFp
        .signJwt(id, signJwtInputDto, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * KeyApi - object-oriented interface
 * @export
 * @class KeyApi
 * @extends {BaseAPI}
 */
export class KeyApi extends BaseAPI {
  /**
   *
   * @param {string} id id of seed record
   * @param {CreateKeysConfigInputDto} createKeysConfigInputDto CreateKey
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof KeyApi
   */
  public createKey(
    id: string,
    createKeysConfigInputDto: CreateKeysConfigInputDto,
    options?: RawAxiosRequestConfig
  ) {
    return KeyApiFp(this.configuration)
      .createKey(id, createKeysConfigInputDto, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id id of seed
   * @param {DecryptByPrivateKeyInputDto} decryptByPrivateKeyInputDto DecryptByPrivateKey
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof KeyApi
   */
  public decryptByPrivateKey(
    id: string,
    decryptByPrivateKeyInputDto: DecryptByPrivateKeyInputDto,
    options?: RawAxiosRequestConfig
  ) {
    return KeyApiFp(this.configuration)
      .decryptByPrivateKey(id, decryptByPrivateKeyInputDto, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id id of key
   * @param {SignCredentialInputDto} signCredentialInputDto SignCredential
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof KeyApi
   */
  public kmssignCredential(
    id: string,
    signCredentialInputDto: SignCredentialInputDto,
    options?: RawAxiosRequestConfig
  ) {
    return KeyApiFp(this.configuration)
      .kmssignCredential(id, signCredentialInputDto, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id id of signing key configuration
   * @param {SignInputDto} signInputDto Sign
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof KeyApi
   */
  public sign(
    id: string,
    signInputDto: SignInputDto,
    options?: RawAxiosRequestConfig
  ) {
    return KeyApiFp(this.configuration)
      .sign(id, signInputDto, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id id of seed
   * @param {SignJwtInputDto} signJwtInputDto SignJwt
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof KeyApi
   */
  public signJwt(
    id: string,
    signJwtInputDto: SignJwtInputDto,
    options?: RawAxiosRequestConfig
  ) {
    return KeyApiFp(this.configuration)
      .signJwt(id, signJwtInputDto, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SeedApi - axios parameter creator
 * @export
 */
export const SeedApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {EmptyInput} [emptyInput] CreateSeed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSeed: async (
      emptyInput?: EmptyInput,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/seeds`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        emptyInput,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Export seed as a mnemonic phrase (for seed 128bit / 256bit (default)). Returns the exported seed from the service
     * @param {string} id id of seed to be exported
     * @param {EmptyInput} [emptyInput] ExportSeedAsMnemonic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exportSeedAsMnemonic: async (
      id: string,
      emptyInput?: EmptyInput,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('exportSeedAsMnemonic', 'id', id);
      const localVarPath = `/v1/seeds/{id}/export-mnemonic`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        emptyInput,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id id of key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getKey: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getKey', 'id', id);
      const localVarPath = `/v1/keys/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} id id of seed record
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSeed: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getSeed', 'id', id);
      const localVarPath = `/v1/seeds/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {ImportSeedRequest} importSeedRequest ImportSeed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    importSeed: async (
      importSeedRequest: ImportSeedRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'importSeedRequest' is not null or undefined
      assertParamExists('importSeed', 'importSeedRequest', importSeedRequest);
      const localVarPath = `/v1/seeds/import`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        importSeedRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {ListSeedStatusEnum} [status]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSeed: async (
      status?: ListSeedStatusEnum,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/seeds`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration
      );

      if (status !== undefined) {
        localVarQueryParameter['status'] = status;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * revokes the seed, after that the keys derived from this seed cannot be used anymore. Revoked seed id will be listed in seed list with isRevoked=true flag
     * @param {string} id id of seed record
     * @param {EmptyInput} [emptyInput] RevokeSeed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    revokeSeed: async (
      id: string,
      emptyInput?: EmptyInput,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('revokeSeed', 'id', id);
      const localVarPath = `/v1/seeds/{id}/revoke`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        emptyInput,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SeedApi - functional programming interface
 * @export
 */
export const SeedApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SeedApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {EmptyInput} [emptyInput] CreateSeed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createSeed(
      emptyInput?: EmptyInput,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CreateSeedResultDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createSeed(
        emptyInput,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['SeedApi.createSeed']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Export seed as a mnemonic phrase (for seed 128bit / 256bit (default)). Returns the exported seed from the service
     * @param {string} id id of seed to be exported
     * @param {EmptyInput} [emptyInput] ExportSeedAsMnemonic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async exportSeedAsMnemonic(
      id: string,
      emptyInput?: EmptyInput,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ExportSeedResultDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.exportSeedAsMnemonic(
          id,
          emptyInput,
          options
        );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['SeedApi.exportSeedAsMnemonic']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {string} id id of key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getKey(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetKeyResultDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getKey(
        id,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['SeedApi.getKey']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {string} id id of seed record
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSeed(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetSeedResultDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSeed(
        id,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['SeedApi.getSeed']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {ImportSeedRequest} importSeedRequest ImportSeed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async importSeed(
      importSeedRequest: ImportSeedRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CreateSeedResultDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.importSeed(
        importSeedRequest,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['SeedApi.importSeed']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {ListSeedStatusEnum} [status]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listSeed(
      status?: ListSeedStatusEnum,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ListSeedResultDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listSeed(
        status,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['SeedApi.listSeed']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * revokes the seed, after that the keys derived from this seed cannot be used anymore. Revoked seed id will be listed in seed list with isRevoked=true flag
     * @param {string} id id of seed record
     * @param {EmptyInput} [emptyInput] RevokeSeed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async revokeSeed(
      id: string,
      emptyInput?: EmptyInput,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.revokeSeed(
        id,
        emptyInput,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['SeedApi.revokeSeed']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
  };
};

/**
 * SeedApi - factory interface
 * @export
 */
export const SeedApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = SeedApiFp(configuration);
  return {
    /**
     *
     * @param {EmptyInput} [emptyInput] CreateSeed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSeed(
      emptyInput?: EmptyInput,
      options?: any
    ): AxiosPromise<CreateSeedResultDto> {
      return localVarFp
        .createSeed(emptyInput, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Export seed as a mnemonic phrase (for seed 128bit / 256bit (default)). Returns the exported seed from the service
     * @param {string} id id of seed to be exported
     * @param {EmptyInput} [emptyInput] ExportSeedAsMnemonic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    exportSeedAsMnemonic(
      id: string,
      emptyInput?: EmptyInput,
      options?: any
    ): AxiosPromise<ExportSeedResultDto> {
      return localVarFp
        .exportSeedAsMnemonic(id, emptyInput, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} id id of key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getKey(id: string, options?: any): AxiosPromise<GetKeyResultDto> {
      return localVarFp
        .getKey(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} id id of seed record
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSeed(id: string, options?: any): AxiosPromise<GetSeedResultDto> {
      return localVarFp
        .getSeed(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {ImportSeedRequest} importSeedRequest ImportSeed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    importSeed(
      importSeedRequest: ImportSeedRequest,
      options?: any
    ): AxiosPromise<CreateSeedResultDto> {
      return localVarFp
        .importSeed(importSeedRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {ListSeedStatusEnum} [status]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listSeed(
      status?: ListSeedStatusEnum,
      options?: any
    ): AxiosPromise<ListSeedResultDto> {
      return localVarFp
        .listSeed(status, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * revokes the seed, after that the keys derived from this seed cannot be used anymore. Revoked seed id will be listed in seed list with isRevoked=true flag
     * @param {string} id id of seed record
     * @param {EmptyInput} [emptyInput] RevokeSeed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    revokeSeed(
      id: string,
      emptyInput?: EmptyInput,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .revokeSeed(id, emptyInput, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * SeedApi - object-oriented interface
 * @export
 * @class SeedApi
 * @extends {BaseAPI}
 */
export class SeedApi extends BaseAPI {
  /**
   *
   * @param {EmptyInput} [emptyInput] CreateSeed
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SeedApi
   */
  public createSeed(emptyInput?: EmptyInput, options?: RawAxiosRequestConfig) {
    return SeedApiFp(this.configuration)
      .createSeed(emptyInput, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Export seed as a mnemonic phrase (for seed 128bit / 256bit (default)). Returns the exported seed from the service
   * @param {string} id id of seed to be exported
   * @param {EmptyInput} [emptyInput] ExportSeedAsMnemonic
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SeedApi
   */
  public exportSeedAsMnemonic(
    id: string,
    emptyInput?: EmptyInput,
    options?: RawAxiosRequestConfig
  ) {
    return SeedApiFp(this.configuration)
      .exportSeedAsMnemonic(id, emptyInput, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id id of key
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SeedApi
   */
  public getKey(id: string, options?: RawAxiosRequestConfig) {
    return SeedApiFp(this.configuration)
      .getKey(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} id id of seed record
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SeedApi
   */
  public getSeed(id: string, options?: RawAxiosRequestConfig) {
    return SeedApiFp(this.configuration)
      .getSeed(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {ImportSeedRequest} importSeedRequest ImportSeed
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SeedApi
   */
  public importSeed(
    importSeedRequest: ImportSeedRequest,
    options?: RawAxiosRequestConfig
  ) {
    return SeedApiFp(this.configuration)
      .importSeed(importSeedRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {ListSeedStatusEnum} [status]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SeedApi
   */
  public listSeed(
    status?: ListSeedStatusEnum,
    options?: RawAxiosRequestConfig
  ) {
    return SeedApiFp(this.configuration)
      .listSeed(status, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * revokes the seed, after that the keys derived from this seed cannot be used anymore. Revoked seed id will be listed in seed list with isRevoked=true flag
   * @param {string} id id of seed record
   * @param {EmptyInput} [emptyInput] RevokeSeed
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SeedApi
   */
  public revokeSeed(
    id: string,
    emptyInput?: EmptyInput,
    options?: RawAxiosRequestConfig
  ) {
    return SeedApiFp(this.configuration)
      .revokeSeed(id, emptyInput, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const ListSeedStatusEnum = {
  Revoked: 'REVOKED',
  Active: 'ACTIVE',
} as const;
export type ListSeedStatusEnum =
  (typeof ListSeedStatusEnum)[keyof typeof ListSeedStatusEnum];
