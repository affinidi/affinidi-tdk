/* tslint:disable */
/* eslint-disable */
/**
 * KnowYourCustomer
 * Affinidi KnowYourCustomer Structure
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: consumer-eng@affinidi.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  BaseAPI,
  RequiredError,
  operationServerMap,
} from './base';

/**
 *
 * @export
 * @interface CodeMismatchExceptionError
 */
export interface CodeMismatchExceptionError {
  /**
   *
   * @type {string}
   * @memberof CodeMismatchExceptionError
   */
  name: CodeMismatchExceptionErrorNameEnum;
  /**
   *
   * @type {string}
   * @memberof CodeMismatchExceptionError
   */
  message: CodeMismatchExceptionErrorMessageEnum;
  /**
   *
   * @type {number}
   * @memberof CodeMismatchExceptionError
   */
  httpStatusCode: CodeMismatchExceptionErrorHttpStatusCodeEnum;
  /**
   *
   * @type {string}
   * @memberof CodeMismatchExceptionError
   */
  traceId: string;
  /**
   *
   * @type {Array<RateLimitExceededErrorDetailsInner>}
   * @memberof CodeMismatchExceptionError
   */
  details?: Array<RateLimitExceededErrorDetailsInner>;
}

export const CodeMismatchExceptionErrorNameEnum = {
  CodeMismatchExceptionError: 'CodeMismatchExceptionError',
} as const;

export type CodeMismatchExceptionErrorNameEnum =
  (typeof CodeMismatchExceptionErrorNameEnum)[keyof typeof CodeMismatchExceptionErrorNameEnum];
export const CodeMismatchExceptionErrorMessageEnum = {
  InvalidCode: 'Invalid code',
} as const;

export type CodeMismatchExceptionErrorMessageEnum =
  (typeof CodeMismatchExceptionErrorMessageEnum)[keyof typeof CodeMismatchExceptionErrorMessageEnum];
export const CodeMismatchExceptionErrorHttpStatusCodeEnum = {
  NUMBER_400: 400,
} as const;

export type CodeMismatchExceptionErrorHttpStatusCodeEnum =
  (typeof CodeMismatchExceptionErrorHttpStatusCodeEnum)[keyof typeof CodeMismatchExceptionErrorHttpStatusCodeEnum];

/**
 * @type CompleteOtpOperation400Response
 * @export
 */
export type CompleteOtpOperation400Response =
  | CodeMismatchExceptionError
  | ExpiredCodeExceptionError;

/**
 * completeOtp operation request
 * @export
 * @interface CompleteRequest
 */
export interface CompleteRequest {
  /**
   *
   * @type {string}
   * @memberof CompleteRequest
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof CompleteRequest
   */
  did: string;
  /**
   *
   * @type {string}
   * @memberof CompleteRequest
   */
  confirmationCode: string;
}
/**
 *
 * @export
 * @interface CompleteResponse
 */
export interface CompleteResponse {
  /**
   *
   * @type {object}
   * @memberof CompleteResponse
   */
  emailVc?: object;
}
/**
 *
 * @export
 * @interface CorsCompleteOtpOperationOK
 */
export interface CorsCompleteOtpOperationOK {
  /**
   *
   * @type {string}
   * @memberof CorsCompleteOtpOperationOK
   */
  corsCompleteOtpOperationOk?: string;
}
/**
 *
 * @export
 * @interface CorsInitiateOtpOperationOK
 */
export interface CorsInitiateOtpOperationOK {
  /**
   *
   * @type {string}
   * @memberof CorsInitiateOtpOperationOK
   */
  corsInitiateOtpOperationOk?: string;
}
/**
 *
 * @export
 * @interface ExpiredCodeExceptionError
 */
export interface ExpiredCodeExceptionError {
  /**
   *
   * @type {string}
   * @memberof ExpiredCodeExceptionError
   */
  name: ExpiredCodeExceptionErrorNameEnum;
  /**
   *
   * @type {string}
   * @memberof ExpiredCodeExceptionError
   */
  message: ExpiredCodeExceptionErrorMessageEnum;
  /**
   *
   * @type {number}
   * @memberof ExpiredCodeExceptionError
   */
  httpStatusCode: ExpiredCodeExceptionErrorHttpStatusCodeEnum;
  /**
   *
   * @type {string}
   * @memberof ExpiredCodeExceptionError
   */
  traceId: string;
  /**
   *
   * @type {Array<RateLimitExceededErrorDetailsInner>}
   * @memberof ExpiredCodeExceptionError
   */
  details?: Array<RateLimitExceededErrorDetailsInner>;
}

export const ExpiredCodeExceptionErrorNameEnum = {
  ExpiredCodeExceptionError: 'ExpiredCodeExceptionError',
} as const;

export type ExpiredCodeExceptionErrorNameEnum =
  (typeof ExpiredCodeExceptionErrorNameEnum)[keyof typeof ExpiredCodeExceptionErrorNameEnum];
export const ExpiredCodeExceptionErrorMessageEnum = {
  CodeHasExpired: 'Code has expired',
} as const;

export type ExpiredCodeExceptionErrorMessageEnum =
  (typeof ExpiredCodeExceptionErrorMessageEnum)[keyof typeof ExpiredCodeExceptionErrorMessageEnum];
export const ExpiredCodeExceptionErrorHttpStatusCodeEnum = {
  NUMBER_400: 400,
} as const;

export type ExpiredCodeExceptionErrorHttpStatusCodeEnum =
  (typeof ExpiredCodeExceptionErrorHttpStatusCodeEnum)[keyof typeof ExpiredCodeExceptionErrorHttpStatusCodeEnum];

/**
 *
 * @export
 * @interface InitiateRequest
 */
export interface InitiateRequest {
  /**
   *
   * @type {string}
   * @memberof InitiateRequest
   */
  email: string;
}
/**
 * initiateOtp operation response
 * @export
 * @interface InitiateResponse
 */
export interface InitiateResponse {
  /**
   *
   * @type {string}
   * @memberof InitiateResponse
   */
  message?: string;
}
/**
 * Thrown if for the specified endpoint count of calls exceeds the limit
 * @export
 * @interface RateLimitExceededError
 */
export interface RateLimitExceededError {
  /**
   *
   * @type {string}
   * @memberof RateLimitExceededError
   */
  name: RateLimitExceededErrorNameEnum;
  /**
   *
   * @type {string}
   * @memberof RateLimitExceededError
   */
  message: RateLimitExceededErrorMessageEnum;
  /**
   *
   * @type {number}
   * @memberof RateLimitExceededError
   */
  httpStatusCode: RateLimitExceededErrorHttpStatusCodeEnum;
  /**
   *
   * @type {string}
   * @memberof RateLimitExceededError
   */
  traceId: string;
  /**
   *
   * @type {Array<RateLimitExceededErrorDetailsInner>}
   * @memberof RateLimitExceededError
   */
  details?: Array<RateLimitExceededErrorDetailsInner>;
}

export const RateLimitExceededErrorNameEnum = {
  RateLimitExceededError: 'RateLimitExceededError',
} as const;

export type RateLimitExceededErrorNameEnum =
  (typeof RateLimitExceededErrorNameEnum)[keyof typeof RateLimitExceededErrorNameEnum];
export const RateLimitExceededErrorMessageEnum = {
  RateLimitExceededParam: 'Rate limit exceeded: ${param}.',
} as const;

export type RateLimitExceededErrorMessageEnum =
  (typeof RateLimitExceededErrorMessageEnum)[keyof typeof RateLimitExceededErrorMessageEnum];
export const RateLimitExceededErrorHttpStatusCodeEnum = {
  NUMBER_429: 429,
} as const;

export type RateLimitExceededErrorHttpStatusCodeEnum =
  (typeof RateLimitExceededErrorHttpStatusCodeEnum)[keyof typeof RateLimitExceededErrorHttpStatusCodeEnum];

/**
 *
 * @export
 * @interface RateLimitExceededErrorDetailsInner
 */
export interface RateLimitExceededErrorDetailsInner {
  /**
   *
   * @type {string}
   * @memberof RateLimitExceededErrorDetailsInner
   */
  issue: string;
  /**
   *
   * @type {string}
   * @memberof RateLimitExceededErrorDetailsInner
   */
  field?: string;
  /**
   *
   * @type {string}
   * @memberof RateLimitExceededErrorDetailsInner
   */
  value?: string;
  /**
   *
   * @type {string}
   * @memberof RateLimitExceededErrorDetailsInner
   */
  location?: string;
}
/**
 *
 * @export
 * @interface ServiceErrorResponse
 */
export interface ServiceErrorResponse {
  /**
   * unique id for correlating this specific error to logs
   * @type {string}
   * @memberof ServiceErrorResponse
   */
  traceId: string;
  /**
   * name of the error
   * @type {string}
   * @memberof ServiceErrorResponse
   */
  name: string;
  /**
   * backwards compatible Affinidi error code
   * @type {string}
   * @memberof ServiceErrorResponse
   */
  code: string;
  /**
   *
   * @type {Array<ServiceErrorResponseDetailsInner>}
   * @memberof ServiceErrorResponse
   */
  details?: Array<ServiceErrorResponseDetailsInner>;
}
/**
 *
 * @export
 * @interface ServiceErrorResponseDetailsInner
 */
export interface ServiceErrorResponseDetailsInner {
  /**
   *
   * @type {string}
   * @memberof ServiceErrorResponseDetailsInner
   */
  issue: string;
  /**
   *
   * @type {string}
   * @memberof ServiceErrorResponseDetailsInner
   */
  field?: string;
  /**
   *
   * @type {string}
   * @memberof ServiceErrorResponseDetailsInner
   */
  value?: string;
  /**
   *
   * @type {string}
   * @memberof ServiceErrorResponseDetailsInner
   */
  location?: ServiceErrorResponseDetailsInnerLocationEnum;
}

export const ServiceErrorResponseDetailsInnerLocationEnum = {
  Body: 'BODY',
  Path: 'PATH',
  Query: 'QUERY',
} as const;

export type ServiceErrorResponseDetailsInnerLocationEnum =
  (typeof ServiceErrorResponseDetailsInnerLocationEnum)[keyof typeof ServiceErrorResponseDetailsInnerLocationEnum];

/**
 * Unexpected service error.
 * @export
 * @interface UnexpectedServiceError
 */
export interface UnexpectedServiceError {
  /**
   *
   * @type {string}
   * @memberof UnexpectedServiceError
   */
  name: UnexpectedServiceErrorNameEnum;
  /**
   *
   * @type {string}
   * @memberof UnexpectedServiceError
   */
  message: UnexpectedServiceErrorMessageEnum;
  /**
   *
   * @type {number}
   * @memberof UnexpectedServiceError
   */
  httpStatusCode: UnexpectedServiceErrorHttpStatusCodeEnum;
  /**
   *
   * @type {string}
   * @memberof UnexpectedServiceError
   */
  traceId: string;
  /**
   *
   * @type {Array<RateLimitExceededErrorDetailsInner>}
   * @memberof UnexpectedServiceError
   */
  details?: Array<RateLimitExceededErrorDetailsInner>;
}

export const UnexpectedServiceErrorNameEnum = {
  UnexpectedServiceError: 'UnexpectedServiceError',
} as const;

export type UnexpectedServiceErrorNameEnum =
  (typeof UnexpectedServiceErrorNameEnum)[keyof typeof UnexpectedServiceErrorNameEnum];
export const UnexpectedServiceErrorMessageEnum = {
  UnexpectedErrorOccurred: 'Unexpected error occurred.',
} as const;

export type UnexpectedServiceErrorMessageEnum =
  (typeof UnexpectedServiceErrorMessageEnum)[keyof typeof UnexpectedServiceErrorMessageEnum];
export const UnexpectedServiceErrorHttpStatusCodeEnum = {
  NUMBER_500: 500,
} as const;

export type UnexpectedServiceErrorHttpStatusCodeEnum =
  (typeof UnexpectedServiceErrorHttpStatusCodeEnum)[keyof typeof UnexpectedServiceErrorHttpStatusCodeEnum];

/**
 *
 * @export
 * @interface UserNotFoundExceptionError
 */
export interface UserNotFoundExceptionError {
  /**
   *
   * @type {string}
   * @memberof UserNotFoundExceptionError
   */
  name: UserNotFoundExceptionErrorNameEnum;
  /**
   *
   * @type {string}
   * @memberof UserNotFoundExceptionError
   */
  message: UserNotFoundExceptionErrorMessageEnum;
  /**
   *
   * @type {number}
   * @memberof UserNotFoundExceptionError
   */
  httpStatusCode: UserNotFoundExceptionErrorHttpStatusCodeEnum;
  /**
   *
   * @type {string}
   * @memberof UserNotFoundExceptionError
   */
  traceId: string;
  /**
   *
   * @type {Array<RateLimitExceededErrorDetailsInner>}
   * @memberof UserNotFoundExceptionError
   */
  details?: Array<RateLimitExceededErrorDetailsInner>;
}

export const UserNotFoundExceptionErrorNameEnum = {
  UserNotFoundExceptionError: 'UserNotFoundExceptionError',
} as const;

export type UserNotFoundExceptionErrorNameEnum =
  (typeof UserNotFoundExceptionErrorNameEnum)[keyof typeof UserNotFoundExceptionErrorNameEnum];
export const UserNotFoundExceptionErrorMessageEnum = {
  UserCannotBeFoundPleaseEnterEmailAddressAgain:
    'User cannot be found. Please enter email address again.',
} as const;

export type UserNotFoundExceptionErrorMessageEnum =
  (typeof UserNotFoundExceptionErrorMessageEnum)[keyof typeof UserNotFoundExceptionErrorMessageEnum];
export const UserNotFoundExceptionErrorHttpStatusCodeEnum = {
  NUMBER_404: 404,
} as const;

export type UserNotFoundExceptionErrorHttpStatusCodeEnum =
  (typeof UserNotFoundExceptionErrorHttpStatusCodeEnum)[keyof typeof UserNotFoundExceptionErrorHttpStatusCodeEnum];

/**
 *
 * @export
 * @interface UsernameExistsExceptionError
 */
export interface UsernameExistsExceptionError {
  /**
   *
   * @type {string}
   * @memberof UsernameExistsExceptionError
   */
  name: UsernameExistsExceptionErrorNameEnum;
  /**
   *
   * @type {string}
   * @memberof UsernameExistsExceptionError
   */
  message: UsernameExistsExceptionErrorMessageEnum;
  /**
   *
   * @type {number}
   * @memberof UsernameExistsExceptionError
   */
  httpStatusCode: UsernameExistsExceptionErrorHttpStatusCodeEnum;
  /**
   *
   * @type {string}
   * @memberof UsernameExistsExceptionError
   */
  traceId: string;
  /**
   *
   * @type {Array<RateLimitExceededErrorDetailsInner>}
   * @memberof UsernameExistsExceptionError
   */
  details?: Array<RateLimitExceededErrorDetailsInner>;
}

export const UsernameExistsExceptionErrorNameEnum = {
  UsernameExistsExceptionError: 'UsernameExistsExceptionError',
} as const;

export type UsernameExistsExceptionErrorNameEnum =
  (typeof UsernameExistsExceptionErrorNameEnum)[keyof typeof UsernameExistsExceptionErrorNameEnum];
export const UsernameExistsExceptionErrorMessageEnum = {
  UsernameAlreadyExists: 'Username already exists',
} as const;

export type UsernameExistsExceptionErrorMessageEnum =
  (typeof UsernameExistsExceptionErrorMessageEnum)[keyof typeof UsernameExistsExceptionErrorMessageEnum];
export const UsernameExistsExceptionErrorHttpStatusCodeEnum = {
  NUMBER_409: 409,
} as const;

export type UsernameExistsExceptionErrorHttpStatusCodeEnum =
  (typeof UsernameExistsExceptionErrorHttpStatusCodeEnum)[keyof typeof UsernameExistsExceptionErrorHttpStatusCodeEnum];

/**
 * CorsApi - axios parameter creator
 * @export
 */
export const CorsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Enables CORS by returning correct headers
     * @summary CORS Support
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    corsCompleteOtpOperation: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/otp/complete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'OPTIONS',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Enables CORS by returning correct headers
     * @summary CORS Support
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    corsInitiateOtpOperation: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/otp/initiate`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'OPTIONS',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CorsApi - functional programming interface
 * @export
 */
export const CorsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = CorsApiAxiosParamCreator(configuration);
  return {
    /**
     * Enables CORS by returning correct headers
     * @summary CORS Support
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async corsCompleteOtpOperation(
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CorsCompleteOtpOperationOK>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.corsCompleteOtpOperation(options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['CorsApi.corsCompleteOtpOperation']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Enables CORS by returning correct headers
     * @summary CORS Support
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async corsInitiateOtpOperation(
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CorsInitiateOtpOperationOK>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.corsInitiateOtpOperation(options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['CorsApi.corsInitiateOtpOperation']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
  };
};

/**
 * CorsApi - factory interface
 * @export
 */
export const CorsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = CorsApiFp(configuration);
  return {
    /**
     * Enables CORS by returning correct headers
     * @summary CORS Support
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    corsCompleteOtpOperation(
      options?: any
    ): AxiosPromise<CorsCompleteOtpOperationOK> {
      return localVarFp
        .corsCompleteOtpOperation(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Enables CORS by returning correct headers
     * @summary CORS Support
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    corsInitiateOtpOperation(
      options?: any
    ): AxiosPromise<CorsInitiateOtpOperationOK> {
      return localVarFp
        .corsInitiateOtpOperation(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * CorsApi - object-oriented interface
 * @export
 * @class CorsApi
 * @extends {BaseAPI}
 */
export class CorsApi extends BaseAPI {
  /**
   * Enables CORS by returning correct headers
   * @summary CORS Support
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CorsApi
   */
  public corsCompleteOtpOperation(options?: RawAxiosRequestConfig) {
    return CorsApiFp(this.configuration)
      .corsCompleteOtpOperation(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Enables CORS by returning correct headers
   * @summary CORS Support
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CorsApi
   */
  public corsInitiateOtpOperation(options?: RawAxiosRequestConfig) {
    return CorsApiFp(this.configuration)
      .corsInitiateOtpOperation(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * OtpApi - axios parameter creator
 * @export
 */
export const OtpApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {CompleteRequest} completeRequest CompleteOtpOperation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    completeOtpOperation: async (
      completeRequest: CompleteRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'completeRequest' is not null or undefined
      assertParamExists(
        'completeOtpOperation',
        'completeRequest',
        completeRequest
      );
      const localVarPath = `/v1/otp/complete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ConsumerTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        completeRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {InitiateRequest} initiateRequest InitiateOtpOperation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    initiateOtpOperation: async (
      initiateRequest: InitiateRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'initiateRequest' is not null or undefined
      assertParamExists(
        'initiateOtpOperation',
        'initiateRequest',
        initiateRequest
      );
      const localVarPath = `/v1/otp/initiate`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ConsumerTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        initiateRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * OtpApi - functional programming interface
 * @export
 */
export const OtpApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = OtpApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {CompleteRequest} completeRequest CompleteOtpOperation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async completeOtpOperation(
      completeRequest: CompleteRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CompleteResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.completeOtpOperation(
          completeRequest,
          options
        );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['OtpApi.completeOtpOperation']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @param {InitiateRequest} initiateRequest InitiateOtpOperation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async initiateOtpOperation(
      initiateRequest: InitiateRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InitiateResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.initiateOtpOperation(
          initiateRequest,
          options
        );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['OtpApi.initiateOtpOperation']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
  };
};

/**
 * OtpApi - factory interface
 * @export
 */
export const OtpApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = OtpApiFp(configuration);
  return {
    /**
     *
     * @param {CompleteRequest} completeRequest CompleteOtpOperation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    completeOtpOperation(
      completeRequest: CompleteRequest,
      options?: any
    ): AxiosPromise<CompleteResponse> {
      return localVarFp
        .completeOtpOperation(completeRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {InitiateRequest} initiateRequest InitiateOtpOperation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    initiateOtpOperation(
      initiateRequest: InitiateRequest,
      options?: any
    ): AxiosPromise<InitiateResponse> {
      return localVarFp
        .initiateOtpOperation(initiateRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * OtpApi - object-oriented interface
 * @export
 * @class OtpApi
 * @extends {BaseAPI}
 */
export class OtpApi extends BaseAPI {
  /**
   *
   * @param {CompleteRequest} completeRequest CompleteOtpOperation
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OtpApi
   */
  public completeOtpOperation(
    completeRequest: CompleteRequest,
    options?: RawAxiosRequestConfig
  ) {
    return OtpApiFp(this.configuration)
      .completeOtpOperation(completeRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {InitiateRequest} initiateRequest InitiateOtpOperation
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OtpApi
   */
  public initiateOtpOperation(
    initiateRequest: InitiateRequest,
    options?: RawAxiosRequestConfig
  ) {
    return OtpApiFp(this.configuration)
      .initiateOtpOperation(initiateRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
