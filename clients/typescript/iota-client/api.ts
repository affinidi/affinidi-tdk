/* tslint:disable */
/* eslint-disable */
/**
 * IotaService
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: info@affinidi.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration'
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios'
import globalAxios from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common'
import type { RequestArgs } from './base'
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  BaseAPI,
  RequiredError,
  operationServerMap,
} from './base'

/**
 *
 * @export
 * @interface AlreadyExistsError
 */
export interface AlreadyExistsError {
  /**
   *
   * @type {string}
   * @memberof AlreadyExistsError
   */
  name: AlreadyExistsErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof AlreadyExistsError
   */
  message: AlreadyExistsErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof AlreadyExistsError
   */
  httpStatusCode: AlreadyExistsErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof AlreadyExistsError
   */
  traceId: string
  /**
   *
   * @type {Array<InvalidParameterErrorDetailsInner>}
   * @memberof AlreadyExistsError
   */
  details?: Array<InvalidParameterErrorDetailsInner>
}

export const AlreadyExistsErrorNameEnum = {
  AlreadyExistsError: 'AlreadyExistsError',
} as const

export type AlreadyExistsErrorNameEnum =
  (typeof AlreadyExistsErrorNameEnum)[keyof typeof AlreadyExistsErrorNameEnum]
export const AlreadyExistsErrorMessageEnum = {
  AlreadyExistsParam: 'Already exists: ${param}.',
} as const

export type AlreadyExistsErrorMessageEnum =
  (typeof AlreadyExistsErrorMessageEnum)[keyof typeof AlreadyExistsErrorMessageEnum]
export const AlreadyExistsErrorHttpStatusCodeEnum = {
  NUMBER_409: 409,
} as const

export type AlreadyExistsErrorHttpStatusCodeEnum =
  (typeof AlreadyExistsErrorHttpStatusCodeEnum)[keyof typeof AlreadyExistsErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface AwsExchangeCredentials
 */
export interface AwsExchangeCredentials {
  /**
   * A valid JSON Web Token (JWT) that secures the WebSocket connection. The JWT is signed with the key pair\'s private key used to create the Personal Access Token (PAT).
   * @type {string}
   * @memberof AwsExchangeCredentials
   */
  assertion: string
}
/**
 *
 * @export
 * @interface AwsExchangeCredentialsOK
 */
export interface AwsExchangeCredentialsOK {
  /**
   *
   * @type {string}
   * @memberof AwsExchangeCredentialsOK
   */
  connectionClientId: string
  /**
   *
   * @type {AwsExchangeCredentialsProjectTokenOKCredentials}
   * @memberof AwsExchangeCredentialsOK
   */
  credentials: AwsExchangeCredentialsProjectTokenOKCredentials
}
/**
 *
 * @export
 * @interface AwsExchangeCredentialsProjectToken
 */
export interface AwsExchangeCredentialsProjectToken {
  /**
   * ID of the session generated by a client.
   * @type {string}
   * @memberof AwsExchangeCredentialsProjectToken
   */
  sessionId: string
  /**
   * ID of the Affinidi Iota Framework configuration.
   * @type {string}
   * @memberof AwsExchangeCredentialsProjectToken
   */
  configurationId: string
  /**
   * The Decentalised Identifier (DID) of the user.
   * @type {string}
   * @memberof AwsExchangeCredentialsProjectToken
   */
  did: string
}
/**
 *
 * @export
 * @interface AwsExchangeCredentialsProjectTokenOK
 */
export interface AwsExchangeCredentialsProjectTokenOK {
  /**
   *
   * @type {string}
   * @memberof AwsExchangeCredentialsProjectTokenOK
   */
  connectionClientId: string
  /**
   *
   * @type {AwsExchangeCredentialsProjectTokenOKCredentials}
   * @memberof AwsExchangeCredentialsProjectTokenOK
   */
  credentials: AwsExchangeCredentialsProjectTokenOKCredentials
}
/**
 *
 * @export
 * @interface AwsExchangeCredentialsProjectTokenOKCredentials
 */
export interface AwsExchangeCredentialsProjectTokenOKCredentials {
  /**
   *
   * @type {string}
   * @memberof AwsExchangeCredentialsProjectTokenOKCredentials
   */
  identityId: string
  /**
   *
   * @type {string}
   * @memberof AwsExchangeCredentialsProjectTokenOKCredentials
   */
  token: string
}
/**
 *
 * @export
 * @interface CallbackInput
 */
export interface CallbackInput {
  /**
   * A randomly generated string that follows a valid UUID (version 1-5) format to validate the session.
   * @type {string}
   * @memberof CallbackInput
   */
  state: string
  /**
   * A JSON string format that describes the link between the Verifiable Presentation and Presentation Definition for the verifier. The presentation submission follows the OID4VP standard.
   * @type {string}
   * @memberof CallbackInput
   */
  presentation_submission?: string
  /**
   * A JSON string format containing the data the user consented to share in a Verifiable Presentation format. The VP Token follows the OID4VP standard.
   * @type {string}
   * @memberof CallbackInput
   */
  vp_token?: string
  /**
   * A short string indicating the error code reported by the service. It follows the OAuth 2.0 error code format (e.g., invalid_request, access_denied). The default is access_denied.
   * @type {string}
   * @memberof CallbackInput
   */
  error?: string
  /**
   * A human-readable description that provides detailed information about the error.
   * @type {string}
   * @memberof CallbackInput
   */
  error_description?: string
  /**
   * It specifies whether the data sharing flow triggered an onboarding process to the Affinidi Vault [New User].
   * @type {boolean}
   * @memberof CallbackInput
   */
  onboarded?: boolean
}
/**
 *
 * @export
 * @interface CallbackResponseOK
 */
export interface CallbackResponseOK {
  /**
   * The URL to which Affinidi Vault will redirect the user.
   * @type {string}
   * @memberof CallbackResponseOK
   */
  redirect_uri?: string
  /**
   * A unique identifier to fetch the callback response data. Send this value together with the transactionId to successfully fetch the data.
   * @type {string}
   * @memberof CallbackResponseOK
   */
  response_code?: string
  /**
   * A message to the Affinidi Vault indicating that the update was successful.
   * @type {string}
   * @memberof CallbackResponseOK
   */
  message: string
}
/**
 *
 * @export
 * @interface ConsentDto
 */
export interface ConsentDto {
  /**
   * The ID of the project.
   * @type {string}
   * @memberof ConsentDto
   */
  projectId: string
  /**
   * Unique identifier for the record.
   * @type {string}
   * @memberof ConsentDto
   */
  id: string
  /**
   * Unique identifier for the user.
   * @type {string}
   * @memberof ConsentDto
   */
  userId: string
  /**
   * Type of the VC shared by the user. It creates a consent record for each  VC type shared except for the base type VerifiableCredential.
   * @type {string}
   * @memberof ConsentDto
   */
  vcType: string
  /**
   * Status of the consent.
   * @type {string}
   * @memberof ConsentDto
   */
  status: ConsentDtoStatusEnum
  /**
   *
   * @type {string}
   * @memberof ConsentDto
   */
  modifiedAt: string
  /**
   *
   * @type {string}
   * @memberof ConsentDto
   */
  modifiedBy: string
  /**
   *
   * @type {string}
   * @memberof ConsentDto
   */
  createdAt: string
  /**
   *
   * @type {string}
   * @memberof ConsentDto
   */
  createdBy: string
}

export const ConsentDtoStatusEnum = {
  Given: 'GIVEN',
} as const

export type ConsentDtoStatusEnum =
  (typeof ConsentDtoStatusEnum)[keyof typeof ConsentDtoStatusEnum]

/**
 *
 * @export
 * @interface CorsAwsExchangeCredentialsOK
 */
export interface CorsAwsExchangeCredentialsOK {
  /**
   *
   * @type {string}
   * @memberof CorsAwsExchangeCredentialsOK
   */
  corsAwsExchangeCredentialsOk?: string
}
/**
 *
 * @export
 * @interface CorsAwsExchangeCredentialsProjectTokenOK
 */
export interface CorsAwsExchangeCredentialsProjectTokenOK {
  /**
   *
   * @type {string}
   * @memberof CorsAwsExchangeCredentialsProjectTokenOK
   */
  corsAwsExchangeCredentialsProjectTokenOk?: string
}
/**
 *
 * @export
 * @interface CorsFetchIotaVpResponseOK
 */
export interface CorsFetchIotaVpResponseOK {
  /**
   *
   * @type {string}
   * @memberof CorsFetchIotaVpResponseOK
   */
  corsFetchIotaVpResponseOk?: string
}
/**
 *
 * @export
 * @interface CorsInitiateDataSharingRequestOK
 */
export interface CorsInitiateDataSharingRequestOK {
  /**
   *
   * @type {string}
   * @memberof CorsInitiateDataSharingRequestOK
   */
  corsInitiateDataSharingRequestOk?: string
}
/**
 *
 * @export
 * @interface CorsIotOidc4vpcallbackOK
 */
export interface CorsIotOidc4vpcallbackOK {
  /**
   *
   * @type {string}
   * @memberof CorsIotOidc4vpcallbackOK
   */
  corsIotOidc4vpcallbackOk?: string
}
/**
 *
 * @export
 * @interface CorsIotaExchangeCredentialsOK
 */
export interface CorsIotaExchangeCredentialsOK {
  /**
   *
   * @type {string}
   * @memberof CorsIotaExchangeCredentialsOK
   */
  corsIotaExchangeCredentialsOk?: string
}
/**
 *
 * @export
 * @interface CreateDcqlQueryInput
 */
export interface CreateDcqlQueryInput {
  /**
   * The name of the DCQL query to quickly identify the query.
   * @type {string}
   * @memberof CreateDcqlQueryInput
   */
  name: string
  /**
   * The DCQL query describing the data requirement that must be satisfied by the user. The value is in a JSON stringify format.
   * @type {string}
   * @memberof CreateDcqlQueryInput
   */
  dcqlQuery: string
  /**
   * An optional description of what the query is used for.
   * @type {string}
   * @memberof CreateDcqlQueryInput
   */
  description?: string
}
/**
 *
 * @export
 * @interface CreateIotaConfigurationInput
 */
export interface CreateIotaConfigurationInput {
  /**
   * The name of the configuration to quickly identify the resource.
   * @type {string}
   * @memberof CreateIotaConfigurationInput
   */
  name: string
  /**
   * An optional description of what the configuration is used for.
   * @type {string}
   * @memberof CreateIotaConfigurationInput
   */
  description?: string
  /**
   * The unique resource identifier of the Wallet used to sign the request token.
   * @type {string}
   * @memberof CreateIotaConfigurationInput
   */
  walletAri: string
  /**
   * The webhook URL is used for callback when the data is ready.
   * @type {string}
   * @memberof CreateIotaConfigurationInput
   */
  iotaResponseWebhookURL?: string
  /**
   * Cryptographically verifies the data shared by the user when enabled.
   * @type {boolean}
   * @memberof CreateIotaConfigurationInput
   */
  enableVerification: boolean
  /**
   * Records the user\'s consent when they share their data, including the type of data shared when enabled.
   * @type {boolean}
   * @memberof CreateIotaConfigurationInput
   */
  enableConsentAuditLog: boolean
  /**
   * This is the lifetime of the signed request token during the data-sharing flow.
   * @type {number}
   * @memberof CreateIotaConfigurationInput
   */
  tokenMaxAge?: number
  /**
   *
   * @type {IotaConfigurationDtoClientMetadata}
   * @memberof CreateIotaConfigurationInput
   */
  clientMetadata: IotaConfigurationDtoClientMetadata
  /**
   * Determines whether to handle the data-sharing request using the WebSocket, Redirect or Didcomm messaging flow.
   * @type {string}
   * @memberof CreateIotaConfigurationInput
   */
  mode?: CreateIotaConfigurationInputModeEnum
  /**
   * List of allowed URLs to redirect users, including the response from the request. This is required if the selected data-sharing mode is Redirect.
   * @type {Array<string>}
   * @memberof CreateIotaConfigurationInput
   */
  redirectUris?: Array<string>
  /**
   * Enables identity verification from user with a 3rd-party provider when a verified identity document is not found.
   * @type {boolean}
   * @memberof CreateIotaConfigurationInput
   */
  enableIdvProviders?: boolean
}

export const CreateIotaConfigurationInputModeEnum = {
  Redirect: 'redirect',
  Websocket: 'websocket',
  Didcomm: 'didcomm',
} as const

export type CreateIotaConfigurationInputModeEnum =
  (typeof CreateIotaConfigurationInputModeEnum)[keyof typeof CreateIotaConfigurationInputModeEnum]

/**
 *
 * @export
 * @interface CreatePexQueryInput
 */
export interface CreatePexQueryInput {
  /**
   * The name of the presentation definition to quickly identify the query.
   * @type {string}
   * @memberof CreatePexQueryInput
   */
  name: string
  /**
   * The presentation definition describing the data requirement that must be satisfied by the user. The value is in a JSON stringify format.
   * @type {string}
   * @memberof CreatePexQueryInput
   */
  vpDefinition: string
  /**
   * An optional description of what the query is used for.
   * @type {string}
   * @memberof CreatePexQueryInput
   */
  description?: string
}
/**
 *
 * @export
 * @interface DcqlQueryDto
 */
export interface DcqlQueryDto {
  /**
   * The unique resource identifier of the qeuery.
   * @type {string}
   * @memberof DcqlQueryDto
   */
  ari: string
  /**
   * The ID of the query.
   * @type {string}
   * @memberof DcqlQueryDto
   */
  queryId: string
  /**
   * The name of the DCQL query to quickly identify the query.
   * @type {string}
   * @memberof DcqlQueryDto
   */
  name: string
  /**
   * An optional description of what the query is used for.
   * @type {string}
   * @memberof DcqlQueryDto
   */
  description: string
  /**
   * The unique resource identifier of the related configuration where the query is defined.
   * @type {string}
   * @memberof DcqlQueryDto
   */
  configurationAri: string
  /**
   * The DCQL query describing the data requirement that must be satisfied by the user. The value is in a JSON stringify format.
   * @type {string}
   * @memberof DcqlQueryDto
   */
  dcqlQuery: string
}
/**
 *
 * @export
 * @interface DeletePexQueriesInput
 */
export interface DeletePexQueriesInput {
  /**
   *
   * @type {Array<string>}
   * @memberof DeletePexQueriesInput
   */
  queryIds: Array<string>
}
/**
 *
 * @export
 * @interface FetchIOTAVPResponseInput
 */
export interface FetchIOTAVPResponseInput {
  /**
   * A unique, randomly generated identifier that correlates the request and response in the data-sharing request flow.
   * @type {string}
   * @memberof FetchIOTAVPResponseInput
   */
  correlationId: string
  /**
   * A unique, randomly generated identifier data-sharing request flow is initiated. This value is used with the response code to fetch the callback response data.
   * @type {string}
   * @memberof FetchIOTAVPResponseInput
   */
  transactionId: string
  /**
   * A unique identifier to fetch the callback response data. Send this value together with the transactionId to successfully fetch the data.
   * @type {string}
   * @memberof FetchIOTAVPResponseInput
   */
  responseCode: string
  /**
   * ID of the Affinidi Iota Framework configuration.
   * @type {string}
   * @memberof FetchIOTAVPResponseInput
   */
  configurationId: string
}
/**
 *
 * @export
 * @interface FetchIOTAVPResponseOK
 */
export interface FetchIOTAVPResponseOK {
  /**
   * A unique, randomly generated identifier that correlates the request and response in the data-sharing request flow.
   * @type {string}
   * @memberof FetchIOTAVPResponseOK
   */
  correlationId?: string
  /**
   * A JSON string format that describes the link between the Verifiable Presentation and Presentation Definition for the verifier. The presentation submission follows the OID4VP standard.
   * @type {string}
   * @memberof FetchIOTAVPResponseOK
   */
  presentation_submission?: string
  /**
   * A JSON string format containing the data the user consented to share in a Verifiable Presentation format. The VP Token follows the OID4VP standard.
   * @type {string}
   * @memberof FetchIOTAVPResponseOK
   */
  vp_token?: string
}
/**
 *
 * @export
 * @interface GetIotaConfigurationMetaDataOK
 */
export interface GetIotaConfigurationMetaDataOK {
  /**
   * The name displayed on the consent page indicates who is requesting data from the user. It can be the application or website\'s name.
   * @type {string}
   * @memberof GetIotaConfigurationMetaDataOK
   */
  name: string
  /**
   * The URL of the requester displayed on the consent page indicates the request\'s origin.
   * @type {string}
   * @memberof GetIotaConfigurationMetaDataOK
   */
  origin: string
  /**
   * The logo of the requester displayed on the consent page, allowing users to easily recognise who requests the data.
   * @type {string}
   * @memberof GetIotaConfigurationMetaDataOK
   */
  logo: string
}
/**
 *
 * @export
 * @interface InitiateDataSharingRequestInput
 */
export interface InitiateDataSharingRequestInput {
  /**
   * The ID of the query.
   * @type {string}
   * @memberof InitiateDataSharingRequestInput
   */
  queryId: string
  /**
   * A unique, randomly generated identifier that correlates the request and response in the data-sharing request flow.
   * @type {string}
   * @memberof InitiateDataSharingRequestInput
   */
  correlationId: string
  /**
   * This is the lifetime of the signed request token during the data-sharing flow.
   * @type {number}
   * @memberof InitiateDataSharingRequestInput
   */
  tokenMaxAge?: number
  /**
   * A randomly generated value that is added in the request and response to prevent replay attacks.
   * @type {string}
   * @memberof InitiateDataSharingRequestInput
   */
  nonce: string
  /**
   * List of allowed URLs to redirect users, including the response from the request. This is required if the selected data-sharing mode is Redirect.
   * @type {string}
   * @memberof InitiateDataSharingRequestInput
   */
  redirectUri: string
  /**
   * ID of the Affinidi Iota Framework configuration.
   * @type {string}
   * @memberof InitiateDataSharingRequestInput
   */
  configurationId: string
  /**
   * User did to send the initiating request to. Only required if mode is didcomm
   * @type {string}
   * @memberof InitiateDataSharingRequestInput
   */
  userDid?: string
  /**
   * Determines whether to handle the data-sharing request using the WebSocket, Redirect or Didcomm messaging flow.
   * @type {string}
   * @memberof InitiateDataSharingRequestInput
   */
  mode: InitiateDataSharingRequestInputModeEnum
}

export const InitiateDataSharingRequestInputModeEnum = {
  Redirect: 'redirect',
  Websocket: 'websocket',
  Didcomm: 'didcomm',
} as const

export type InitiateDataSharingRequestInputModeEnum =
  (typeof InitiateDataSharingRequestInputModeEnum)[keyof typeof InitiateDataSharingRequestInputModeEnum]

/**
 *
 * @export
 * @interface InitiateDataSharingRequestOK
 */
export interface InitiateDataSharingRequestOK {
  /**
   *
   * @type {InitiateDataSharingRequestOKData}
   * @memberof InitiateDataSharingRequestOK
   */
  data?: InitiateDataSharingRequestOKData
}
/**
 *
 * @export
 * @interface InitiateDataSharingRequestOKData
 */
export interface InitiateDataSharingRequestOKData {
  /**
   *
   * @type {string}
   * @memberof InitiateDataSharingRequestOKData
   */
  jwt: string
  /**
   *
   * @type {string}
   * @memberof InitiateDataSharingRequestOKData
   */
  correlationId: string
  /**
   *
   * @type {string}
   * @memberof InitiateDataSharingRequestOKData
   */
  transactionId: string
}
/**
 *
 * @export
 * @interface InvalidParameterError
 */
export interface InvalidParameterError {
  /**
   *
   * @type {string}
   * @memberof InvalidParameterError
   */
  name: InvalidParameterErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof InvalidParameterError
   */
  message: InvalidParameterErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof InvalidParameterError
   */
  httpStatusCode: InvalidParameterErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof InvalidParameterError
   */
  traceId: string
  /**
   *
   * @type {Array<InvalidParameterErrorDetailsInner>}
   * @memberof InvalidParameterError
   */
  details?: Array<InvalidParameterErrorDetailsInner>
}

export const InvalidParameterErrorNameEnum = {
  InvalidParameterError: 'InvalidParameterError',
} as const

export type InvalidParameterErrorNameEnum =
  (typeof InvalidParameterErrorNameEnum)[keyof typeof InvalidParameterErrorNameEnum]
export const InvalidParameterErrorMessageEnum = {
  InvalidParameterParam: 'Invalid parameter: ${param}.',
} as const

export type InvalidParameterErrorMessageEnum =
  (typeof InvalidParameterErrorMessageEnum)[keyof typeof InvalidParameterErrorMessageEnum]
export const InvalidParameterErrorHttpStatusCodeEnum = {
  NUMBER_400: 400,
} as const

export type InvalidParameterErrorHttpStatusCodeEnum =
  (typeof InvalidParameterErrorHttpStatusCodeEnum)[keyof typeof InvalidParameterErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface InvalidParameterErrorDetailsInner
 */
export interface InvalidParameterErrorDetailsInner {
  /**
   *
   * @type {string}
   * @memberof InvalidParameterErrorDetailsInner
   */
  issue: string
  /**
   *
   * @type {string}
   * @memberof InvalidParameterErrorDetailsInner
   */
  field?: string
  /**
   *
   * @type {string}
   * @memberof InvalidParameterErrorDetailsInner
   */
  value?: string
  /**
   *
   * @type {string}
   * @memberof InvalidParameterErrorDetailsInner
   */
  location?: string
}
/**
 *
 * @export
 * @interface IotaConfigurationDto
 */
export interface IotaConfigurationDto {
  /**
   * This is a unique resource identifier of the Affinidi Iota Framework configuration.
   * @type {string}
   * @memberof IotaConfigurationDto
   */
  ari: string
  /**
   * ID of the Affinidi Iota Framework configuration.
   * @type {string}
   * @memberof IotaConfigurationDto
   */
  configurationId: string
  /**
   * The name of the configuration to quickly identify the resource.
   * @type {string}
   * @memberof IotaConfigurationDto
   */
  name: string
  /**
   * The ID of the project.
   * @type {string}
   * @memberof IotaConfigurationDto
   */
  projectId: string
  /**
   * The unique resource identifier of the Wallet used to sign the request token.
   * @type {string}
   * @memberof IotaConfigurationDto
   */
  walletAri: string
  /**
   * This is the lifetime of the signed request token during the data-sharing flow.
   * @type {number}
   * @memberof IotaConfigurationDto
   */
  tokenMaxAge: number
  /**
   * The webhook URL is used for callback when the data is ready.
   * @type {string}
   * @memberof IotaConfigurationDto
   */
  iotaResponseWebhookURL?: string
  /**
   * Cryptographically verifies the data shared by the user when enabled.
   * @type {boolean}
   * @memberof IotaConfigurationDto
   */
  enableVerification: boolean
  /**
   * Records the consent the user gave when they shared their data, including the type of data shared.
   * @type {boolean}
   * @memberof IotaConfigurationDto
   */
  enableConsentAuditLog: boolean
  /**
   *
   * @type {IotaConfigurationDtoClientMetadata}
   * @memberof IotaConfigurationDto
   */
  clientMetadata: IotaConfigurationDtoClientMetadata
  /**
   * Determines whether to handle the data-sharing request using the WebSocket, Redirect or Didcomm messaging flow.
   * @type {string}
   * @memberof IotaConfigurationDto
   */
  mode?: IotaConfigurationDtoModeEnum
  /**
   * List of allowed URLs to redirect users, including the response from the request. This is required if the selected data-sharing mode is Redirect.
   * @type {Array<string>}
   * @memberof IotaConfigurationDto
   */
  redirectUris?: Array<string>
  /**
   * Enables identity verification from user with a 3rd-party provider when a verified identity document is not found.
   * @type {boolean}
   * @memberof IotaConfigurationDto
   */
  enableIdvProviders?: boolean
}

export const IotaConfigurationDtoModeEnum = {
  Redirect: 'redirect',
  Websocket: 'websocket',
  Didcomm: 'didcomm',
} as const

export type IotaConfigurationDtoModeEnum =
  (typeof IotaConfigurationDtoModeEnum)[keyof typeof IotaConfigurationDtoModeEnum]

/**
 * It contains information about the requester or verifier.
 * @export
 * @interface IotaConfigurationDtoClientMetadata
 */
export interface IotaConfigurationDtoClientMetadata {
  /**
   * The name displayed on the consent page indicates who is requesting data from the user. It can be the application or website\'s name.
   * @type {string}
   * @memberof IotaConfigurationDtoClientMetadata
   */
  name: string
  /**
   * The URL of the requester displayed on the consent page indicates the request\'s origin.
   * @type {string}
   * @memberof IotaConfigurationDtoClientMetadata
   */
  origin: string
  /**
   * The logo of the requester displayed on the consent page, allowing users to easily recognise who requests the data.
   * @type {string}
   * @memberof IotaConfigurationDtoClientMetadata
   */
  logo: string
}
/**
 *
 * @export
 * @interface IotaExchangeCredentials
 */
export interface IotaExchangeCredentials {
  /**
   * A valid JSON Web Token (JWT) that secures the WebSocket connection. The JWT is signed with the key pair\'s private key used to create the Personal Access Token (PAT).
   * @type {string}
   * @memberof IotaExchangeCredentials
   */
  assertion: string
}
/**
 *
 * @export
 * @interface IotaExchangeCredentialsOK
 */
export interface IotaExchangeCredentialsOK {
  /**
   *
   * @type {string}
   * @memberof IotaExchangeCredentialsOK
   */
  connectionClientId: string
  /**
   *
   * @type {IotaExchangeCredentialsOKCredentials}
   * @memberof IotaExchangeCredentialsOK
   */
  credentials: IotaExchangeCredentialsOKCredentials
}
/**
 *
 * @export
 * @interface IotaExchangeCredentialsOKCredentials
 */
export interface IotaExchangeCredentialsOKCredentials {
  /**
   *
   * @type {string}
   * @memberof IotaExchangeCredentialsOKCredentials
   */
  accessKeyId: string
  /**
   *
   * @type {string}
   * @memberof IotaExchangeCredentialsOKCredentials
   */
  secretKey: string
  /**
   *
   * @type {string}
   * @memberof IotaExchangeCredentialsOKCredentials
   */
  sessionToken: string
  /**
   *
   * @type {string}
   * @memberof IotaExchangeCredentialsOKCredentials
   */
  expiration: string
}
/**
 *
 * @export
 * @interface ListConfigurationOK
 */
export interface ListConfigurationOK {
  /**
   *
   * @type {Array<IotaConfigurationDto>}
   * @memberof ListConfigurationOK
   */
  configurations: Array<IotaConfigurationDto>
}
/**
 *
 * @export
 * @interface ListDcqlQueriesOK
 */
export interface ListDcqlQueriesOK {
  /**
   *
   * @type {Array<DcqlQueryDto>}
   * @memberof ListDcqlQueriesOK
   */
  dcqlQueries: Array<DcqlQueryDto>
  /**
   *
   * @type {string}
   * @memberof ListDcqlQueriesOK
   */
  lastEvaluatedKey?: string
}
/**
 *
 * @export
 * @interface ListLoggedConsentsOK
 */
export interface ListLoggedConsentsOK {
  /**
   *
   * @type {Array<ConsentDto>}
   * @memberof ListLoggedConsentsOK
   */
  consents: Array<ConsentDto>
  /**
   *
   * @type {string}
   * @memberof ListLoggedConsentsOK
   */
  lastEvaluatedKey?: string
}
/**
 *
 * @export
 * @interface ListPexQueriesOK
 */
export interface ListPexQueriesOK {
  /**
   *
   * @type {Array<PexQueryDto>}
   * @memberof ListPexQueriesOK
   */
  pexQueries: Array<PexQueryDto>
  /**
   *
   * @type {string}
   * @memberof ListPexQueriesOK
   */
  lastEvaluatedKey?: string
}
/**
 *
 * @export
 * @interface MessagePublishingError
 */
export interface MessagePublishingError {
  /**
   *
   * @type {string}
   * @memberof MessagePublishingError
   */
  name: MessagePublishingErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof MessagePublishingError
   */
  message: MessagePublishingErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof MessagePublishingError
   */
  httpStatusCode: MessagePublishingErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof MessagePublishingError
   */
  traceId: string
  /**
   *
   * @type {Array<InvalidParameterErrorDetailsInner>}
   * @memberof MessagePublishingError
   */
  details?: Array<InvalidParameterErrorDetailsInner>
}

export const MessagePublishingErrorNameEnum = {
  MessagePublishingError: 'MessagePublishingError',
} as const

export type MessagePublishingErrorNameEnum =
  (typeof MessagePublishingErrorNameEnum)[keyof typeof MessagePublishingErrorNameEnum]
export const MessagePublishingErrorMessageEnum = {
  NotAbleToPublishMessagesToTopic: 'Not able to publish messages to topic',
} as const

export type MessagePublishingErrorMessageEnum =
  (typeof MessagePublishingErrorMessageEnum)[keyof typeof MessagePublishingErrorMessageEnum]
export const MessagePublishingErrorHttpStatusCodeEnum = {
  NUMBER_500: 500,
} as const

export type MessagePublishingErrorHttpStatusCodeEnum =
  (typeof MessagePublishingErrorHttpStatusCodeEnum)[keyof typeof MessagePublishingErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface NotFoundError
 */
export interface NotFoundError {
  /**
   *
   * @type {string}
   * @memberof NotFoundError
   */
  name: NotFoundErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof NotFoundError
   */
  message: NotFoundErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof NotFoundError
   */
  httpStatusCode: NotFoundErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof NotFoundError
   */
  traceId: string
  /**
   *
   * @type {Array<InvalidParameterErrorDetailsInner>}
   * @memberof NotFoundError
   */
  details?: Array<InvalidParameterErrorDetailsInner>
}

export const NotFoundErrorNameEnum = {
  NotFoundError: 'NotFoundError',
} as const

export type NotFoundErrorNameEnum =
  (typeof NotFoundErrorNameEnum)[keyof typeof NotFoundErrorNameEnum]
export const NotFoundErrorMessageEnum = {
  NotFoundParam: 'Not found: ${param}.',
} as const

export type NotFoundErrorMessageEnum =
  (typeof NotFoundErrorMessageEnum)[keyof typeof NotFoundErrorMessageEnum]
export const NotFoundErrorHttpStatusCodeEnum = {
  NUMBER_404: 404,
} as const

export type NotFoundErrorHttpStatusCodeEnum =
  (typeof NotFoundErrorHttpStatusCodeEnum)[keyof typeof NotFoundErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface OperationForbiddenError
 */
export interface OperationForbiddenError {
  /**
   *
   * @type {string}
   * @memberof OperationForbiddenError
   */
  name: OperationForbiddenErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof OperationForbiddenError
   */
  message: OperationForbiddenErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof OperationForbiddenError
   */
  httpStatusCode: OperationForbiddenErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof OperationForbiddenError
   */
  traceId: string
  /**
   *
   * @type {Array<InvalidParameterErrorDetailsInner>}
   * @memberof OperationForbiddenError
   */
  details?: Array<InvalidParameterErrorDetailsInner>
}

export const OperationForbiddenErrorNameEnum = {
  OperationForbiddenError: 'OperationForbiddenError',
} as const

export type OperationForbiddenErrorNameEnum =
  (typeof OperationForbiddenErrorNameEnum)[keyof typeof OperationForbiddenErrorNameEnum]
export const OperationForbiddenErrorMessageEnum = {
  OperationForbiddenParam: 'Operation forbidden: ${param}.',
} as const

export type OperationForbiddenErrorMessageEnum =
  (typeof OperationForbiddenErrorMessageEnum)[keyof typeof OperationForbiddenErrorMessageEnum]
export const OperationForbiddenErrorHttpStatusCodeEnum = {
  NUMBER_403: 403,
} as const

export type OperationForbiddenErrorHttpStatusCodeEnum =
  (typeof OperationForbiddenErrorHttpStatusCodeEnum)[keyof typeof OperationForbiddenErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface PexQueryDto
 */
export interface PexQueryDto {
  /**
   * The unique resource identifier of the qeuery.
   * @type {string}
   * @memberof PexQueryDto
   */
  ari: string
  /**
   * The ID of the query.
   * @type {string}
   * @memberof PexQueryDto
   */
  queryId: string
  /**
   * The name of the presentation definition to quickly identify the query.
   * @type {string}
   * @memberof PexQueryDto
   */
  name: string
  /**
   * An optional description of what the query is used for.
   * @type {string}
   * @memberof PexQueryDto
   */
  description: string
  /**
   * The unique resource identifier of the related configuration where the query is defined.
   * @type {string}
   * @memberof PexQueryDto
   */
  configurationAri: string
  /**
   * The presentation definition describing the data requirement that must be satisfied by the user. The value is in a JSON stringify format.
   * @type {string}
   * @memberof PexQueryDto
   */
  vpDefinition: string
}
/**
 *
 * @export
 * @interface PrepareRequest
 */
export interface PrepareRequest {
  /**
   *
   * @type {string}
   * @memberof PrepareRequest
   */
  connectionClientId: string
  /**
   *
   * @type {string}
   * @memberof PrepareRequest
   */
  queryId: string
  /**
   * A unique, randomly generated identifier that correlates the request and response in the data-sharing request flow.
   * @type {string}
   * @memberof PrepareRequest
   */
  correlationId: string
  /**
   * This is the lifetime of the signed request token during the data-sharing flow.
   * @type {number}
   * @memberof PrepareRequest
   */
  tokenMaxAge?: number
  /**
   *
   * @type {string}
   * @memberof PrepareRequest
   */
  audience?: string
}
/**
 *
 * @export
 * @interface PrepareRequestCreated
 */
export interface PrepareRequestCreated {
  /**
   *
   * @type {PrepareRequestCreatedData}
   * @memberof PrepareRequestCreated
   */
  data: PrepareRequestCreatedData
}
/**
 *
 * @export
 * @interface PrepareRequestCreatedData
 */
export interface PrepareRequestCreatedData {
  /**
   *
   * @type {string}
   * @memberof PrepareRequestCreatedData
   */
  jwt: string
  /**
   * A unique, randomly generated identifier that correlates the request and response in the data-sharing request flow.
   * @type {string}
   * @memberof PrepareRequestCreatedData
   */
  correlationId: string
}
/**
 *
 * @export
 * @interface ResourceLimitExceededError
 */
export interface ResourceLimitExceededError {
  /**
   *
   * @type {string}
   * @memberof ResourceLimitExceededError
   */
  name: ResourceLimitExceededErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof ResourceLimitExceededError
   */
  message: ResourceLimitExceededErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof ResourceLimitExceededError
   */
  httpStatusCode: ResourceLimitExceededErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof ResourceLimitExceededError
   */
  traceId: string
  /**
   *
   * @type {Array<InvalidParameterErrorDetailsInner>}
   * @memberof ResourceLimitExceededError
   */
  details?: Array<InvalidParameterErrorDetailsInner>
}

export const ResourceLimitExceededErrorNameEnum = {
  ResourceLimitExceededError: 'ResourceLimitExceededError',
} as const

export type ResourceLimitExceededErrorNameEnum =
  (typeof ResourceLimitExceededErrorNameEnum)[keyof typeof ResourceLimitExceededErrorNameEnum]
export const ResourceLimitExceededErrorMessageEnum = {
  ResourceLimitExceededParam: 'Resource limit exceeded: ${param}.',
} as const

export type ResourceLimitExceededErrorMessageEnum =
  (typeof ResourceLimitExceededErrorMessageEnum)[keyof typeof ResourceLimitExceededErrorMessageEnum]
export const ResourceLimitExceededErrorHttpStatusCodeEnum = {
  NUMBER_422: 422,
} as const

export type ResourceLimitExceededErrorHttpStatusCodeEnum =
  (typeof ResourceLimitExceededErrorHttpStatusCodeEnum)[keyof typeof ResourceLimitExceededErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface SavePexQueriesUpdateInput
 */
export interface SavePexQueriesUpdateInput {
  /**
   *
   * @type {Array<SavePexQueriesUpdateInputQueriesInner>}
   * @memberof SavePexQueriesUpdateInput
   */
  queries?: Array<SavePexQueriesUpdateInputQueriesInner>
}
/**
 *
 * @export
 * @interface SavePexQueriesUpdateInputQueriesInner
 */
export interface SavePexQueriesUpdateInputQueriesInner {
  /**
   * The ID of the query.
   * @type {string}
   * @memberof SavePexQueriesUpdateInputQueriesInner
   */
  queryId: string
  /**
   * The presentation definition describing the data requirement that must be satisfied by the user. The value is in a JSON stringify format.
   * @type {string}
   * @memberof SavePexQueriesUpdateInputQueriesInner
   */
  vpDefinition?: string
  /**
   * An optional description of what the query is used for.
   * @type {string}
   * @memberof SavePexQueriesUpdateInputQueriesInner
   */
  description?: string
}
/**
 *
 * @export
 * @interface UpdateConfigurationByIdInput
 */
export interface UpdateConfigurationByIdInput {
  /**
   * The name of the configuration to quickly identify the resource.
   * @type {string}
   * @memberof UpdateConfigurationByIdInput
   */
  name?: string
  /**
   * The unique resource identifier of the Wallet used to sign the request token.
   * @type {string}
   * @memberof UpdateConfigurationByIdInput
   */
  walletAri?: string
  /**
   * The webhook URL is used for callback when the data is ready.
   * @type {string}
   * @memberof UpdateConfigurationByIdInput
   */
  iotaResponseWebhookURL?: string
  /**
   * Cryptographically verifies the data shared by the user when enabled.
   * @type {boolean}
   * @memberof UpdateConfigurationByIdInput
   */
  enableVerification?: boolean
  /**
   * Records the user\'s consent when they share their data, including the type of data shared when enabled.
   * @type {boolean}
   * @memberof UpdateConfigurationByIdInput
   */
  enableConsentAuditLog?: boolean
  /**
   * This is the lifetime of the signed request token during the data-sharing flow.
   * @type {number}
   * @memberof UpdateConfigurationByIdInput
   */
  tokenMaxAge?: number
  /**
   * An optional description of what the configuration is used for.
   * @type {string}
   * @memberof UpdateConfigurationByIdInput
   */
  description?: string
  /**
   *
   * @type {IotaConfigurationDtoClientMetadata}
   * @memberof UpdateConfigurationByIdInput
   */
  clientMetadata?: IotaConfigurationDtoClientMetadata
  /**
   * Determines whether to handle the data-sharing request using the WebSocket, Redirect or Didcomm messaging flow.
   * @type {string}
   * @memberof UpdateConfigurationByIdInput
   */
  mode?: UpdateConfigurationByIdInputModeEnum
  /**
   * List of allowed URLs to redirect users, including the response from the request. This is required if the selected data-sharing mode is Redirect.
   * @type {Array<string>}
   * @memberof UpdateConfigurationByIdInput
   */
  redirectUris?: Array<string>
  /**
   * Enables identity verification from user with a 3rd-party provider when a verified identity document is not found.
   * @type {boolean}
   * @memberof UpdateConfigurationByIdInput
   */
  enableIdvProviders?: boolean
}

export const UpdateConfigurationByIdInputModeEnum = {
  Redirect: 'redirect',
  Websocket: 'websocket',
  Didcomm: 'didcomm',
} as const

export type UpdateConfigurationByIdInputModeEnum =
  (typeof UpdateConfigurationByIdInputModeEnum)[keyof typeof UpdateConfigurationByIdInputModeEnum]

/**
 *
 * @export
 * @interface UpdateConfigurationByIdOK
 */
export interface UpdateConfigurationByIdOK {
  /**
   *
   * @type {string}
   * @memberof UpdateConfigurationByIdOK
   */
  updateConfigurationByIdOk?: string
}
/**
 *
 * @export
 * @interface UpdateDcqlQueryInput
 */
export interface UpdateDcqlQueryInput {
  /**
   * The DCQL query describing the data requirement that must be satisfied by the user. The value is in a JSON stringify format.
   * @type {string}
   * @memberof UpdateDcqlQueryInput
   */
  dcqlQuery?: string
  /**
   * An optional description of what the query is used for.
   * @type {string}
   * @memberof UpdateDcqlQueryInput
   */
  description?: string
}
/**
 *
 * @export
 * @interface UpdatePexQueryInput
 */
export interface UpdatePexQueryInput {
  /**
   * The presentation definition describing the data requirement that must be satisfied by the user. The value is in a JSON stringify format.
   * @type {string}
   * @memberof UpdatePexQueryInput
   */
  vpDefinition?: string
  /**
   * An optional description of what the query is used for.
   * @type {string}
   * @memberof UpdatePexQueryInput
   */
  description?: string
}
/**
 *
 * @export
 * @interface VPTokenValidationError
 */
export interface VPTokenValidationError {
  /**
   *
   * @type {string}
   * @memberof VPTokenValidationError
   */
  name: VPTokenValidationErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof VPTokenValidationError
   */
  message: VPTokenValidationErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof VPTokenValidationError
   */
  httpStatusCode: VPTokenValidationErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof VPTokenValidationError
   */
  traceId: string
  /**
   *
   * @type {Array<InvalidParameterErrorDetailsInner>}
   * @memberof VPTokenValidationError
   */
  details?: Array<InvalidParameterErrorDetailsInner>
}

export const VPTokenValidationErrorNameEnum = {
  VpTokenValidationError: 'VPTokenValidationError',
} as const

export type VPTokenValidationErrorNameEnum =
  (typeof VPTokenValidationErrorNameEnum)[keyof typeof VPTokenValidationErrorNameEnum]
export const VPTokenValidationErrorMessageEnum = {
  VpTokenValidationEndedWithAnError: 'VP token validation ended with an error',
} as const

export type VPTokenValidationErrorMessageEnum =
  (typeof VPTokenValidationErrorMessageEnum)[keyof typeof VPTokenValidationErrorMessageEnum]
export const VPTokenValidationErrorHttpStatusCodeEnum = {
  NUMBER_400: 400,
} as const

export type VPTokenValidationErrorHttpStatusCodeEnum =
  (typeof VPTokenValidationErrorHttpStatusCodeEnum)[keyof typeof VPTokenValidationErrorHttpStatusCodeEnum]

/**
 * CallbackApi - axios parameter creator
 * @export
 */
export const CallbackApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * It handles the client\'s (e.g., Affinidi Vault) callback about the result of the data-sharing request. It may contain the data shared by the user, including the presentation submission, verification token, and state. Using the MQTT protocol, it communicates the completion of the request or if any error occurred.
     * @param {CallbackInput} callbackInput CallbackRequestInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iotOIDC4VPCallback: async (
      callbackInput: CallbackInput,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'callbackInput' is not null or undefined
      assertParamExists('iotOIDC4VPCallback', 'callbackInput', callbackInput)
      const localVarPath = `/v1/callback`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        callbackInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * CallbackApi - functional programming interface
 * @export
 */
export const CallbackApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = CallbackApiAxiosParamCreator(configuration)
  return {
    /**
     * It handles the client\'s (e.g., Affinidi Vault) callback about the result of the data-sharing request. It may contain the data shared by the user, including the presentation submission, verification token, and state. Using the MQTT protocol, it communicates the completion of the request or if any error occurred.
     * @param {CallbackInput} callbackInput CallbackRequestInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async iotOIDC4VPCallback(
      callbackInput: CallbackInput,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<CallbackResponseOK>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.iotOIDC4VPCallback(
          callbackInput,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['CallbackApi.iotOIDC4VPCallback']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * CallbackApi - factory interface
 * @export
 */
export const CallbackApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = CallbackApiFp(configuration)
  return {
    /**
     * It handles the client\'s (e.g., Affinidi Vault) callback about the result of the data-sharing request. It may contain the data shared by the user, including the presentation submission, verification token, and state. Using the MQTT protocol, it communicates the completion of the request or if any error occurred.
     * @param {CallbackInput} callbackInput CallbackRequestInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iotOIDC4VPCallback(
      callbackInput: CallbackInput,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<CallbackResponseOK> {
      return localVarFp
        .iotOIDC4VPCallback(callbackInput, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * CallbackApi - object-oriented interface
 * @export
 * @class CallbackApi
 * @extends {BaseAPI}
 */
export class CallbackApi extends BaseAPI {
  /**
   * It handles the client\'s (e.g., Affinidi Vault) callback about the result of the data-sharing request. It may contain the data shared by the user, including the presentation submission, verification token, and state. Using the MQTT protocol, it communicates the completion of the request or if any error occurred.
   * @param {CallbackInput} callbackInput CallbackRequestInput
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CallbackApi
   */
  public iotOIDC4VPCallback(
    callbackInput: CallbackInput,
    options?: RawAxiosRequestConfig,
  ) {
    return CallbackApiFp(this.configuration)
      .iotOIDC4VPCallback(callbackInput, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ConfigurationsApi - axios parameter creator
 * @export
 */
export const ConfigurationsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Creates a new Affinidi Iota Framework configuration.
     * @param {CreateIotaConfigurationInput} createIotaConfigurationInput CreateConfiguration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createIotaConfiguration: async (
      createIotaConfigurationInput: CreateIotaConfigurationInput,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createIotaConfigurationInput' is not null or undefined
      assertParamExists(
        'createIotaConfiguration',
        'createIotaConfigurationInput',
        createIotaConfigurationInput,
      )
      const localVarPath = `/v1/configurations`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        createIotaConfigurationInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Deletes an Affinidi Iota Framework configuration by ID.
     * @param {string} configurationId ID of the Affinidi Iota Framework configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteIotaConfigurationById: async (
      configurationId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'configurationId' is not null or undefined
      assertParamExists(
        'deleteIotaConfigurationById',
        'configurationId',
        configurationId,
      )
      const localVarPath = `/v1/configurations/{configurationId}`.replace(
        `{${'configurationId'}}`,
        encodeURIComponent(String(configurationId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieves the details of an Affinidi Iota Framework configuration.
     * @param {string} configurationId ID of the Affinidi Iota Framework configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIotaConfigurationById: async (
      configurationId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'configurationId' is not null or undefined
      assertParamExists(
        'getIotaConfigurationById',
        'configurationId',
        configurationId,
      )
      const localVarPath = `/v1/configurations/{configurationId}`.replace(
        `{${'configurationId'}}`,
        encodeURIComponent(String(configurationId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieves the client metadata of an Affinidi Iota Framework configuration.
     * @param {string} projectId The ID of the project.
     * @param {string} configurationId ID of the Affinidi Iota Framework configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIotaConfigurationMetaData: async (
      projectId: string,
      configurationId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists('getIotaConfigurationMetaData', 'projectId', projectId)
      // verify required parameter 'configurationId' is not null or undefined
      assertParamExists(
        'getIotaConfigurationMetaData',
        'configurationId',
        configurationId,
      )
      const localVarPath =
        `/v1/projects/{projectId}/configurations/{configurationId}/metadata`
          .replace(`{${'projectId'}}`, encodeURIComponent(String(projectId)))
          .replace(
            `{${'configurationId'}}`,
            encodeURIComponent(String(configurationId)),
          )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List all Affinidi Iota Framework configurations.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listIotaConfigurations: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/configurations`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Updates the details of an Affinidi Iota Framework configuration by ID.
     * @param {string} configurationId ID of the Affinidi Iota Framework configuration.
     * @param {UpdateConfigurationByIdInput} updateConfigurationByIdInput UpdateConfigurationById
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateIotaConfigurationById: async (
      configurationId: string,
      updateConfigurationByIdInput: UpdateConfigurationByIdInput,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'configurationId' is not null or undefined
      assertParamExists(
        'updateIotaConfigurationById',
        'configurationId',
        configurationId,
      )
      // verify required parameter 'updateConfigurationByIdInput' is not null or undefined
      assertParamExists(
        'updateIotaConfigurationById',
        'updateConfigurationByIdInput',
        updateConfigurationByIdInput,
      )
      const localVarPath = `/v1/configurations/{configurationId}`.replace(
        `{${'configurationId'}}`,
        encodeURIComponent(String(configurationId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateConfigurationByIdInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ConfigurationsApi - functional programming interface
 * @export
 */
export const ConfigurationsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ConfigurationsApiAxiosParamCreator(configuration)
  return {
    /**
     * Creates a new Affinidi Iota Framework configuration.
     * @param {CreateIotaConfigurationInput} createIotaConfigurationInput CreateConfiguration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createIotaConfiguration(
      createIotaConfigurationInput: CreateIotaConfigurationInput,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<IotaConfigurationDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createIotaConfiguration(
          createIotaConfigurationInput,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ConfigurationsApi.createIotaConfiguration']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Deletes an Affinidi Iota Framework configuration by ID.
     * @param {string} configurationId ID of the Affinidi Iota Framework configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteIotaConfigurationById(
      configurationId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteIotaConfigurationById(
          configurationId,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ConfigurationsApi.deleteIotaConfigurationById']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Retrieves the details of an Affinidi Iota Framework configuration.
     * @param {string} configurationId ID of the Affinidi Iota Framework configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getIotaConfigurationById(
      configurationId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<IotaConfigurationDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getIotaConfigurationById(
          configurationId,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ConfigurationsApi.getIotaConfigurationById']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Retrieves the client metadata of an Affinidi Iota Framework configuration.
     * @param {string} projectId The ID of the project.
     * @param {string} configurationId ID of the Affinidi Iota Framework configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getIotaConfigurationMetaData(
      projectId: string,
      configurationId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<GetIotaConfigurationMetaDataOK>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getIotaConfigurationMetaData(
          projectId,
          configurationId,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ConfigurationsApi.getIotaConfigurationMetaData']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * List all Affinidi Iota Framework configurations.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listIotaConfigurations(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ListConfigurationOK>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listIotaConfigurations(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ConfigurationsApi.listIotaConfigurations']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Updates the details of an Affinidi Iota Framework configuration by ID.
     * @param {string} configurationId ID of the Affinidi Iota Framework configuration.
     * @param {UpdateConfigurationByIdInput} updateConfigurationByIdInput UpdateConfigurationById
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateIotaConfigurationById(
      configurationId: string,
      updateConfigurationByIdInput: UpdateConfigurationByIdInput,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<IotaConfigurationDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateIotaConfigurationById(
          configurationId,
          updateConfigurationByIdInput,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ConfigurationsApi.updateIotaConfigurationById']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * ConfigurationsApi - factory interface
 * @export
 */
export const ConfigurationsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ConfigurationsApiFp(configuration)
  return {
    /**
     * Creates a new Affinidi Iota Framework configuration.
     * @param {CreateIotaConfigurationInput} createIotaConfigurationInput CreateConfiguration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createIotaConfiguration(
      createIotaConfigurationInput: CreateIotaConfigurationInput,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<IotaConfigurationDto> {
      return localVarFp
        .createIotaConfiguration(createIotaConfigurationInput, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Deletes an Affinidi Iota Framework configuration by ID.
     * @param {string} configurationId ID of the Affinidi Iota Framework configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteIotaConfigurationById(
      configurationId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .deleteIotaConfigurationById(configurationId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieves the details of an Affinidi Iota Framework configuration.
     * @param {string} configurationId ID of the Affinidi Iota Framework configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIotaConfigurationById(
      configurationId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<IotaConfigurationDto> {
      return localVarFp
        .getIotaConfigurationById(configurationId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieves the client metadata of an Affinidi Iota Framework configuration.
     * @param {string} projectId The ID of the project.
     * @param {string} configurationId ID of the Affinidi Iota Framework configuration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIotaConfigurationMetaData(
      projectId: string,
      configurationId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GetIotaConfigurationMetaDataOK> {
      return localVarFp
        .getIotaConfigurationMetaData(projectId, configurationId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * List all Affinidi Iota Framework configurations.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listIotaConfigurations(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ListConfigurationOK> {
      return localVarFp
        .listIotaConfigurations(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Updates the details of an Affinidi Iota Framework configuration by ID.
     * @param {string} configurationId ID of the Affinidi Iota Framework configuration.
     * @param {UpdateConfigurationByIdInput} updateConfigurationByIdInput UpdateConfigurationById
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateIotaConfigurationById(
      configurationId: string,
      updateConfigurationByIdInput: UpdateConfigurationByIdInput,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<IotaConfigurationDto> {
      return localVarFp
        .updateIotaConfigurationById(
          configurationId,
          updateConfigurationByIdInput,
          options,
        )
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ConfigurationsApi - object-oriented interface
 * @export
 * @class ConfigurationsApi
 * @extends {BaseAPI}
 */
export class ConfigurationsApi extends BaseAPI {
  /**
   * Creates a new Affinidi Iota Framework configuration.
   * @param {CreateIotaConfigurationInput} createIotaConfigurationInput CreateConfiguration
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConfigurationsApi
   */
  public createIotaConfiguration(
    createIotaConfigurationInput: CreateIotaConfigurationInput,
    options?: RawAxiosRequestConfig,
  ) {
    return ConfigurationsApiFp(this.configuration)
      .createIotaConfiguration(createIotaConfigurationInput, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Deletes an Affinidi Iota Framework configuration by ID.
   * @param {string} configurationId ID of the Affinidi Iota Framework configuration.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConfigurationsApi
   */
  public deleteIotaConfigurationById(
    configurationId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ConfigurationsApiFp(this.configuration)
      .deleteIotaConfigurationById(configurationId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieves the details of an Affinidi Iota Framework configuration.
   * @param {string} configurationId ID of the Affinidi Iota Framework configuration.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConfigurationsApi
   */
  public getIotaConfigurationById(
    configurationId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ConfigurationsApiFp(this.configuration)
      .getIotaConfigurationById(configurationId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieves the client metadata of an Affinidi Iota Framework configuration.
   * @param {string} projectId The ID of the project.
   * @param {string} configurationId ID of the Affinidi Iota Framework configuration.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConfigurationsApi
   */
  public getIotaConfigurationMetaData(
    projectId: string,
    configurationId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ConfigurationsApiFp(this.configuration)
      .getIotaConfigurationMetaData(projectId, configurationId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List all Affinidi Iota Framework configurations.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConfigurationsApi
   */
  public listIotaConfigurations(options?: RawAxiosRequestConfig) {
    return ConfigurationsApiFp(this.configuration)
      .listIotaConfigurations(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Updates the details of an Affinidi Iota Framework configuration by ID.
   * @param {string} configurationId ID of the Affinidi Iota Framework configuration.
   * @param {UpdateConfigurationByIdInput} updateConfigurationByIdInput UpdateConfigurationById
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConfigurationsApi
   */
  public updateIotaConfigurationById(
    configurationId: string,
    updateConfigurationByIdInput: UpdateConfigurationByIdInput,
    options?: RawAxiosRequestConfig,
  ) {
    return ConfigurationsApiFp(this.configuration)
      .updateIotaConfigurationById(
        configurationId,
        updateConfigurationByIdInput,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Lists all the logged consents for a project.
     * @param {string} [configurationId]
     * @param {string} [userId]
     * @param {number} [limit] The maximum number of records to fetch from the list of logged consents.
     * @param {string} [exclusiveStartKey] The base64url encoded key of the first item that this operation will evaluate (it is not returned). Use the value that was returned in the previous operation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listLoggedConsents: async (
      configurationId?: string,
      userId?: string,
      limit?: number,
      exclusiveStartKey?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/logged-consents`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      if (configurationId !== undefined) {
        localVarQueryParameter['configurationId'] = configurationId
      }

      if (userId !== undefined) {
        localVarQueryParameter['userId'] = userId
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (exclusiveStartKey !== undefined) {
        localVarQueryParameter['exclusiveStartKey'] = exclusiveStartKey
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
  return {
    /**
     * Lists all the logged consents for a project.
     * @param {string} [configurationId]
     * @param {string} [userId]
     * @param {number} [limit] The maximum number of records to fetch from the list of logged consents.
     * @param {string} [exclusiveStartKey] The base64url encoded key of the first item that this operation will evaluate (it is not returned). Use the value that was returned in the previous operation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listLoggedConsents(
      configurationId?: string,
      userId?: string,
      limit?: number,
      exclusiveStartKey?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ListLoggedConsentsOK>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listLoggedConsents(
          configurationId,
          userId,
          limit,
          exclusiveStartKey,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.listLoggedConsents']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DefaultApiFp(configuration)
  return {
    /**
     * Lists all the logged consents for a project.
     * @param {string} [configurationId]
     * @param {string} [userId]
     * @param {number} [limit] The maximum number of records to fetch from the list of logged consents.
     * @param {string} [exclusiveStartKey] The base64url encoded key of the first item that this operation will evaluate (it is not returned). Use the value that was returned in the previous operation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listLoggedConsents(
      configurationId?: string,
      userId?: string,
      limit?: number,
      exclusiveStartKey?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ListLoggedConsentsOK> {
      return localVarFp
        .listLoggedConsents(
          configurationId,
          userId,
          limit,
          exclusiveStartKey,
          options,
        )
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
  /**
   * Lists all the logged consents for a project.
   * @param {string} [configurationId]
   * @param {string} [userId]
   * @param {number} [limit] The maximum number of records to fetch from the list of logged consents.
   * @param {string} [exclusiveStartKey] The base64url encoded key of the first item that this operation will evaluate (it is not returned). Use the value that was returned in the previous operation.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public listLoggedConsents(
    configurationId?: string,
    userId?: string,
    limit?: number,
    exclusiveStartKey?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return DefaultApiFp(this.configuration)
      .listLoggedConsents(
        configurationId,
        userId,
        limit,
        exclusiveStartKey,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * IotaApi - axios parameter creator
 * @export
 */
export const IotaApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Exchange a limited-scoped token into a Cognito credential to generate the identity credential. The identity credential initiates the secure WebSocket connection from the client. This method is used only in WebSocket data-sharing mode.
     * @param {AwsExchangeCredentials} awsExchangeCredentials AwsExchangeCredentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    awsExchangeCredentials: async (
      awsExchangeCredentials: AwsExchangeCredentials,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'awsExchangeCredentials' is not null or undefined
      assertParamExists(
        'awsExchangeCredentials',
        'awsExchangeCredentials',
        awsExchangeCredentials,
      )
      const localVarPath = `/v1/aws-exchange-credentials`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        awsExchangeCredentials,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Exchange a Project Scoped Token into an identity credential directly to initiate a secure WebSocket connection. This method is used only in WebSocket data-sharing mode.
     * @param {AwsExchangeCredentialsProjectToken} awsExchangeCredentialsProjectToken AwsExchangeCredentialsProjectToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    awsExchangeCredentialsProjectToken: async (
      awsExchangeCredentialsProjectToken: AwsExchangeCredentialsProjectToken,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'awsExchangeCredentialsProjectToken' is not null or undefined
      assertParamExists(
        'awsExchangeCredentialsProjectToken',
        'awsExchangeCredentialsProjectToken',
        awsExchangeCredentialsProjectToken,
      )
      const localVarPath = `/v1/aws-exchange-credentials/project-token`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        awsExchangeCredentialsProjectToken,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Fetches the client\'s callback that contains the user\'s shared data in a Verifiable Presentation format after a successful data-sharing flow.
     * @param {FetchIOTAVPResponseInput} fetchIOTAVPResponseInput FetchIOTAVPResponseInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchIotaVpResponse: async (
      fetchIOTAVPResponseInput: FetchIOTAVPResponseInput,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'fetchIOTAVPResponseInput' is not null or undefined
      assertParamExists(
        'fetchIotaVpResponse',
        'fetchIOTAVPResponseInput',
        fetchIOTAVPResponseInput,
      )
      const localVarPath = `/v1/fetch-iota-response`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        fetchIOTAVPResponseInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Generates the request token for the Redirect mode to initiate the data-sharing flow.
     * @param {InitiateDataSharingRequestInput} initiateDataSharingRequestInput InitiateDataSharingRequestInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    initiateDataSharingRequest: async (
      initiateDataSharingRequestInput: InitiateDataSharingRequestInput,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'initiateDataSharingRequestInput' is not null or undefined
      assertParamExists(
        'initiateDataSharingRequest',
        'initiateDataSharingRequestInput',
        initiateDataSharingRequestInput,
      )
      const localVarPath = `/v1/initiate-data-sharing-request`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        initiateDataSharingRequestInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Exchange a limited-scoped token into an identity credential directly to initiate a secure WebSocket connection. This method is used only in WebSocket data-sharing mode.
     * @param {IotaExchangeCredentials} iotaExchangeCredentials IotaAwsExchangeCredentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iotaExchangeCredentials: async (
      iotaExchangeCredentials: IotaExchangeCredentials,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'iotaExchangeCredentials' is not null or undefined
      assertParamExists(
        'iotaExchangeCredentials',
        'iotaExchangeCredentials',
        iotaExchangeCredentials,
      )
      const localVarPath = `/v1/exchange-credentials`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        iotaExchangeCredentials,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * IotaApi - functional programming interface
 * @export
 */
export const IotaApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = IotaApiAxiosParamCreator(configuration)
  return {
    /**
     * Exchange a limited-scoped token into a Cognito credential to generate the identity credential. The identity credential initiates the secure WebSocket connection from the client. This method is used only in WebSocket data-sharing mode.
     * @param {AwsExchangeCredentials} awsExchangeCredentials AwsExchangeCredentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async awsExchangeCredentials(
      awsExchangeCredentials: AwsExchangeCredentials,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<AwsExchangeCredentialsOK>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.awsExchangeCredentials(
          awsExchangeCredentials,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['IotaApi.awsExchangeCredentials']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Exchange a Project Scoped Token into an identity credential directly to initiate a secure WebSocket connection. This method is used only in WebSocket data-sharing mode.
     * @param {AwsExchangeCredentialsProjectToken} awsExchangeCredentialsProjectToken AwsExchangeCredentialsProjectToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async awsExchangeCredentialsProjectToken(
      awsExchangeCredentialsProjectToken: AwsExchangeCredentialsProjectToken,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<IotaExchangeCredentialsOK>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.awsExchangeCredentialsProjectToken(
          awsExchangeCredentialsProjectToken,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['IotaApi.awsExchangeCredentialsProjectToken']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Fetches the client\'s callback that contains the user\'s shared data in a Verifiable Presentation format after a successful data-sharing flow.
     * @param {FetchIOTAVPResponseInput} fetchIOTAVPResponseInput FetchIOTAVPResponseInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async fetchIotaVpResponse(
      fetchIOTAVPResponseInput: FetchIOTAVPResponseInput,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<FetchIOTAVPResponseOK>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.fetchIotaVpResponse(
          fetchIOTAVPResponseInput,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['IotaApi.fetchIotaVpResponse']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Generates the request token for the Redirect mode to initiate the data-sharing flow.
     * @param {InitiateDataSharingRequestInput} initiateDataSharingRequestInput InitiateDataSharingRequestInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async initiateDataSharingRequest(
      initiateDataSharingRequestInput: InitiateDataSharingRequestInput,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<InitiateDataSharingRequestOK>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.initiateDataSharingRequest(
          initiateDataSharingRequestInput,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['IotaApi.initiateDataSharingRequest']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Exchange a limited-scoped token into an identity credential directly to initiate a secure WebSocket connection. This method is used only in WebSocket data-sharing mode.
     * @param {IotaExchangeCredentials} iotaExchangeCredentials IotaAwsExchangeCredentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async iotaExchangeCredentials(
      iotaExchangeCredentials: IotaExchangeCredentials,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<IotaExchangeCredentialsOK>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.iotaExchangeCredentials(
          iotaExchangeCredentials,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['IotaApi.iotaExchangeCredentials']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * IotaApi - factory interface
 * @export
 */
export const IotaApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = IotaApiFp(configuration)
  return {
    /**
     * Exchange a limited-scoped token into a Cognito credential to generate the identity credential. The identity credential initiates the secure WebSocket connection from the client. This method is used only in WebSocket data-sharing mode.
     * @param {AwsExchangeCredentials} awsExchangeCredentials AwsExchangeCredentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    awsExchangeCredentials(
      awsExchangeCredentials: AwsExchangeCredentials,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<AwsExchangeCredentialsOK> {
      return localVarFp
        .awsExchangeCredentials(awsExchangeCredentials, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Exchange a Project Scoped Token into an identity credential directly to initiate a secure WebSocket connection. This method is used only in WebSocket data-sharing mode.
     * @param {AwsExchangeCredentialsProjectToken} awsExchangeCredentialsProjectToken AwsExchangeCredentialsProjectToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    awsExchangeCredentialsProjectToken(
      awsExchangeCredentialsProjectToken: AwsExchangeCredentialsProjectToken,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<IotaExchangeCredentialsOK> {
      return localVarFp
        .awsExchangeCredentialsProjectToken(
          awsExchangeCredentialsProjectToken,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Fetches the client\'s callback that contains the user\'s shared data in a Verifiable Presentation format after a successful data-sharing flow.
     * @param {FetchIOTAVPResponseInput} fetchIOTAVPResponseInput FetchIOTAVPResponseInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchIotaVpResponse(
      fetchIOTAVPResponseInput: FetchIOTAVPResponseInput,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<FetchIOTAVPResponseOK> {
      return localVarFp
        .fetchIotaVpResponse(fetchIOTAVPResponseInput, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Generates the request token for the Redirect mode to initiate the data-sharing flow.
     * @param {InitiateDataSharingRequestInput} initiateDataSharingRequestInput InitiateDataSharingRequestInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    initiateDataSharingRequest(
      initiateDataSharingRequestInput: InitiateDataSharingRequestInput,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<InitiateDataSharingRequestOK> {
      return localVarFp
        .initiateDataSharingRequest(initiateDataSharingRequestInput, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Exchange a limited-scoped token into an identity credential directly to initiate a secure WebSocket connection. This method is used only in WebSocket data-sharing mode.
     * @param {IotaExchangeCredentials} iotaExchangeCredentials IotaAwsExchangeCredentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iotaExchangeCredentials(
      iotaExchangeCredentials: IotaExchangeCredentials,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<IotaExchangeCredentialsOK> {
      return localVarFp
        .iotaExchangeCredentials(iotaExchangeCredentials, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * IotaApi - object-oriented interface
 * @export
 * @class IotaApi
 * @extends {BaseAPI}
 */
export class IotaApi extends BaseAPI {
  /**
   * Exchange a limited-scoped token into a Cognito credential to generate the identity credential. The identity credential initiates the secure WebSocket connection from the client. This method is used only in WebSocket data-sharing mode.
   * @param {AwsExchangeCredentials} awsExchangeCredentials AwsExchangeCredentials
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IotaApi
   */
  public awsExchangeCredentials(
    awsExchangeCredentials: AwsExchangeCredentials,
    options?: RawAxiosRequestConfig,
  ) {
    return IotaApiFp(this.configuration)
      .awsExchangeCredentials(awsExchangeCredentials, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Exchange a Project Scoped Token into an identity credential directly to initiate a secure WebSocket connection. This method is used only in WebSocket data-sharing mode.
   * @param {AwsExchangeCredentialsProjectToken} awsExchangeCredentialsProjectToken AwsExchangeCredentialsProjectToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IotaApi
   */
  public awsExchangeCredentialsProjectToken(
    awsExchangeCredentialsProjectToken: AwsExchangeCredentialsProjectToken,
    options?: RawAxiosRequestConfig,
  ) {
    return IotaApiFp(this.configuration)
      .awsExchangeCredentialsProjectToken(
        awsExchangeCredentialsProjectToken,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Fetches the client\'s callback that contains the user\'s shared data in a Verifiable Presentation format after a successful data-sharing flow.
   * @param {FetchIOTAVPResponseInput} fetchIOTAVPResponseInput FetchIOTAVPResponseInput
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IotaApi
   */
  public fetchIotaVpResponse(
    fetchIOTAVPResponseInput: FetchIOTAVPResponseInput,
    options?: RawAxiosRequestConfig,
  ) {
    return IotaApiFp(this.configuration)
      .fetchIotaVpResponse(fetchIOTAVPResponseInput, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Generates the request token for the Redirect mode to initiate the data-sharing flow.
   * @param {InitiateDataSharingRequestInput} initiateDataSharingRequestInput InitiateDataSharingRequestInput
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IotaApi
   */
  public initiateDataSharingRequest(
    initiateDataSharingRequestInput: InitiateDataSharingRequestInput,
    options?: RawAxiosRequestConfig,
  ) {
    return IotaApiFp(this.configuration)
      .initiateDataSharingRequest(initiateDataSharingRequestInput, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Exchange a limited-scoped token into an identity credential directly to initiate a secure WebSocket connection. This method is used only in WebSocket data-sharing mode.
   * @param {IotaExchangeCredentials} iotaExchangeCredentials IotaAwsExchangeCredentials
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IotaApi
   */
  public iotaExchangeCredentials(
    iotaExchangeCredentials: IotaExchangeCredentials,
    options?: RawAxiosRequestConfig,
  ) {
    return IotaApiFp(this.configuration)
      .iotaExchangeCredentials(iotaExchangeCredentials, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * PexQueryApi - axios parameter creator
 * @export
 */
export const PexQueryApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Creates a new Presentation Definition in the configuration to query data.
     * @param {string} configurationId ID of the Affinidi Iota Framework configuration.
     * @param {CreatePexQueryInput} createPexQueryInput CreatePexQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPexQuery: async (
      configurationId: string,
      createPexQueryInput: CreatePexQueryInput,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'configurationId' is not null or undefined
      assertParamExists('createPexQuery', 'configurationId', configurationId)
      // verify required parameter 'createPexQueryInput' is not null or undefined
      assertParamExists(
        'createPexQuery',
        'createPexQueryInput',
        createPexQueryInput,
      )
      const localVarPath =
        `/v1/configurations/{configurationId}/pex-queries`.replace(
          `{${'configurationId'}}`,
          encodeURIComponent(String(configurationId)),
        )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        createPexQueryInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Deletes all Presentation Definition queries of a configuration.
     * @param {string} configurationId ID of the Affinidi Iota Framework configuration.
     * @param {DeletePexQueriesInput} deletePexQueriesInput DeletePexQueriesInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePexQueries: async (
      configurationId: string,
      deletePexQueriesInput: DeletePexQueriesInput,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'configurationId' is not null or undefined
      assertParamExists('deletePexQueries', 'configurationId', configurationId)
      // verify required parameter 'deletePexQueriesInput' is not null or undefined
      assertParamExists(
        'deletePexQueries',
        'deletePexQueriesInput',
        deletePexQueriesInput,
      )
      const localVarPath =
        `/v1/configurations/{configurationId}/delete-queries`.replace(
          `{${'configurationId'}}`,
          encodeURIComponent(String(configurationId)),
        )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        deletePexQueriesInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Deletes a Presentation Definition in the configuration by ID.
     * @param {string} configurationId ID of the Affinidi Iota Framework configuration.
     * @param {string} queryId The ID of the query.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePexQueryById: async (
      configurationId: string,
      queryId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'configurationId' is not null or undefined
      assertParamExists(
        'deletePexQueryById',
        'configurationId',
        configurationId,
      )
      // verify required parameter 'queryId' is not null or undefined
      assertParamExists('deletePexQueryById', 'queryId', queryId)
      const localVarPath =
        `/v1/configurations/{configurationId}/pex-queries/{queryId}`
          .replace(
            `{${'configurationId'}}`,
            encodeURIComponent(String(configurationId)),
          )
          .replace(`{${'queryId'}}`, encodeURIComponent(String(queryId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieves a Presentation Definition in the configuration by ID.
     * @param {string} configurationId ID of the Affinidi Iota Framework configuration.
     * @param {string} queryId The ID of the query.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPexQueryById: async (
      configurationId: string,
      queryId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'configurationId' is not null or undefined
      assertParamExists('getPexQueryById', 'configurationId', configurationId)
      // verify required parameter 'queryId' is not null or undefined
      assertParamExists('getPexQueryById', 'queryId', queryId)
      const localVarPath =
        `/v1/configurations/{configurationId}/pex-queries/{queryId}`
          .replace(
            `{${'configurationId'}}`,
            encodeURIComponent(String(configurationId)),
          )
          .replace(`{${'queryId'}}`, encodeURIComponent(String(queryId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Lists all Presentation Definitions in the configuration.
     * @param {string} configurationId ID of the Affinidi Iota Framework configuration.
     * @param {number} [limit] Maximum number of records to fetch in a list
     * @param {string} [exclusiveStartKey] The base64url encoded key of the first item that this operation will evaluate (it is not returned). Use the value that was returned in the previous operation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPexQueries: async (
      configurationId: string,
      limit?: number,
      exclusiveStartKey?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'configurationId' is not null or undefined
      assertParamExists('listPexQueries', 'configurationId', configurationId)
      const localVarPath =
        `/v1/configurations/{configurationId}/pex-queries`.replace(
          `{${'configurationId'}}`,
          encodeURIComponent(String(configurationId)),
        )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (exclusiveStartKey !== undefined) {
        localVarQueryParameter['exclusiveStartKey'] = exclusiveStartKey
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Saves all Presentation Definition queries of a configuration.
     * @param {string} configurationId ID of the Affinidi Iota Framework configuration.
     * @param {SavePexQueriesUpdateInput} savePexQueriesUpdateInput SavePexQueriesInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    savePexQueries: async (
      configurationId: string,
      savePexQueriesUpdateInput: SavePexQueriesUpdateInput,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'configurationId' is not null or undefined
      assertParamExists('savePexQueries', 'configurationId', configurationId)
      // verify required parameter 'savePexQueriesUpdateInput' is not null or undefined
      assertParamExists(
        'savePexQueries',
        'savePexQueriesUpdateInput',
        savePexQueriesUpdateInput,
      )
      const localVarPath =
        `/v1/configurations/{configurationId}/save-queries`.replace(
          `{${'configurationId'}}`,
          encodeURIComponent(String(configurationId)),
        )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        savePexQueriesUpdateInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Updates the Presentation Definition in the configuration by ID.
     * @param {string} configurationId ID of the Affinidi Iota Framework configuration.
     * @param {string} queryId The ID of the query.
     * @param {UpdatePexQueryInput} updatePexQueryInput UpdatePexQueryById
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePexQueryById: async (
      configurationId: string,
      queryId: string,
      updatePexQueryInput: UpdatePexQueryInput,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'configurationId' is not null or undefined
      assertParamExists(
        'updatePexQueryById',
        'configurationId',
        configurationId,
      )
      // verify required parameter 'queryId' is not null or undefined
      assertParamExists('updatePexQueryById', 'queryId', queryId)
      // verify required parameter 'updatePexQueryInput' is not null or undefined
      assertParamExists(
        'updatePexQueryById',
        'updatePexQueryInput',
        updatePexQueryInput,
      )
      const localVarPath =
        `/v1/configurations/{configurationId}/pex-queries/{queryId}`
          .replace(
            `{${'configurationId'}}`,
            encodeURIComponent(String(configurationId)),
          )
          .replace(`{${'queryId'}}`, encodeURIComponent(String(queryId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        updatePexQueryInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * PexQueryApi - functional programming interface
 * @export
 */
export const PexQueryApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PexQueryApiAxiosParamCreator(configuration)
  return {
    /**
     * Creates a new Presentation Definition in the configuration to query data.
     * @param {string} configurationId ID of the Affinidi Iota Framework configuration.
     * @param {CreatePexQueryInput} createPexQueryInput CreatePexQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPexQuery(
      configurationId: string,
      createPexQueryInput: CreatePexQueryInput,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PexQueryDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createPexQuery(
        configurationId,
        createPexQueryInput,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['PexQueryApi.createPexQuery']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Deletes all Presentation Definition queries of a configuration.
     * @param {string} configurationId ID of the Affinidi Iota Framework configuration.
     * @param {DeletePexQueriesInput} deletePexQueriesInput DeletePexQueriesInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletePexQueries(
      configurationId: string,
      deletePexQueriesInput: DeletePexQueriesInput,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deletePexQueries(
          configurationId,
          deletePexQueriesInput,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['PexQueryApi.deletePexQueries']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Deletes a Presentation Definition in the configuration by ID.
     * @param {string} configurationId ID of the Affinidi Iota Framework configuration.
     * @param {string} queryId The ID of the query.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletePexQueryById(
      configurationId: string,
      queryId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deletePexQueryById(
          configurationId,
          queryId,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['PexQueryApi.deletePexQueryById']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Retrieves a Presentation Definition in the configuration by ID.
     * @param {string} configurationId ID of the Affinidi Iota Framework configuration.
     * @param {string} queryId The ID of the query.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPexQueryById(
      configurationId: string,
      queryId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PexQueryDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPexQueryById(
        configurationId,
        queryId,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['PexQueryApi.getPexQueryById']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Lists all Presentation Definitions in the configuration.
     * @param {string} configurationId ID of the Affinidi Iota Framework configuration.
     * @param {number} [limit] Maximum number of records to fetch in a list
     * @param {string} [exclusiveStartKey] The base64url encoded key of the first item that this operation will evaluate (it is not returned). Use the value that was returned in the previous operation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listPexQueries(
      configurationId: string,
      limit?: number,
      exclusiveStartKey?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ListPexQueriesOK>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listPexQueries(
        configurationId,
        limit,
        exclusiveStartKey,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['PexQueryApi.listPexQueries']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Saves all Presentation Definition queries of a configuration.
     * @param {string} configurationId ID of the Affinidi Iota Framework configuration.
     * @param {SavePexQueriesUpdateInput} savePexQueriesUpdateInput SavePexQueriesInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async savePexQueries(
      configurationId: string,
      savePexQueriesUpdateInput: SavePexQueriesUpdateInput,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.savePexQueries(
        configurationId,
        savePexQueriesUpdateInput,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['PexQueryApi.savePexQueries']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Updates the Presentation Definition in the configuration by ID.
     * @param {string} configurationId ID of the Affinidi Iota Framework configuration.
     * @param {string} queryId The ID of the query.
     * @param {UpdatePexQueryInput} updatePexQueryInput UpdatePexQueryById
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatePexQueryById(
      configurationId: string,
      queryId: string,
      updatePexQueryInput: UpdatePexQueryInput,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PexQueryDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updatePexQueryById(
          configurationId,
          queryId,
          updatePexQueryInput,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['PexQueryApi.updatePexQueryById']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * PexQueryApi - factory interface
 * @export
 */
export const PexQueryApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = PexQueryApiFp(configuration)
  return {
    /**
     * Creates a new Presentation Definition in the configuration to query data.
     * @param {string} configurationId ID of the Affinidi Iota Framework configuration.
     * @param {CreatePexQueryInput} createPexQueryInput CreatePexQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPexQuery(
      configurationId: string,
      createPexQueryInput: CreatePexQueryInput,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<PexQueryDto> {
      return localVarFp
        .createPexQuery(configurationId, createPexQueryInput, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Deletes all Presentation Definition queries of a configuration.
     * @param {string} configurationId ID of the Affinidi Iota Framework configuration.
     * @param {DeletePexQueriesInput} deletePexQueriesInput DeletePexQueriesInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePexQueries(
      configurationId: string,
      deletePexQueriesInput: DeletePexQueriesInput,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<object> {
      return localVarFp
        .deletePexQueries(configurationId, deletePexQueriesInput, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Deletes a Presentation Definition in the configuration by ID.
     * @param {string} configurationId ID of the Affinidi Iota Framework configuration.
     * @param {string} queryId The ID of the query.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePexQueryById(
      configurationId: string,
      queryId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .deletePexQueryById(configurationId, queryId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieves a Presentation Definition in the configuration by ID.
     * @param {string} configurationId ID of the Affinidi Iota Framework configuration.
     * @param {string} queryId The ID of the query.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPexQueryById(
      configurationId: string,
      queryId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<PexQueryDto> {
      return localVarFp
        .getPexQueryById(configurationId, queryId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Lists all Presentation Definitions in the configuration.
     * @param {string} configurationId ID of the Affinidi Iota Framework configuration.
     * @param {number} [limit] Maximum number of records to fetch in a list
     * @param {string} [exclusiveStartKey] The base64url encoded key of the first item that this operation will evaluate (it is not returned). Use the value that was returned in the previous operation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPexQueries(
      configurationId: string,
      limit?: number,
      exclusiveStartKey?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ListPexQueriesOK> {
      return localVarFp
        .listPexQueries(configurationId, limit, exclusiveStartKey, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Saves all Presentation Definition queries of a configuration.
     * @param {string} configurationId ID of the Affinidi Iota Framework configuration.
     * @param {SavePexQueriesUpdateInput} savePexQueriesUpdateInput SavePexQueriesInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    savePexQueries(
      configurationId: string,
      savePexQueriesUpdateInput: SavePexQueriesUpdateInput,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<object> {
      return localVarFp
        .savePexQueries(configurationId, savePexQueriesUpdateInput, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Updates the Presentation Definition in the configuration by ID.
     * @param {string} configurationId ID of the Affinidi Iota Framework configuration.
     * @param {string} queryId The ID of the query.
     * @param {UpdatePexQueryInput} updatePexQueryInput UpdatePexQueryById
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePexQueryById(
      configurationId: string,
      queryId: string,
      updatePexQueryInput: UpdatePexQueryInput,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<PexQueryDto> {
      return localVarFp
        .updatePexQueryById(
          configurationId,
          queryId,
          updatePexQueryInput,
          options,
        )
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * PexQueryApi - object-oriented interface
 * @export
 * @class PexQueryApi
 * @extends {BaseAPI}
 */
export class PexQueryApi extends BaseAPI {
  /**
   * Creates a new Presentation Definition in the configuration to query data.
   * @param {string} configurationId ID of the Affinidi Iota Framework configuration.
   * @param {CreatePexQueryInput} createPexQueryInput CreatePexQuery
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PexQueryApi
   */
  public createPexQuery(
    configurationId: string,
    createPexQueryInput: CreatePexQueryInput,
    options?: RawAxiosRequestConfig,
  ) {
    return PexQueryApiFp(this.configuration)
      .createPexQuery(configurationId, createPexQueryInput, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Deletes all Presentation Definition queries of a configuration.
   * @param {string} configurationId ID of the Affinidi Iota Framework configuration.
   * @param {DeletePexQueriesInput} deletePexQueriesInput DeletePexQueriesInput
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PexQueryApi
   */
  public deletePexQueries(
    configurationId: string,
    deletePexQueriesInput: DeletePexQueriesInput,
    options?: RawAxiosRequestConfig,
  ) {
    return PexQueryApiFp(this.configuration)
      .deletePexQueries(configurationId, deletePexQueriesInput, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Deletes a Presentation Definition in the configuration by ID.
   * @param {string} configurationId ID of the Affinidi Iota Framework configuration.
   * @param {string} queryId The ID of the query.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PexQueryApi
   */
  public deletePexQueryById(
    configurationId: string,
    queryId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return PexQueryApiFp(this.configuration)
      .deletePexQueryById(configurationId, queryId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieves a Presentation Definition in the configuration by ID.
   * @param {string} configurationId ID of the Affinidi Iota Framework configuration.
   * @param {string} queryId The ID of the query.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PexQueryApi
   */
  public getPexQueryById(
    configurationId: string,
    queryId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return PexQueryApiFp(this.configuration)
      .getPexQueryById(configurationId, queryId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Lists all Presentation Definitions in the configuration.
   * @param {string} configurationId ID of the Affinidi Iota Framework configuration.
   * @param {number} [limit] Maximum number of records to fetch in a list
   * @param {string} [exclusiveStartKey] The base64url encoded key of the first item that this operation will evaluate (it is not returned). Use the value that was returned in the previous operation.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PexQueryApi
   */
  public listPexQueries(
    configurationId: string,
    limit?: number,
    exclusiveStartKey?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return PexQueryApiFp(this.configuration)
      .listPexQueries(configurationId, limit, exclusiveStartKey, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Saves all Presentation Definition queries of a configuration.
   * @param {string} configurationId ID of the Affinidi Iota Framework configuration.
   * @param {SavePexQueriesUpdateInput} savePexQueriesUpdateInput SavePexQueriesInput
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PexQueryApi
   */
  public savePexQueries(
    configurationId: string,
    savePexQueriesUpdateInput: SavePexQueriesUpdateInput,
    options?: RawAxiosRequestConfig,
  ) {
    return PexQueryApiFp(this.configuration)
      .savePexQueries(configurationId, savePexQueriesUpdateInput, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Updates the Presentation Definition in the configuration by ID.
   * @param {string} configurationId ID of the Affinidi Iota Framework configuration.
   * @param {string} queryId The ID of the query.
   * @param {UpdatePexQueryInput} updatePexQueryInput UpdatePexQueryById
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PexQueryApi
   */
  public updatePexQueryById(
    configurationId: string,
    queryId: string,
    updatePexQueryInput: UpdatePexQueryInput,
    options?: RawAxiosRequestConfig,
  ) {
    return PexQueryApiFp(this.configuration)
      .updatePexQueryById(
        configurationId,
        queryId,
        updatePexQueryInput,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }
}
