/* tslint:disable */
/* eslint-disable */
/**
 * CloudWalletEssentials
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: info@affinidi.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration'
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios'
import globalAxios from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common'
import type { RequestArgs } from './base'
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  BaseAPI,
  RequiredError,
  operationServerMap,
} from './base'

/**
 * @type CreateWalletInput
 * @export
 */
export type CreateWalletInput = DidKeyInputParams | DidWebInputParams

/**
 * wallet dto
 * @export
 * @interface CreateWalletResponse
 */
export interface CreateWalletResponse {
  /**
   *
   * @type {WalletDto}
   * @memberof CreateWalletResponse
   */
  wallet?: WalletDto
}
/**
 * Did key input params
 * @export
 * @interface DidKeyInputParams
 */
export interface DidKeyInputParams {
  /**
   * The name of the wallet
   * @type {string}
   * @memberof DidKeyInputParams
   */
  name?: string
  /**
   * The description of the wallet
   * @type {string}
   * @memberof DidKeyInputParams
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof DidKeyInputParams
   */
  didMethod?: DidKeyInputParamsDidMethodEnum
}

export const DidKeyInputParamsDidMethodEnum = {
  Key: 'key',
} as const

export type DidKeyInputParamsDidMethodEnum =
  (typeof DidKeyInputParamsDidMethodEnum)[keyof typeof DidKeyInputParamsDidMethodEnum]

/**
 * Additional params for did method web
 * @export
 * @interface DidWebInputParams
 */
export interface DidWebInputParams {
  /**
   * The name of the wallet
   * @type {string}
   * @memberof DidWebInputParams
   */
  name?: string
  /**
   * The description of the wallet
   * @type {string}
   * @memberof DidWebInputParams
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof DidWebInputParams
   */
  didMethod: DidWebInputParamsDidMethodEnum
  /**
   * If the did method is web, this is the URL of the did
   * @type {string}
   * @memberof DidWebInputParams
   */
  didWebUrl: string
}

export const DidWebInputParamsDidMethodEnum = {
  Web: 'web',
} as const

export type DidWebInputParamsDidMethodEnum =
  (typeof DidWebInputParamsDidMethodEnum)[keyof typeof DidWebInputParamsDidMethodEnum]

/**
 *
 * @export
 * @interface EntityNotFoundError
 */
export interface EntityNotFoundError {
  /**
   *
   * @type {string}
   * @memberof EntityNotFoundError
   */
  name: EntityNotFoundErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof EntityNotFoundError
   */
  message: EntityNotFoundErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof EntityNotFoundError
   */
  httpStatusCode: EntityNotFoundErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof EntityNotFoundError
   */
  traceId: string
  /**
   *
   * @type {Array<ServiceErrorResponseDetailsInner>}
   * @memberof EntityNotFoundError
   */
  details?: Array<ServiceErrorResponseDetailsInner>
}

export const EntityNotFoundErrorNameEnum = {
  EntityNotFoundError: 'EntityNotFoundError',
} as const

export type EntityNotFoundErrorNameEnum =
  (typeof EntityNotFoundErrorNameEnum)[keyof typeof EntityNotFoundErrorNameEnum]
export const EntityNotFoundErrorMessageEnum = {
  EntityNotFound: 'Entity not found',
} as const

export type EntityNotFoundErrorMessageEnum =
  (typeof EntityNotFoundErrorMessageEnum)[keyof typeof EntityNotFoundErrorMessageEnum]
export const EntityNotFoundErrorHttpStatusCodeEnum = {
  NUMBER_404: 404,
} as const

export type EntityNotFoundErrorHttpStatusCodeEnum =
  (typeof EntityNotFoundErrorHttpStatusCodeEnum)[keyof typeof EntityNotFoundErrorHttpStatusCodeEnum]

/**
 * DTO contains revocation list credential
 * @export
 * @interface GetRevocationCredentialStatusOK
 */
export interface GetRevocationCredentialStatusOK {
  /**
   *
   * @type {object}
   * @memberof GetRevocationCredentialStatusOK
   */
  revocationListCredential: object
}
/**
 * DTO contains revocation list credential
 * @export
 * @interface GetRevocationListCredentialResultDto
 */
export interface GetRevocationListCredentialResultDto {
  /**
   *
   * @type {object}
   * @memberof GetRevocationListCredentialResultDto
   */
  revocationListCredential: object
}
/**
 *
 * @export
 * @interface InvalidDidParameterError
 */
export interface InvalidDidParameterError {
  /**
   *
   * @type {string}
   * @memberof InvalidDidParameterError
   */
  name: InvalidDidParameterErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof InvalidDidParameterError
   */
  message: InvalidDidParameterErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof InvalidDidParameterError
   */
  httpStatusCode: InvalidDidParameterErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof InvalidDidParameterError
   */
  traceId: string
  /**
   *
   * @type {Array<ServiceErrorResponseDetailsInner>}
   * @memberof InvalidDidParameterError
   */
  details?: Array<ServiceErrorResponseDetailsInner>
}

export const InvalidDidParameterErrorNameEnum = {
  InvalidDidParameterError: 'InvalidDidParameterError',
} as const

export type InvalidDidParameterErrorNameEnum =
  (typeof InvalidDidParameterErrorNameEnum)[keyof typeof InvalidDidParameterErrorNameEnum]
export const InvalidDidParameterErrorMessageEnum = {
  GivenDidInFieldToDidIsInvalidUseOnlyResolvableFormOfDid:
    'Given did in field toDid is invalid. Use only resolvable form of did.',
} as const

export type InvalidDidParameterErrorMessageEnum =
  (typeof InvalidDidParameterErrorMessageEnum)[keyof typeof InvalidDidParameterErrorMessageEnum]
export const InvalidDidParameterErrorHttpStatusCodeEnum = {
  NUMBER_400: 400,
} as const

export type InvalidDidParameterErrorHttpStatusCodeEnum =
  (typeof InvalidDidParameterErrorHttpStatusCodeEnum)[keyof typeof InvalidDidParameterErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface InvalidParameterError
 */
export interface InvalidParameterError {
  /**
   *
   * @type {string}
   * @memberof InvalidParameterError
   */
  name: InvalidParameterErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof InvalidParameterError
   */
  message: InvalidParameterErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof InvalidParameterError
   */
  httpStatusCode: InvalidParameterErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof InvalidParameterError
   */
  traceId: string
  /**
   *
   * @type {Array<ServiceErrorResponseDetailsInner>}
   * @memberof InvalidParameterError
   */
  details?: Array<ServiceErrorResponseDetailsInner>
}

export const InvalidParameterErrorNameEnum = {
  InvalidParameterError: 'InvalidParameterError',
} as const

export type InvalidParameterErrorNameEnum =
  (typeof InvalidParameterErrorNameEnum)[keyof typeof InvalidParameterErrorNameEnum]
export const InvalidParameterErrorMessageEnum = {
  InvalidParameterParam: 'Invalid parameter: ${param}.',
} as const

export type InvalidParameterErrorMessageEnum =
  (typeof InvalidParameterErrorMessageEnum)[keyof typeof InvalidParameterErrorMessageEnum]
export const InvalidParameterErrorHttpStatusCodeEnum = {
  NUMBER_400: 400,
} as const

export type InvalidParameterErrorHttpStatusCodeEnum =
  (typeof InvalidParameterErrorHttpStatusCodeEnum)[keyof typeof InvalidParameterErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface KeyNotFoundError
 */
export interface KeyNotFoundError {
  /**
   *
   * @type {string}
   * @memberof KeyNotFoundError
   */
  name: KeyNotFoundErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof KeyNotFoundError
   */
  message: KeyNotFoundErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof KeyNotFoundError
   */
  httpStatusCode: KeyNotFoundErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof KeyNotFoundError
   */
  traceId: string
  /**
   *
   * @type {Array<ServiceErrorResponseDetailsInner>}
   * @memberof KeyNotFoundError
   */
  details?: Array<ServiceErrorResponseDetailsInner>
}

export const KeyNotFoundErrorNameEnum = {
  KeyNotFoundError: 'KeyNotFoundError',
} as const

export type KeyNotFoundErrorNameEnum =
  (typeof KeyNotFoundErrorNameEnum)[keyof typeof KeyNotFoundErrorNameEnum]
export const KeyNotFoundErrorMessageEnum = {
  KeyNotFound: 'Key not found',
} as const

export type KeyNotFoundErrorMessageEnum =
  (typeof KeyNotFoundErrorMessageEnum)[keyof typeof KeyNotFoundErrorMessageEnum]
export const KeyNotFoundErrorHttpStatusCodeEnum = {
  NUMBER_500: 500,
} as const

export type KeyNotFoundErrorHttpStatusCodeEnum =
  (typeof KeyNotFoundErrorHttpStatusCodeEnum)[keyof typeof KeyNotFoundErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface NotFoundError
 */
export interface NotFoundError {
  /**
   *
   * @type {string}
   * @memberof NotFoundError
   */
  name: NotFoundErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof NotFoundError
   */
  message: NotFoundErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof NotFoundError
   */
  httpStatusCode: NotFoundErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof NotFoundError
   */
  traceId: string
  /**
   *
   * @type {Array<ServiceErrorResponseDetailsInner>}
   * @memberof NotFoundError
   */
  details?: Array<ServiceErrorResponseDetailsInner>
}

export const NotFoundErrorNameEnum = {
  NotFoundError: 'NotFoundError',
} as const

export type NotFoundErrorNameEnum =
  (typeof NotFoundErrorNameEnum)[keyof typeof NotFoundErrorNameEnum]
export const NotFoundErrorMessageEnum = {
  NotFoundParam: 'Not found: ${param}.',
} as const

export type NotFoundErrorMessageEnum =
  (typeof NotFoundErrorMessageEnum)[keyof typeof NotFoundErrorMessageEnum]
export const NotFoundErrorHttpStatusCodeEnum = {
  NUMBER_404: 404,
} as const

export type NotFoundErrorHttpStatusCodeEnum =
  (typeof NotFoundErrorHttpStatusCodeEnum)[keyof typeof NotFoundErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface OperationForbiddenError
 */
export interface OperationForbiddenError {
  /**
   *
   * @type {string}
   * @memberof OperationForbiddenError
   */
  name: OperationForbiddenErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof OperationForbiddenError
   */
  message: OperationForbiddenErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof OperationForbiddenError
   */
  httpStatusCode: OperationForbiddenErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof OperationForbiddenError
   */
  traceId: string
  /**
   *
   * @type {Array<ServiceErrorResponseDetailsInner>}
   * @memberof OperationForbiddenError
   */
  details?: Array<ServiceErrorResponseDetailsInner>
}

export const OperationForbiddenErrorNameEnum = {
  OperationForbiddenError: 'OperationForbiddenError',
} as const

export type OperationForbiddenErrorNameEnum =
  (typeof OperationForbiddenErrorNameEnum)[keyof typeof OperationForbiddenErrorNameEnum]
export const OperationForbiddenErrorMessageEnum = {
  OperationForbiddenParam: 'Operation forbidden: ${param}.',
} as const

export type OperationForbiddenErrorMessageEnum =
  (typeof OperationForbiddenErrorMessageEnum)[keyof typeof OperationForbiddenErrorMessageEnum]
export const OperationForbiddenErrorHttpStatusCodeEnum = {
  NUMBER_403: 403,
} as const

export type OperationForbiddenErrorHttpStatusCodeEnum =
  (typeof OperationForbiddenErrorHttpStatusCodeEnum)[keyof typeof OperationForbiddenErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface RevokeCredentialInput
 */
export interface RevokeCredentialInput {
  /**
   *
   * @type {string}
   * @memberof RevokeCredentialInput
   */
  revocationReason?: string | null
  /**
   *
   * @type {string}
   * @memberof RevokeCredentialInput
   */
  credentialId?: string
}
/**
 *
 * @export
 * @interface ServiceErrorResponse
 */
export interface ServiceErrorResponse {
  /**
   * unique id for correlating this specific error to logs
   * @type {string}
   * @memberof ServiceErrorResponse
   */
  debugId: string
  /**
   * name of the error
   * @type {string}
   * @memberof ServiceErrorResponse
   */
  name: string
  /**
   * backwards compatible Affinidi error code
   * @type {string}
   * @memberof ServiceErrorResponse
   */
  code: string
  /**
   *
   * @type {Array<ServiceErrorResponseDetailsInner>}
   * @memberof ServiceErrorResponse
   */
  details?: Array<ServiceErrorResponseDetailsInner>
}
/**
 *
 * @export
 * @interface ServiceErrorResponseDetailsInner
 */
export interface ServiceErrorResponseDetailsInner {
  /**
   *
   * @type {string}
   * @memberof ServiceErrorResponseDetailsInner
   */
  issue: string
  /**
   *
   * @type {string}
   * @memberof ServiceErrorResponseDetailsInner
   */
  field?: string
  /**
   *
   * @type {string}
   * @memberof ServiceErrorResponseDetailsInner
   */
  value?: string
  /**
   *
   * @type {string}
   * @memberof ServiceErrorResponseDetailsInner
   */
  location?: string
}
/**
 * @type SignCredential400Response
 * @export
 */
export type SignCredential400Response =
  | InvalidParameterError
  | SigningFailedError

/**
 * DTO contains params to sign credential
 * @export
 * @interface SignCredentialInputDto
 */
export interface SignCredentialInputDto {
  /**
   * Unsigned Credential. If provided \"unsignedCredentialParams\" is not accepted
   * @type {object}
   * @memberof SignCredentialInputDto
   */
  unsignedCredential?: object
  /**
   *
   * @type {boolean}
   * @memberof SignCredentialInputDto
   */
  revocable?: boolean
  /**
   *
   * @type {string}
   * @memberof SignCredentialInputDto
   */
  credentialFormat?: SignCredentialInputDtoCredentialFormatEnum
  /**
   *
   * @type {SignCredentialInputDtoUnsignedCredentialParams}
   * @memberof SignCredentialInputDto
   */
  unsignedCredentialParams?: SignCredentialInputDtoUnsignedCredentialParams
}

export const SignCredentialInputDtoCredentialFormatEnum = {
  LdpVc: 'ldp_vc',
  JwtVcJsonLd: 'jwt_vc_json-ld',
  SdJwtVcJsonLd: 'sd_jwt_vc_json-ld',
} as const

export type SignCredentialInputDtoCredentialFormatEnum =
  (typeof SignCredentialInputDtoCredentialFormatEnum)[keyof typeof SignCredentialInputDtoCredentialFormatEnum]

/**
 * unsignedCredentialParams. Used to build an unsigned credential before the signing. This param is not accepted when \"unsignedCredential\" is given
 * @export
 * @interface SignCredentialInputDtoUnsignedCredentialParams
 */
export interface SignCredentialInputDtoUnsignedCredentialParams {
  /**
   *
   * @type {string}
   * @memberof SignCredentialInputDtoUnsignedCredentialParams
   */
  jsonLdContextUrl: string
  /**
   *
   * @type {string}
   * @memberof SignCredentialInputDtoUnsignedCredentialParams
   */
  jsonSchemaUrl: string
  /**
   *
   * @type {string}
   * @memberof SignCredentialInputDtoUnsignedCredentialParams
   */
  typeName: string
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof SignCredentialInputDtoUnsignedCredentialParams
   */
  credentialSubject: { [key: string]: any }
  /**
   *
   * @type {string}
   * @memberof SignCredentialInputDtoUnsignedCredentialParams
   */
  holderDid: string
  /**
   *
   * @type {string}
   * @memberof SignCredentialInputDtoUnsignedCredentialParams
   */
  expiresAt: string
}
/**
 * DTO contains signed credential
 * @export
 * @interface SignCredentialResultDto
 */
export interface SignCredentialResultDto {
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof SignCredentialResultDto
   */
  signedCredential: { [key: string]: any }
}
/**
 * DTO contains parts of JWT to be signed
 * @export
 * @interface SignJwtToken
 */
export interface SignJwtToken {
  /**
   *
   * @type {object}
   * @memberof SignJwtToken
   */
  header: object
  /**
   *
   * @type {object}
   * @memberof SignJwtToken
   */
  payload: object
}
/**
 *
 * @export
 * @interface SignJwtTokenOK
 */
export interface SignJwtTokenOK {
  /**
   *
   * @type {string}
   * @memberof SignJwtTokenOK
   */
  signedJwt?: string
}
/**
 *
 * @export
 * @interface SigningFailedError
 */
export interface SigningFailedError {
  /**
   *
   * @type {string}
   * @memberof SigningFailedError
   */
  name: SigningFailedErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof SigningFailedError
   */
  message: SigningFailedErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof SigningFailedError
   */
  httpStatusCode: SigningFailedErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof SigningFailedError
   */
  traceId: string
  /**
   *
   * @type {Array<ServiceErrorResponseDetailsInner>}
   * @memberof SigningFailedError
   */
  details?: Array<ServiceErrorResponseDetailsInner>
}

export const SigningFailedErrorNameEnum = {
  SigningFailedError: 'SigningFailedError',
} as const

export type SigningFailedErrorNameEnum =
  (typeof SigningFailedErrorNameEnum)[keyof typeof SigningFailedErrorNameEnum]
export const SigningFailedErrorMessageEnum = {
  SigningFailed: 'Signing failed.',
} as const

export type SigningFailedErrorMessageEnum =
  (typeof SigningFailedErrorMessageEnum)[keyof typeof SigningFailedErrorMessageEnum]
export const SigningFailedErrorHttpStatusCodeEnum = {
  NUMBER_400: 400,
} as const

export type SigningFailedErrorHttpStatusCodeEnum =
  (typeof SigningFailedErrorHttpStatusCodeEnum)[keyof typeof SigningFailedErrorHttpStatusCodeEnum]

/**
 * Update wallet input params
 * @export
 * @interface UpdateWalletInput
 */
export interface UpdateWalletInput {
  /**
   * The name of the wallet
   * @type {string}
   * @memberof UpdateWalletInput
   */
  name?: string
  /**
   * The description of the wallet
   * @type {string}
   * @memberof UpdateWalletInput
   */
  description?: string
}
/**
 * wallet dto
 * @export
 * @interface WalletDto
 */
export interface WalletDto {
  /**
   * id of the wallet in uuidV4 format
   * @type {string}
   * @memberof WalletDto
   */
  id?: string
  /**
   * did of the wallet
   * @type {string}
   * @memberof WalletDto
   */
  did?: string
  /**
   * The name of the wallet
   * @type {string}
   * @memberof WalletDto
   */
  name?: string
  /**
   * The description of the wallet
   * @type {string}
   * @memberof WalletDto
   */
  description?: string
  /**
   * did document of the wallet
   * @type {object}
   * @memberof WalletDto
   */
  didDocument?: object
  /**
   * ARI of the wallet
   * @type {string}
   * @memberof WalletDto
   */
  ari?: string
  /**
   *
   * @type {Array<WalletDtoKeysInner>}
   * @memberof WalletDto
   */
  keys?: Array<WalletDtoKeysInner>
  /**
   *
   * @type {string}
   * @memberof WalletDto
   */
  createdAt?: string
  /**
   *
   * @type {string}
   * @memberof WalletDto
   */
  modifiedAt?: string
}
/**
 *
 * @export
 * @interface WalletDtoKeysInner
 */
export interface WalletDtoKeysInner {
  /**
   * id of linked key
   * @type {string}
   * @memberof WalletDtoKeysInner
   */
  id?: string
  /**
   * ari of linked key
   * @type {string}
   * @memberof WalletDtoKeysInner
   */
  ari?: string
}
/**
 * list of wallets
 * @export
 * @interface WalletsListDto
 */
export interface WalletsListDto {
  /**
   *
   * @type {Array<WalletDto>}
   * @memberof WalletsListDto
   */
  wallets?: Array<WalletDto>
}

/**
 * RevocationApi - axios parameter creator
 * @export
 */
export const RevocationApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Get revocation status list as RevocationListCredential
     * @param {string} projectId Description for projectId.
     * @param {string} walletId Description for walletId.
     * @param {string} statusId Description for statusId.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRevocationCredentialStatus: async (
      projectId: string,
      walletId: string,
      statusId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists('getRevocationCredentialStatus', 'projectId', projectId)
      // verify required parameter 'walletId' is not null or undefined
      assertParamExists('getRevocationCredentialStatus', 'walletId', walletId)
      // verify required parameter 'statusId' is not null or undefined
      assertParamExists('getRevocationCredentialStatus', 'statusId', statusId)
      const localVarPath =
        `/v1/projects/{projectId}/wallets/{walletId}/revocation-statuses/{statusId}`
          .replace(`{${'projectId'}}`, encodeURIComponent(String(projectId)))
          .replace(`{${'walletId'}}`, encodeURIComponent(String(walletId)))
          .replace(`{${'statusId'}}`, encodeURIComponent(String(statusId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get revocation list 2020 Credential (required to check if VC revoked). It is a public endpoint.
     * @summary Return revocation list credential.
     * @param {string} listId
     * @param {string} walletId id of the wallet
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    getRevocationListCredential: async (
      listId: string,
      walletId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'listId' is not null or undefined
      assertParamExists('getRevocationListCredential', 'listId', listId)
      // verify required parameter 'walletId' is not null or undefined
      assertParamExists('getRevocationListCredential', 'walletId', walletId)
      const localVarPath = `/v1/wallets/{walletId}/revocation-list/{listId}`
        .replace(`{${'listId'}}`, encodeURIComponent(String(listId)))
        .replace(`{${'walletId'}}`, encodeURIComponent(String(walletId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update index/credetial at appropriate revocation list (set revoken is true).
     * @summary Revoke Credential.
     * @param {string} walletId id of the wallet
     * @param {RevokeCredentialInput} revokeCredentialInput RevokeCredential
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    revokeCredential: async (
      walletId: string,
      revokeCredentialInput: RevokeCredentialInput,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'walletId' is not null or undefined
      assertParamExists('revokeCredential', 'walletId', walletId)
      // verify required parameter 'revokeCredentialInput' is not null or undefined
      assertParamExists(
        'revokeCredential',
        'revokeCredentialInput',
        revokeCredentialInput,
      )
      const localVarPath = `/v1/wallets/{walletId}/revoke`.replace(
        `{${'walletId'}}`,
        encodeURIComponent(String(walletId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        revokeCredentialInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * RevocationApi - functional programming interface
 * @export
 */
export const RevocationApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    RevocationApiAxiosParamCreator(configuration)
  return {
    /**
     * Get revocation status list as RevocationListCredential
     * @param {string} projectId Description for projectId.
     * @param {string} walletId Description for walletId.
     * @param {string} statusId Description for statusId.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRevocationCredentialStatus(
      projectId: string,
      walletId: string,
      statusId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<GetRevocationListCredentialResultDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getRevocationCredentialStatus(
          projectId,
          walletId,
          statusId,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['RevocationApi.getRevocationCredentialStatus']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get revocation list 2020 Credential (required to check if VC revoked). It is a public endpoint.
     * @summary Return revocation list credential.
     * @param {string} listId
     * @param {string} walletId id of the wallet
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async getRevocationListCredential(
      listId: string,
      walletId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<GetRevocationListCredentialResultDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getRevocationListCredential(
          listId,
          walletId,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['RevocationApi.getRevocationListCredential']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Update index/credetial at appropriate revocation list (set revoken is true).
     * @summary Revoke Credential.
     * @param {string} walletId id of the wallet
     * @param {RevokeCredentialInput} revokeCredentialInput RevokeCredential
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async revokeCredential(
      walletId: string,
      revokeCredentialInput: RevokeCredentialInput,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.revokeCredential(
          walletId,
          revokeCredentialInput,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['RevocationApi.revokeCredential']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * RevocationApi - factory interface
 * @export
 */
export const RevocationApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = RevocationApiFp(configuration)
  return {
    /**
     * Get revocation status list as RevocationListCredential
     * @param {string} projectId Description for projectId.
     * @param {string} walletId Description for walletId.
     * @param {string} statusId Description for statusId.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRevocationCredentialStatus(
      projectId: string,
      walletId: string,
      statusId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GetRevocationListCredentialResultDto> {
      return localVarFp
        .getRevocationCredentialStatus(projectId, walletId, statusId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get revocation list 2020 Credential (required to check if VC revoked). It is a public endpoint.
     * @summary Return revocation list credential.
     * @param {string} listId
     * @param {string} walletId id of the wallet
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    getRevocationListCredential(
      listId: string,
      walletId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GetRevocationListCredentialResultDto> {
      return localVarFp
        .getRevocationListCredential(listId, walletId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update index/credetial at appropriate revocation list (set revoken is true).
     * @summary Revoke Credential.
     * @param {string} walletId id of the wallet
     * @param {RevokeCredentialInput} revokeCredentialInput RevokeCredential
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    revokeCredential(
      walletId: string,
      revokeCredentialInput: RevokeCredentialInput,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .revokeCredential(walletId, revokeCredentialInput, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * RevocationApi - object-oriented interface
 * @export
 * @class RevocationApi
 * @extends {BaseAPI}
 */
export class RevocationApi extends BaseAPI {
  /**
   * Get revocation status list as RevocationListCredential
   * @param {string} projectId Description for projectId.
   * @param {string} walletId Description for walletId.
   * @param {string} statusId Description for statusId.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RevocationApi
   */
  public getRevocationCredentialStatus(
    projectId: string,
    walletId: string,
    statusId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return RevocationApiFp(this.configuration)
      .getRevocationCredentialStatus(projectId, walletId, statusId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get revocation list 2020 Credential (required to check if VC revoked). It is a public endpoint.
   * @summary Return revocation list credential.
   * @param {string} listId
   * @param {string} walletId id of the wallet
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof RevocationApi
   */
  public getRevocationListCredential(
    listId: string,
    walletId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return RevocationApiFp(this.configuration)
      .getRevocationListCredential(listId, walletId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update index/credetial at appropriate revocation list (set revoken is true).
   * @summary Revoke Credential.
   * @param {string} walletId id of the wallet
   * @param {RevokeCredentialInput} revokeCredentialInput RevokeCredential
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RevocationApi
   */
  public revokeCredential(
    walletId: string,
    revokeCredentialInput: RevokeCredentialInput,
    options?: RawAxiosRequestConfig,
  ) {
    return RevocationApiFp(this.configuration)
      .revokeCredential(walletId, revokeCredentialInput, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * WalletApi - axios parameter creator
 * @export
 */
export const WalletApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * creates a wallet
     * @param {CreateWalletInput} [createWalletInput] CreateWallet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWallet: async (
      createWalletInput?: CreateWalletInput,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/wallets`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        createWalletInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * delete wallet by walletId
     * @param {string} walletId id of the wallet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWallet: async (
      walletId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'walletId' is not null or undefined
      assertParamExists('deleteWallet', 'walletId', walletId)
      const localVarPath = `/v1/wallets/{walletId}`.replace(
        `{${'walletId'}}`,
        encodeURIComponent(String(walletId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * get wallet details using wallet Id.
     * @param {string} walletId id of the wallet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWallet: async (
      walletId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'walletId' is not null or undefined
      assertParamExists('getWallet', 'walletId', walletId)
      const localVarPath = `/v1/wallets/{walletId}`.replace(
        `{${'walletId'}}`,
        encodeURIComponent(String(walletId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * lists all wallets
     * @param {ListWalletsDidTypeEnum} [didType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWallets: async (
      didType?: ListWalletsDidTypeEnum,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/wallets`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      if (didType !== undefined) {
        localVarQueryParameter['didType'] = didType
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * signs credential with the wallet
     * @param {string} walletId id of the wallet
     * @param {SignCredentialInputDto} signCredentialInputDto SignCredential
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signCredential: async (
      walletId: string,
      signCredentialInputDto: SignCredentialInputDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'walletId' is not null or undefined
      assertParamExists('signCredential', 'walletId', walletId)
      // verify required parameter 'signCredentialInputDto' is not null or undefined
      assertParamExists(
        'signCredential',
        'signCredentialInputDto',
        signCredentialInputDto,
      )
      const localVarPath = `/v1/wallets/{walletId}/sign-credential`.replace(
        `{${'walletId'}}`,
        encodeURIComponent(String(walletId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        signCredentialInputDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * signs a jwt token with the wallet
     * @param {string} walletId id of the wallet.
     * @param {SignJwtToken} signJwtToken SignJwtToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signJwtToken: async (
      walletId: string,
      signJwtToken: SignJwtToken,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'walletId' is not null or undefined
      assertParamExists('signJwtToken', 'walletId', walletId)
      // verify required parameter 'signJwtToken' is not null or undefined
      assertParamExists('signJwtToken', 'signJwtToken', signJwtToken)
      const localVarPath = `/v1/wallets/{walletId}/sign-jwt`.replace(
        `{${'walletId'}}`,
        encodeURIComponent(String(walletId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        signJwtToken,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * update wallet details using wallet Id.
     * @param {string} walletId id of the wallet
     * @param {UpdateWalletInput} updateWalletInput UpdateWallet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateWallet: async (
      walletId: string,
      updateWalletInput: UpdateWalletInput,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'walletId' is not null or undefined
      assertParamExists('updateWallet', 'walletId', walletId)
      // verify required parameter 'updateWalletInput' is not null or undefined
      assertParamExists('updateWallet', 'updateWalletInput', updateWalletInput)
      const localVarPath = `/v1/wallets/{walletId}`.replace(
        `{${'walletId'}}`,
        encodeURIComponent(String(walletId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateWalletInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * WalletApi - functional programming interface
 * @export
 */
export const WalletApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = WalletApiAxiosParamCreator(configuration)
  return {
    /**
     * creates a wallet
     * @param {CreateWalletInput} [createWalletInput] CreateWallet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createWallet(
      createWalletInput?: CreateWalletInput,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<CreateWalletResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createWallet(
        createWalletInput,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['WalletApi.createWallet']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * delete wallet by walletId
     * @param {string} walletId id of the wallet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteWallet(
      walletId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWallet(
        walletId,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['WalletApi.deleteWallet']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * get wallet details using wallet Id.
     * @param {string} walletId id of the wallet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getWallet(
      walletId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getWallet(
        walletId,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['WalletApi.getWallet']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * lists all wallets
     * @param {ListWalletsDidTypeEnum} [didType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listWallets(
      didType?: ListWalletsDidTypeEnum,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletsListDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listWallets(
        didType,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['WalletApi.listWallets']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * signs credential with the wallet
     * @param {string} walletId id of the wallet
     * @param {SignCredentialInputDto} signCredentialInputDto SignCredential
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signCredential(
      walletId: string,
      signCredentialInputDto: SignCredentialInputDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SignCredentialResultDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.signCredential(
        walletId,
        signCredentialInputDto,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['WalletApi.signCredential']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * signs a jwt token with the wallet
     * @param {string} walletId id of the wallet.
     * @param {SignJwtToken} signJwtToken SignJwtToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signJwtToken(
      walletId: string,
      signJwtToken: SignJwtToken,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignJwtTokenOK>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.signJwtToken(
        walletId,
        signJwtToken,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['WalletApi.signJwtToken']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * update wallet details using wallet Id.
     * @param {string} walletId id of the wallet
     * @param {UpdateWalletInput} updateWalletInput UpdateWallet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateWallet(
      walletId: string,
      updateWalletInput: UpdateWalletInput,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateWallet(
        walletId,
        updateWalletInput,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['WalletApi.updateWallet']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * WalletApi - factory interface
 * @export
 */
export const WalletApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = WalletApiFp(configuration)
  return {
    /**
     * creates a wallet
     * @param {CreateWalletInput} [createWalletInput] CreateWallet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWallet(
      createWalletInput?: CreateWalletInput,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<CreateWalletResponse> {
      return localVarFp
        .createWallet(createWalletInput, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * delete wallet by walletId
     * @param {string} walletId id of the wallet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWallet(
      walletId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .deleteWallet(walletId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * get wallet details using wallet Id.
     * @param {string} walletId id of the wallet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWallet(
      walletId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<WalletDto> {
      return localVarFp
        .getWallet(walletId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * lists all wallets
     * @param {ListWalletsDidTypeEnum} [didType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWallets(
      didType?: ListWalletsDidTypeEnum,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<WalletsListDto> {
      return localVarFp
        .listWallets(didType, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * signs credential with the wallet
     * @param {string} walletId id of the wallet
     * @param {SignCredentialInputDto} signCredentialInputDto SignCredential
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signCredential(
      walletId: string,
      signCredentialInputDto: SignCredentialInputDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SignCredentialResultDto> {
      return localVarFp
        .signCredential(walletId, signCredentialInputDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * signs a jwt token with the wallet
     * @param {string} walletId id of the wallet.
     * @param {SignJwtToken} signJwtToken SignJwtToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signJwtToken(
      walletId: string,
      signJwtToken: SignJwtToken,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SignJwtTokenOK> {
      return localVarFp
        .signJwtToken(walletId, signJwtToken, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * update wallet details using wallet Id.
     * @param {string} walletId id of the wallet
     * @param {UpdateWalletInput} updateWalletInput UpdateWallet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateWallet(
      walletId: string,
      updateWalletInput: UpdateWalletInput,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<WalletDto> {
      return localVarFp
        .updateWallet(walletId, updateWalletInput, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * WalletApi - object-oriented interface
 * @export
 * @class WalletApi
 * @extends {BaseAPI}
 */
export class WalletApi extends BaseAPI {
  /**
   * creates a wallet
   * @param {CreateWalletInput} [createWalletInput] CreateWallet
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletApi
   */
  public createWallet(
    createWalletInput?: CreateWalletInput,
    options?: RawAxiosRequestConfig,
  ) {
    return WalletApiFp(this.configuration)
      .createWallet(createWalletInput, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * delete wallet by walletId
   * @param {string} walletId id of the wallet
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletApi
   */
  public deleteWallet(walletId: string, options?: RawAxiosRequestConfig) {
    return WalletApiFp(this.configuration)
      .deleteWallet(walletId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * get wallet details using wallet Id.
   * @param {string} walletId id of the wallet
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletApi
   */
  public getWallet(walletId: string, options?: RawAxiosRequestConfig) {
    return WalletApiFp(this.configuration)
      .getWallet(walletId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * lists all wallets
   * @param {ListWalletsDidTypeEnum} [didType]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletApi
   */
  public listWallets(
    didType?: ListWalletsDidTypeEnum,
    options?: RawAxiosRequestConfig,
  ) {
    return WalletApiFp(this.configuration)
      .listWallets(didType, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * signs credential with the wallet
   * @param {string} walletId id of the wallet
   * @param {SignCredentialInputDto} signCredentialInputDto SignCredential
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletApi
   */
  public signCredential(
    walletId: string,
    signCredentialInputDto: SignCredentialInputDto,
    options?: RawAxiosRequestConfig,
  ) {
    return WalletApiFp(this.configuration)
      .signCredential(walletId, signCredentialInputDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * signs a jwt token with the wallet
   * @param {string} walletId id of the wallet.
   * @param {SignJwtToken} signJwtToken SignJwtToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletApi
   */
  public signJwtToken(
    walletId: string,
    signJwtToken: SignJwtToken,
    options?: RawAxiosRequestConfig,
  ) {
    return WalletApiFp(this.configuration)
      .signJwtToken(walletId, signJwtToken, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * update wallet details using wallet Id.
   * @param {string} walletId id of the wallet
   * @param {UpdateWalletInput} updateWalletInput UpdateWallet
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletApi
   */
  public updateWallet(
    walletId: string,
    updateWalletInput: UpdateWalletInput,
    options?: RawAxiosRequestConfig,
  ) {
    return WalletApiFp(this.configuration)
      .updateWallet(walletId, updateWalletInput, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * @export
 */
export const ListWalletsDidTypeEnum = {
  Web: 'WEB',
  Key: 'KEY',
} as const
export type ListWalletsDidTypeEnum =
  (typeof ListWalletsDidTypeEnum)[keyof typeof ListWalletsDidTypeEnum]
