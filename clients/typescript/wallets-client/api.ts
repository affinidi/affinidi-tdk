/* tslint:disable */
/* eslint-disable */
/**
 * CloudWalletEssentials
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: info@affinidi.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration'
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios'
import globalAxios from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common'
import type { RequestArgs } from './base'
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  BaseAPI,
  RequiredError,
  operationServerMap,
} from './base'

/**
 * DTO contains params to authcrypt plain text DIDComm message
 * @export
 * @interface AuthcryptMessageInput
 */
export interface AuthcryptMessageInput {
  /**
   * Unsigned plain text DIDComm message
   * @type {object}
   * @memberof AuthcryptMessageInput
   */
  plainTextMessage: object
  /**
   *
   * @type {string}
   * @memberof AuthcryptMessageInput
   */
  signatureScheme?: AuthcryptMessageInputSignatureSchemeEnum
}

export const AuthcryptMessageInputSignatureSchemeEnum = {
  EcdsaSecp256k1Sha256: 'ecdsa_secp256k1_sha256',
  EcdsaP256Sha256: 'ecdsa_p256_sha256',
  Ed25519: 'ed25519',
} as const

export type AuthcryptMessageInputSignatureSchemeEnum =
  (typeof AuthcryptMessageInputSignatureSchemeEnum)[keyof typeof AuthcryptMessageInputSignatureSchemeEnum]

/**
 * DTO contains authcrypted message in JSON format
 * @export
 * @interface AuthcryptMessageResultDto
 */
export interface AuthcryptMessageResultDto {
  /**
   * Authcrypted message in JSON format
   * @type {object}
   * @memberof AuthcryptMessageResultDto
   */
  authcryptedMessage: object
}
/**
 *
 * @export
 * @interface CreateWalletInput
 */
export interface CreateWalletInput {
  /**
   * The name of the wallet
   * @type {string}
   * @memberof CreateWalletInput
   */
  name?: string
  /**
   * The description of the wallet
   * @type {string}
   * @memberof CreateWalletInput
   */
  description?: string
  /**
   * Define how DID of your wallet is created and resolved
   * @type {string}
   * @memberof CreateWalletInput
   */
  didMethod?: CreateWalletInputDidMethodEnum
  /**
   * URL of the DID. Required if the did method is web
   * @type {string}
   * @memberof CreateWalletInput
   */
  didWebUrl?: string
}

export const CreateWalletInputDidMethodEnum = {
  Key: 'key',
  Web: 'web',
  Peer0: 'peer0',
} as const

export type CreateWalletInputDidMethodEnum =
  (typeof CreateWalletInputDidMethodEnum)[keyof typeof CreateWalletInputDidMethodEnum]

/**
 * wallet dto
 * @export
 * @interface CreateWalletResponse
 */
export interface CreateWalletResponse {
  /**
   *
   * @type {WalletDto}
   * @memberof CreateWalletResponse
   */
  wallet?: WalletDto
}
/**
 *
 * @export
 * @interface CreateWalletV2Input
 */
export interface CreateWalletV2Input {
  /**
   * The name of the wallet
   * @type {string}
   * @memberof CreateWalletV2Input
   */
  name?: string
  /**
   * The description of the wallet
   * @type {string}
   * @memberof CreateWalletV2Input
   */
  description?: string
  /**
   * Define how DID of your wallet is created and resolved
   * @type {string}
   * @memberof CreateWalletV2Input
   */
  didMethod?: CreateWalletV2InputDidMethodEnum
  /**
   * URL of the DID. Required if the did method is web
   * @type {string}
   * @memberof CreateWalletV2Input
   */
  didWebUrl?: string
  /**
   * algorithm to generate key for the wallet
   * @type {string}
   * @memberof CreateWalletV2Input
   */
  algorithm?: CreateWalletV2InputAlgorithmEnum
}

export const CreateWalletV2InputDidMethodEnum = {
  Key: 'key',
  Web: 'web',
  Peer0: 'peer0',
} as const

export type CreateWalletV2InputDidMethodEnum =
  (typeof CreateWalletV2InputDidMethodEnum)[keyof typeof CreateWalletV2InputDidMethodEnum]
export const CreateWalletV2InputAlgorithmEnum = {
  Secp256k1: 'secp256k1',
  Ed25519: 'ed25519',
  P256: 'p256',
} as const

export type CreateWalletV2InputAlgorithmEnum =
  (typeof CreateWalletV2InputAlgorithmEnum)[keyof typeof CreateWalletV2InputAlgorithmEnum]

/**
 * wallet dto
 * @export
 * @interface CreateWalletV2Response
 */
export interface CreateWalletV2Response {
  /**
   *
   * @type {WalletV2Dto}
   * @memberof CreateWalletV2Response
   */
  wallet?: WalletV2Dto
}
/**
 *
 * @export
 * @interface EntityNotFoundError
 */
export interface EntityNotFoundError {
  /**
   *
   * @type {string}
   * @memberof EntityNotFoundError
   */
  name: EntityNotFoundErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof EntityNotFoundError
   */
  message: EntityNotFoundErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof EntityNotFoundError
   */
  httpStatusCode: EntityNotFoundErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof EntityNotFoundError
   */
  traceId: string
  /**
   *
   * @type {Array<ServiceErrorResponseDetailsInner>}
   * @memberof EntityNotFoundError
   */
  details?: Array<ServiceErrorResponseDetailsInner>
}

export const EntityNotFoundErrorNameEnum = {
  EntityNotFoundError: 'EntityNotFoundError',
} as const

export type EntityNotFoundErrorNameEnum =
  (typeof EntityNotFoundErrorNameEnum)[keyof typeof EntityNotFoundErrorNameEnum]
export const EntityNotFoundErrorMessageEnum = {
  EntityNotFound: 'Entity not found',
} as const

export type EntityNotFoundErrorMessageEnum =
  (typeof EntityNotFoundErrorMessageEnum)[keyof typeof EntityNotFoundErrorMessageEnum]
export const EntityNotFoundErrorHttpStatusCodeEnum = {
  NUMBER_404: 404,
} as const

export type EntityNotFoundErrorHttpStatusCodeEnum =
  (typeof EntityNotFoundErrorHttpStatusCodeEnum)[keyof typeof EntityNotFoundErrorHttpStatusCodeEnum]

/**
 * DTO contains revocation list credential
 * @export
 * @interface GetRevocationCredentialStatusOK
 */
export interface GetRevocationCredentialStatusOK {
  /**
   *
   * @type {object}
   * @memberof GetRevocationCredentialStatusOK
   */
  revocationListCredential: object
}
/**
 * DTO contains revocation list credential
 * @export
 * @interface GetRevocationListCredentialResultDto
 */
export interface GetRevocationListCredentialResultDto {
  /**
   *
   * @type {object}
   * @memberof GetRevocationListCredentialResultDto
   */
  revocationListCredential: object
}
/**
 *
 * @export
 * @interface InvalidDidParameterError
 */
export interface InvalidDidParameterError {
  /**
   *
   * @type {string}
   * @memberof InvalidDidParameterError
   */
  name: InvalidDidParameterErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof InvalidDidParameterError
   */
  message: InvalidDidParameterErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof InvalidDidParameterError
   */
  httpStatusCode: InvalidDidParameterErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof InvalidDidParameterError
   */
  traceId: string
  /**
   *
   * @type {Array<ServiceErrorResponseDetailsInner>}
   * @memberof InvalidDidParameterError
   */
  details?: Array<ServiceErrorResponseDetailsInner>
}

export const InvalidDidParameterErrorNameEnum = {
  InvalidDidParameterError: 'InvalidDidParameterError',
} as const

export type InvalidDidParameterErrorNameEnum =
  (typeof InvalidDidParameterErrorNameEnum)[keyof typeof InvalidDidParameterErrorNameEnum]
export const InvalidDidParameterErrorMessageEnum = {
  GivenDidInFieldToDidIsInvalidUseOnlyResolvableFormOfDid:
    'Given did in field toDid is invalid. Use only resolvable form of did.',
} as const

export type InvalidDidParameterErrorMessageEnum =
  (typeof InvalidDidParameterErrorMessageEnum)[keyof typeof InvalidDidParameterErrorMessageEnum]
export const InvalidDidParameterErrorHttpStatusCodeEnum = {
  NUMBER_400: 400,
} as const

export type InvalidDidParameterErrorHttpStatusCodeEnum =
  (typeof InvalidDidParameterErrorHttpStatusCodeEnum)[keyof typeof InvalidDidParameterErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface InvalidParameterError
 */
export interface InvalidParameterError {
  /**
   *
   * @type {string}
   * @memberof InvalidParameterError
   */
  name: InvalidParameterErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof InvalidParameterError
   */
  message: InvalidParameterErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof InvalidParameterError
   */
  httpStatusCode: InvalidParameterErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof InvalidParameterError
   */
  traceId: string
  /**
   *
   * @type {Array<ServiceErrorResponseDetailsInner>}
   * @memberof InvalidParameterError
   */
  details?: Array<ServiceErrorResponseDetailsInner>
}

export const InvalidParameterErrorNameEnum = {
  InvalidParameterError: 'InvalidParameterError',
} as const

export type InvalidParameterErrorNameEnum =
  (typeof InvalidParameterErrorNameEnum)[keyof typeof InvalidParameterErrorNameEnum]
export const InvalidParameterErrorMessageEnum = {
  InvalidParameterParam: 'Invalid parameter: ${param}.',
} as const

export type InvalidParameterErrorMessageEnum =
  (typeof InvalidParameterErrorMessageEnum)[keyof typeof InvalidParameterErrorMessageEnum]
export const InvalidParameterErrorHttpStatusCodeEnum = {
  NUMBER_400: 400,
} as const

export type InvalidParameterErrorHttpStatusCodeEnum =
  (typeof InvalidParameterErrorHttpStatusCodeEnum)[keyof typeof InvalidParameterErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface KeyNotFoundError
 */
export interface KeyNotFoundError {
  /**
   *
   * @type {string}
   * @memberof KeyNotFoundError
   */
  name: KeyNotFoundErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof KeyNotFoundError
   */
  message: KeyNotFoundErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof KeyNotFoundError
   */
  httpStatusCode: KeyNotFoundErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof KeyNotFoundError
   */
  traceId: string
  /**
   *
   * @type {Array<ServiceErrorResponseDetailsInner>}
   * @memberof KeyNotFoundError
   */
  details?: Array<ServiceErrorResponseDetailsInner>
}

export const KeyNotFoundErrorNameEnum = {
  KeyNotFoundError: 'KeyNotFoundError',
} as const

export type KeyNotFoundErrorNameEnum =
  (typeof KeyNotFoundErrorNameEnum)[keyof typeof KeyNotFoundErrorNameEnum]
export const KeyNotFoundErrorMessageEnum = {
  KeyNotFound: 'Key not found',
} as const

export type KeyNotFoundErrorMessageEnum =
  (typeof KeyNotFoundErrorMessageEnum)[keyof typeof KeyNotFoundErrorMessageEnum]
export const KeyNotFoundErrorHttpStatusCodeEnum = {
  NUMBER_500: 500,
} as const

export type KeyNotFoundErrorHttpStatusCodeEnum =
  (typeof KeyNotFoundErrorHttpStatusCodeEnum)[keyof typeof KeyNotFoundErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface NotFoundError
 */
export interface NotFoundError {
  /**
   *
   * @type {string}
   * @memberof NotFoundError
   */
  name: NotFoundErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof NotFoundError
   */
  message: NotFoundErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof NotFoundError
   */
  httpStatusCode: NotFoundErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof NotFoundError
   */
  traceId: string
  /**
   *
   * @type {Array<ServiceErrorResponseDetailsInner>}
   * @memberof NotFoundError
   */
  details?: Array<ServiceErrorResponseDetailsInner>
}

export const NotFoundErrorNameEnum = {
  NotFoundError: 'NotFoundError',
} as const

export type NotFoundErrorNameEnum =
  (typeof NotFoundErrorNameEnum)[keyof typeof NotFoundErrorNameEnum]
export const NotFoundErrorMessageEnum = {
  NotFoundParam: 'Not found: ${param}.',
} as const

export type NotFoundErrorMessageEnum =
  (typeof NotFoundErrorMessageEnum)[keyof typeof NotFoundErrorMessageEnum]
export const NotFoundErrorHttpStatusCodeEnum = {
  NUMBER_404: 404,
} as const

export type NotFoundErrorHttpStatusCodeEnum =
  (typeof NotFoundErrorHttpStatusCodeEnum)[keyof typeof NotFoundErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface OperationForbiddenError
 */
export interface OperationForbiddenError {
  /**
   *
   * @type {string}
   * @memberof OperationForbiddenError
   */
  name: OperationForbiddenErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof OperationForbiddenError
   */
  message: OperationForbiddenErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof OperationForbiddenError
   */
  httpStatusCode: OperationForbiddenErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof OperationForbiddenError
   */
  traceId: string
  /**
   *
   * @type {Array<ServiceErrorResponseDetailsInner>}
   * @memberof OperationForbiddenError
   */
  details?: Array<ServiceErrorResponseDetailsInner>
}

export const OperationForbiddenErrorNameEnum = {
  OperationForbiddenError: 'OperationForbiddenError',
} as const

export type OperationForbiddenErrorNameEnum =
  (typeof OperationForbiddenErrorNameEnum)[keyof typeof OperationForbiddenErrorNameEnum]
export const OperationForbiddenErrorMessageEnum = {
  OperationForbiddenParam: 'Operation forbidden: ${param}.',
} as const

export type OperationForbiddenErrorMessageEnum =
  (typeof OperationForbiddenErrorMessageEnum)[keyof typeof OperationForbiddenErrorMessageEnum]
export const OperationForbiddenErrorHttpStatusCodeEnum = {
  NUMBER_403: 403,
} as const

export type OperationForbiddenErrorHttpStatusCodeEnum =
  (typeof OperationForbiddenErrorHttpStatusCodeEnum)[keyof typeof OperationForbiddenErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface RevokeCredentialInput
 */
export interface RevokeCredentialInput {
  /**
   *
   * @type {string}
   * @memberof RevokeCredentialInput
   */
  revocationReason?: string | null
  /**
   *
   * @type {string}
   * @memberof RevokeCredentialInput
   */
  credentialId?: string
}
/**
 *
 * @export
 * @interface RevokeCredentialsInput
 */
export interface RevokeCredentialsInput {
  /**
   *
   * @type {string}
   * @memberof RevokeCredentialsInput
   */
  revocationReason?: string
  /**
   *
   * @type {string}
   * @memberof RevokeCredentialsInput
   */
  credentialId: string
}
/**
 *
 * @export
 * @interface ServiceErrorResponse
 */
export interface ServiceErrorResponse {
  /**
   * unique id for correlating this specific error to logs
   * @type {string}
   * @memberof ServiceErrorResponse
   */
  debugId: string
  /**
   * name of the error
   * @type {string}
   * @memberof ServiceErrorResponse
   */
  name: string
  /**
   * backwards compatible Affinidi error code
   * @type {string}
   * @memberof ServiceErrorResponse
   */
  code: string
  /**
   *
   * @type {Array<ServiceErrorResponseDetailsInner>}
   * @memberof ServiceErrorResponse
   */
  details?: Array<ServiceErrorResponseDetailsInner>
}
/**
 *
 * @export
 * @interface ServiceErrorResponseDetailsInner
 */
export interface ServiceErrorResponseDetailsInner {
  /**
   *
   * @type {string}
   * @memberof ServiceErrorResponseDetailsInner
   */
  issue: string
  /**
   *
   * @type {string}
   * @memberof ServiceErrorResponseDetailsInner
   */
  field?: string
  /**
   *
   * @type {string}
   * @memberof ServiceErrorResponseDetailsInner
   */
  value?: string
  /**
   *
   * @type {string}
   * @memberof ServiceErrorResponseDetailsInner
   */
  location?: string
}
/**
 * @type SignCredential400Response
 * @export
 */
export type SignCredential400Response =
  | InvalidParameterError
  | SigningFailedError

/**
 * DTO contains params to sign credential
 * @export
 * @interface SignCredentialInputDto
 */
export interface SignCredentialInputDto {
  /**
   * Unsigned Credential. If provided \"unsignedCredentialParams\" is not accepted
   * @type {object}
   * @memberof SignCredentialInputDto
   */
  unsignedCredential?: object
  /**
   *
   * @type {boolean}
   * @memberof SignCredentialInputDto
   */
  revocable?: boolean
  /**
   *
   * @type {string}
   * @memberof SignCredentialInputDto
   */
  credentialFormat?: SignCredentialInputDtoCredentialFormatEnum
  /**
   *
   * @type {SignCredentialInputDtoUnsignedCredentialParams}
   * @memberof SignCredentialInputDto
   */
  unsignedCredentialParams?: SignCredentialInputDtoUnsignedCredentialParams
}

export const SignCredentialInputDtoCredentialFormatEnum = {
  LdpVc: 'ldp_vc',
  JwtVcJsonLd: 'jwt_vc_json-ld',
  SdJwtVcJsonLd: 'sd_jwt_vc_json-ld',
} as const

export type SignCredentialInputDtoCredentialFormatEnum =
  (typeof SignCredentialInputDtoCredentialFormatEnum)[keyof typeof SignCredentialInputDtoCredentialFormatEnum]

/**
 * unsignedCredentialParams. Used to build an unsigned credential before the signing. This param is not accepted when \"unsignedCredential\" is given
 * @export
 * @interface SignCredentialInputDtoUnsignedCredentialParams
 */
export interface SignCredentialInputDtoUnsignedCredentialParams {
  /**
   *
   * @type {string}
   * @memberof SignCredentialInputDtoUnsignedCredentialParams
   */
  jsonLdContextUrl: string
  /**
   *
   * @type {string}
   * @memberof SignCredentialInputDtoUnsignedCredentialParams
   */
  jsonSchemaUrl: string
  /**
   *
   * @type {string}
   * @memberof SignCredentialInputDtoUnsignedCredentialParams
   */
  typeName: string
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof SignCredentialInputDtoUnsignedCredentialParams
   */
  credentialSubject: { [key: string]: any }
  /**
   *
   * @type {string}
   * @memberof SignCredentialInputDtoUnsignedCredentialParams
   */
  holderDid: string
  /**
   *
   * @type {string}
   * @memberof SignCredentialInputDtoUnsignedCredentialParams
   */
  expiresAt: string
}
/**
 * DTO contains signed credential
 * @export
 * @interface SignCredentialResultDto
 */
export interface SignCredentialResultDto {
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof SignCredentialResultDto
   */
  signedCredential: { [key: string]: any }
}
/**
 * DTO contains params to sign credential
 * @export
 * @interface SignCredentialsDm1LdInputDto
 */
export interface SignCredentialsDm1LdInputDto {
  /**
   * Unsigned Credential in Dm1 format
   * @type {object}
   * @memberof SignCredentialsDm1LdInputDto
   */
  unsignedCredential: object
  /**
   *
   * @type {boolean}
   * @memberof SignCredentialsDm1LdInputDto
   */
  revocable?: boolean
  /**
   *
   * @type {string}
   * @memberof SignCredentialsDm1LdInputDto
   */
  signatureScheme?: SignCredentialsDm1LdInputDtoSignatureSchemeEnum
}

export const SignCredentialsDm1LdInputDtoSignatureSchemeEnum = {
  EcdsaSecp256k1Sha256: 'ecdsa_secp256k1_sha256',
  EcdsaP256Sha256: 'ecdsa_p256_sha256',
  Ed25519: 'ed25519',
} as const

export type SignCredentialsDm1LdInputDtoSignatureSchemeEnum =
  (typeof SignCredentialsDm1LdInputDtoSignatureSchemeEnum)[keyof typeof SignCredentialsDm1LdInputDtoSignatureSchemeEnum]

/**
 * DTO contains signed credential
 * @export
 * @interface SignCredentialsDm1LdResultDto
 */
export interface SignCredentialsDm1LdResultDto {
  /**
   * Signed credential can be in Dm1Ld format
   * @type {object}
   * @memberof SignCredentialsDm1LdResultDto
   */
  credential: object
}
/**
 * DTO contains params to sign credential
 * @export
 * @interface SignCredentialsDm2SdJwtInputDto
 */
export interface SignCredentialsDm2SdJwtInputDto {
  /**
   * Unsigned Credential in Dm2 format
   * @type {object}
   * @memberof SignCredentialsDm2SdJwtInputDto
   */
  unsignedCredential: object
  /**
   *
   * @type {boolean}
   * @memberof SignCredentialsDm2SdJwtInputDto
   */
  revocable?: boolean
  /**
   *
   * @type {object}
   * @memberof SignCredentialsDm2SdJwtInputDto
   */
  disclosureFrame: object
  /**
   *
   * @type {string}
   * @memberof SignCredentialsDm2SdJwtInputDto
   */
  signatureScheme?: SignCredentialsDm2SdJwtInputDtoSignatureSchemeEnum
}

export const SignCredentialsDm2SdJwtInputDtoSignatureSchemeEnum = {
  EcdsaSecp256k1Sha256: 'ecdsa_secp256k1_sha256',
  EcdsaP256Sha256: 'ecdsa_p256_sha256',
  Ed25519: 'ed25519',
} as const

export type SignCredentialsDm2SdJwtInputDtoSignatureSchemeEnum =
  (typeof SignCredentialsDm2SdJwtInputDtoSignatureSchemeEnum)[keyof typeof SignCredentialsDm2SdJwtInputDtoSignatureSchemeEnum]

/**
 * DTO contains signed credential
 * @export
 * @interface SignCredentialsDm2SdJwtResultDto
 */
export interface SignCredentialsDm2SdJwtResultDto {
  /**
   * Issued selective disclosure SD in jwt format
   * @type {string}
   * @memberof SignCredentialsDm2SdJwtResultDto
   */
  credential: string
}
/**
 * DTO contains params to sign credential
 * @export
 * @interface SignCredentialsJwtInputDto
 */
export interface SignCredentialsJwtInputDto {
  /**
   * Unsigned Credential in Dm1 format
   * @type {object}
   * @memberof SignCredentialsJwtInputDto
   */
  unsignedCredential: object
  /**
   *
   * @type {boolean}
   * @memberof SignCredentialsJwtInputDto
   */
  revocable?: boolean
  /**
   *
   * @type {string}
   * @memberof SignCredentialsJwtInputDto
   */
  signatureScheme?: SignCredentialsJwtInputDtoSignatureSchemeEnum
}

export const SignCredentialsJwtInputDtoSignatureSchemeEnum = {
  EcdsaSecp256k1Sha256: 'ecdsa_secp256k1_sha256',
  EcdsaP256Sha256: 'ecdsa_p256_sha256',
  Ed25519: 'ed25519',
} as const

export type SignCredentialsJwtInputDtoSignatureSchemeEnum =
  (typeof SignCredentialsJwtInputDtoSignatureSchemeEnum)[keyof typeof SignCredentialsJwtInputDtoSignatureSchemeEnum]

/**
 * DTO contains signed credential
 * @export
 * @interface SignCredentialsJwtResultDto
 */
export interface SignCredentialsJwtResultDto {
  /**
   * Signed credential in DM2 jwt format
   * @type {string}
   * @memberof SignCredentialsJwtResultDto
   */
  credential: string
}
/**
 * DTO contains params to sign credential
 * @export
 * @interface SignCredentialsLdpInputDto
 */
export interface SignCredentialsLdpInputDto {
  /**
   * Unsigned Credential in Dm2 format
   * @type {object}
   * @memberof SignCredentialsLdpInputDto
   */
  unsignedCredential: object
  /**
   *
   * @type {boolean}
   * @memberof SignCredentialsLdpInputDto
   */
  revocable?: boolean
  /**
   *
   * @type {string}
   * @memberof SignCredentialsLdpInputDto
   */
  signatureScheme?: SignCredentialsLdpInputDtoSignatureSchemeEnum
}

export const SignCredentialsLdpInputDtoSignatureSchemeEnum = {
  EcdsaSecp256k1Sha256: 'ecdsa_secp256k1_sha256',
  EcdsaP256Sha256: 'ecdsa_p256_sha256',
  Ed25519: 'ed25519',
} as const

export type SignCredentialsLdpInputDtoSignatureSchemeEnum =
  (typeof SignCredentialsLdpInputDtoSignatureSchemeEnum)[keyof typeof SignCredentialsLdpInputDtoSignatureSchemeEnum]

/**
 * DTO contains signed credential
 * @export
 * @interface SignCredentialsLdpResultDto
 */
export interface SignCredentialsLdpResultDto {
  /**
   * Signed credential can be in Dm2Ld format
   * @type {object}
   * @memberof SignCredentialsLdpResultDto
   */
  credential: object
}
/**
 * DTO contains parts of JWT to be signed
 * @export
 * @interface SignJwtToken
 */
export interface SignJwtToken {
  /**
   *
   * @type {object}
   * @memberof SignJwtToken
   */
  header: object
  /**
   *
   * @type {object}
   * @memberof SignJwtToken
   */
  payload: object
}
/**
 *
 * @export
 * @interface SignJwtTokenOK
 */
export interface SignJwtTokenOK {
  /**
   *
   * @type {string}
   * @memberof SignJwtTokenOK
   */
  signedJwt?: string
}
/**
 * DTO contains params to sign plain text DIDComm message
 * @export
 * @interface SignMessageInput
 */
export interface SignMessageInput {
  /**
   * Unsigned plain text DIDComm message
   * @type {object}
   * @memberof SignMessageInput
   */
  plainTextMessage: object
  /**
   *
   * @type {string}
   * @memberof SignMessageInput
   */
  signatureScheme?: SignMessageInputSignatureSchemeEnum
}

export const SignMessageInputSignatureSchemeEnum = {
  EcdsaSecp256k1Sha256: 'ecdsa_secp256k1_sha256',
  EcdsaP256Sha256: 'ecdsa_p256_sha256',
  Ed25519: 'ed25519',
} as const

export type SignMessageInputSignatureSchemeEnum =
  (typeof SignMessageInputSignatureSchemeEnum)[keyof typeof SignMessageInputSignatureSchemeEnum]

/**
 * DTO contains signed JSON
 * @export
 * @interface SignMessageResultDto
 */
export interface SignMessageResultDto {
  /**
   * Signed message in JSON format
   * @type {object}
   * @memberof SignMessageResultDto
   */
  signedMessage: object
}
/**
 * DTO contains params to sign presentation
 * @export
 * @interface SignPresentationLdpInputDto
 */
export interface SignPresentationLdpInputDto {
  /**
   * Unsigned presentation in Dm1 format
   * @type {object}
   * @memberof SignPresentationLdpInputDto
   */
  unsignedPresentation: object
  /**
   *
   * @type {string}
   * @memberof SignPresentationLdpInputDto
   */
  signatureScheme?: SignPresentationLdpInputDtoSignatureSchemeEnum
  /**
   * Domain(s) for which the presentation is intended
   * @type {Array<string>}
   * @memberof SignPresentationLdpInputDto
   */
  domain?: Array<string>
  /**
   * Challenge string
   * @type {string}
   * @memberof SignPresentationLdpInputDto
   */
  challenge?: string
}

export const SignPresentationLdpInputDtoSignatureSchemeEnum = {
  EcdsaSecp256k1Sha256: 'ecdsa_secp256k1_sha256',
  EcdsaP256Sha256: 'ecdsa_p256_sha256',
  Ed25519: 'ed25519',
} as const

export type SignPresentationLdpInputDtoSignatureSchemeEnum =
  (typeof SignPresentationLdpInputDtoSignatureSchemeEnum)[keyof typeof SignPresentationLdpInputDtoSignatureSchemeEnum]

/**
 * DTO contains signed presentation
 * @export
 * @interface SignPresentationLdpResultDto
 */
export interface SignPresentationLdpResultDto {
  /**
   * Signed presentation in Dm1Ld format
   * @type {object}
   * @memberof SignPresentationLdpResultDto
   */
  presentation: object
}
/**
 *
 * @export
 * @interface SigningFailedError
 */
export interface SigningFailedError {
  /**
   *
   * @type {string}
   * @memberof SigningFailedError
   */
  name: SigningFailedErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof SigningFailedError
   */
  message: SigningFailedErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof SigningFailedError
   */
  httpStatusCode: SigningFailedErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof SigningFailedError
   */
  traceId: string
  /**
   *
   * @type {Array<ServiceErrorResponseDetailsInner>}
   * @memberof SigningFailedError
   */
  details?: Array<ServiceErrorResponseDetailsInner>
}

export const SigningFailedErrorNameEnum = {
  SigningFailedError: 'SigningFailedError',
} as const

export type SigningFailedErrorNameEnum =
  (typeof SigningFailedErrorNameEnum)[keyof typeof SigningFailedErrorNameEnum]
export const SigningFailedErrorMessageEnum = {
  SigningFailed: 'Signing failed.',
} as const

export type SigningFailedErrorMessageEnum =
  (typeof SigningFailedErrorMessageEnum)[keyof typeof SigningFailedErrorMessageEnum]
export const SigningFailedErrorHttpStatusCodeEnum = {
  NUMBER_400: 400,
} as const

export type SigningFailedErrorHttpStatusCodeEnum =
  (typeof SigningFailedErrorHttpStatusCodeEnum)[keyof typeof SigningFailedErrorHttpStatusCodeEnum]

/**
 * Update wallet input params
 * @export
 * @interface UpdateWalletInput
 */
export interface UpdateWalletInput {
  /**
   * The name of the wallet
   * @type {string}
   * @memberof UpdateWalletInput
   */
  name?: string
  /**
   * The description of the wallet
   * @type {string}
   * @memberof UpdateWalletInput
   */
  description?: string
}
/**
 * wallet dto
 * @export
 * @interface WalletDto
 */
export interface WalletDto {
  /**
   * id of the wallet in uuidV4 format
   * @type {string}
   * @memberof WalletDto
   */
  id?: string
  /**
   * did of the wallet
   * @type {string}
   * @memberof WalletDto
   */
  did?: string
  /**
   * The name of the wallet
   * @type {string}
   * @memberof WalletDto
   */
  name?: string
  /**
   * The description of the wallet
   * @type {string}
   * @memberof WalletDto
   */
  description?: string
  /**
   * did document of the wallet
   * @type {object}
   * @memberof WalletDto
   */
  didDocument?: object
  /**
   * ARI of the wallet
   * @type {string}
   * @memberof WalletDto
   */
  ari?: string
  /**
   *
   * @type {Array<WalletDtoKeysInner>}
   * @memberof WalletDto
   */
  keys?: Array<WalletDtoKeysInner>
  /**
   *
   * @type {string}
   * @memberof WalletDto
   */
  createdAt?: string
  /**
   *
   * @type {string}
   * @memberof WalletDto
   */
  modifiedAt?: string
}
/**
 *
 * @export
 * @interface WalletDtoKeysInner
 */
export interface WalletDtoKeysInner {
  /**
   * id of linked key
   * @type {string}
   * @memberof WalletDtoKeysInner
   */
  id?: string
  /**
   * ari of linked key
   * @type {string}
   * @memberof WalletDtoKeysInner
   */
  ari?: string
}
/**
 * wallet v2 dto
 * @export
 * @interface WalletV2Dto
 */
export interface WalletV2Dto {
  /**
   * id of the wallet in uuidV4 format
   * @type {string}
   * @memberof WalletV2Dto
   */
  id?: string
  /**
   * did of the wallet
   * @type {string}
   * @memberof WalletV2Dto
   */
  did?: string
  /**
   * The name of the wallet
   * @type {string}
   * @memberof WalletV2Dto
   */
  name?: string
  /**
   * The description of the wallet
   * @type {string}
   * @memberof WalletV2Dto
   */
  description?: string
  /**
   * did document of the wallet
   * @type {object}
   * @memberof WalletV2Dto
   */
  didDocument?: object
  /**
   * ARI of the wallet
   * @type {string}
   * @memberof WalletV2Dto
   */
  ari?: string
  /**
   * algorithm used to generate key for the wallet
   * @type {string}
   * @memberof WalletV2Dto
   */
  algorithm?: string
  /**
   *
   * @type {Array<WalletDtoKeysInner>}
   * @memberof WalletV2Dto
   */
  keys?: Array<WalletDtoKeysInner>
  /**
   *
   * @type {string}
   * @memberof WalletV2Dto
   */
  createdAt?: string
  /**
   *
   * @type {string}
   * @memberof WalletV2Dto
   */
  modifiedAt?: string
}
/**
 * list of wallets
 * @export
 * @interface WalletsListDto
 */
export interface WalletsListDto {
  /**
   *
   * @type {Array<WalletDto>}
   * @memberof WalletsListDto
   */
  wallets?: Array<WalletDto>
}

/**
 * RevocationApi - axios parameter creator
 * @export
 */
export const RevocationApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Get revocation status list as RevocationListCredential
     * @param {string} projectId Description for projectId.
     * @param {string} walletId Description for walletId.
     * @param {string} statusId Description for statusId.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRevocationCredentialStatus: async (
      projectId: string,
      walletId: string,
      statusId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists('getRevocationCredentialStatus', 'projectId', projectId)
      // verify required parameter 'walletId' is not null or undefined
      assertParamExists('getRevocationCredentialStatus', 'walletId', walletId)
      // verify required parameter 'statusId' is not null or undefined
      assertParamExists('getRevocationCredentialStatus', 'statusId', statusId)
      const localVarPath =
        `/v1/projects/{projectId}/wallets/{walletId}/revocation-statuses/{statusId}`
          .replace(`{${'projectId'}}`, encodeURIComponent(String(projectId)))
          .replace(`{${'walletId'}}`, encodeURIComponent(String(walletId)))
          .replace(`{${'statusId'}}`, encodeURIComponent(String(statusId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get revocation list 2020 Credential (required to check if VC revoked). It is a public endpoint.
     * @summary Return revocation list credential.
     * @param {string} listId
     * @param {string} walletId id of the wallet
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    getRevocationListCredential: async (
      listId: string,
      walletId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'listId' is not null or undefined
      assertParamExists('getRevocationListCredential', 'listId', listId)
      // verify required parameter 'walletId' is not null or undefined
      assertParamExists('getRevocationListCredential', 'walletId', walletId)
      const localVarPath = `/v1/wallets/{walletId}/revocation-list/{listId}`
        .replace(`{${'listId'}}`, encodeURIComponent(String(listId)))
        .replace(`{${'walletId'}}`, encodeURIComponent(String(walletId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update index/credetial at appropriate revocation list (set revoken is true).
     * @summary Revoke Credential.
     * @param {string} walletId id of the wallet
     * @param {RevokeCredentialInput} revokeCredentialInput RevokeCredential
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    revokeCredential: async (
      walletId: string,
      revokeCredentialInput: RevokeCredentialInput,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'walletId' is not null or undefined
      assertParamExists('revokeCredential', 'walletId', walletId)
      // verify required parameter 'revokeCredentialInput' is not null or undefined
      assertParamExists(
        'revokeCredential',
        'revokeCredentialInput',
        revokeCredentialInput,
      )
      const localVarPath = `/v1/wallets/{walletId}/revoke`.replace(
        `{${'walletId'}}`,
        encodeURIComponent(String(walletId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        revokeCredentialInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update index/credential at appropriate revocation list (set revoked is true).
     * @summary Revoke Credentials.
     * @param {string} walletId id of the wallet
     * @param {RevokeCredentialsInput} revokeCredentialsInput RevokeCredentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    revokeCredentials: async (
      walletId: string,
      revokeCredentialsInput: RevokeCredentialsInput,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'walletId' is not null or undefined
      assertParamExists('revokeCredentials', 'walletId', walletId)
      // verify required parameter 'revokeCredentialsInput' is not null or undefined
      assertParamExists(
        'revokeCredentials',
        'revokeCredentialsInput',
        revokeCredentialsInput,
      )
      const localVarPath = `/v2/wallets/{walletId}/credentials/revoke`.replace(
        `{${'walletId'}}`,
        encodeURIComponent(String(walletId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        revokeCredentialsInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * RevocationApi - functional programming interface
 * @export
 */
export const RevocationApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    RevocationApiAxiosParamCreator(configuration)
  return {
    /**
     * Get revocation status list as RevocationListCredential
     * @param {string} projectId Description for projectId.
     * @param {string} walletId Description for walletId.
     * @param {string} statusId Description for statusId.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRevocationCredentialStatus(
      projectId: string,
      walletId: string,
      statusId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<GetRevocationListCredentialResultDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getRevocationCredentialStatus(
          projectId,
          walletId,
          statusId,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['RevocationApi.getRevocationCredentialStatus']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Get revocation list 2020 Credential (required to check if VC revoked). It is a public endpoint.
     * @summary Return revocation list credential.
     * @param {string} listId
     * @param {string} walletId id of the wallet
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async getRevocationListCredential(
      listId: string,
      walletId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<GetRevocationListCredentialResultDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getRevocationListCredential(
          listId,
          walletId,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['RevocationApi.getRevocationListCredential']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Update index/credetial at appropriate revocation list (set revoken is true).
     * @summary Revoke Credential.
     * @param {string} walletId id of the wallet
     * @param {RevokeCredentialInput} revokeCredentialInput RevokeCredential
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async revokeCredential(
      walletId: string,
      revokeCredentialInput: RevokeCredentialInput,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.revokeCredential(
          walletId,
          revokeCredentialInput,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['RevocationApi.revokeCredential']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Update index/credential at appropriate revocation list (set revoked is true).
     * @summary Revoke Credentials.
     * @param {string} walletId id of the wallet
     * @param {RevokeCredentialsInput} revokeCredentialsInput RevokeCredentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async revokeCredentials(
      walletId: string,
      revokeCredentialsInput: RevokeCredentialsInput,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.revokeCredentials(
          walletId,
          revokeCredentialsInput,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['RevocationApi.revokeCredentials']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * RevocationApi - factory interface
 * @export
 */
export const RevocationApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = RevocationApiFp(configuration)
  return {
    /**
     * Get revocation status list as RevocationListCredential
     * @param {string} projectId Description for projectId.
     * @param {string} walletId Description for walletId.
     * @param {string} statusId Description for statusId.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRevocationCredentialStatus(
      projectId: string,
      walletId: string,
      statusId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GetRevocationListCredentialResultDto> {
      return localVarFp
        .getRevocationCredentialStatus(projectId, walletId, statusId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Get revocation list 2020 Credential (required to check if VC revoked). It is a public endpoint.
     * @summary Return revocation list credential.
     * @param {string} listId
     * @param {string} walletId id of the wallet
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    getRevocationListCredential(
      listId: string,
      walletId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GetRevocationListCredentialResultDto> {
      return localVarFp
        .getRevocationListCredential(listId, walletId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update index/credetial at appropriate revocation list (set revoken is true).
     * @summary Revoke Credential.
     * @param {string} walletId id of the wallet
     * @param {RevokeCredentialInput} revokeCredentialInput RevokeCredential
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    revokeCredential(
      walletId: string,
      revokeCredentialInput: RevokeCredentialInput,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .revokeCredential(walletId, revokeCredentialInput, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update index/credential at appropriate revocation list (set revoked is true).
     * @summary Revoke Credentials.
     * @param {string} walletId id of the wallet
     * @param {RevokeCredentialsInput} revokeCredentialsInput RevokeCredentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    revokeCredentials(
      walletId: string,
      revokeCredentialsInput: RevokeCredentialsInput,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .revokeCredentials(walletId, revokeCredentialsInput, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * RevocationApi - object-oriented interface
 * @export
 * @class RevocationApi
 * @extends {BaseAPI}
 */
export class RevocationApi extends BaseAPI {
  /**
   * Get revocation status list as RevocationListCredential
   * @param {string} projectId Description for projectId.
   * @param {string} walletId Description for walletId.
   * @param {string} statusId Description for statusId.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RevocationApi
   */
  public getRevocationCredentialStatus(
    projectId: string,
    walletId: string,
    statusId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return RevocationApiFp(this.configuration)
      .getRevocationCredentialStatus(projectId, walletId, statusId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Get revocation list 2020 Credential (required to check if VC revoked). It is a public endpoint.
   * @summary Return revocation list credential.
   * @param {string} listId
   * @param {string} walletId id of the wallet
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof RevocationApi
   */
  public getRevocationListCredential(
    listId: string,
    walletId: string,
    options?: RawAxiosRequestConfig,
  ) {
    return RevocationApiFp(this.configuration)
      .getRevocationListCredential(listId, walletId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update index/credetial at appropriate revocation list (set revoken is true).
   * @summary Revoke Credential.
   * @param {string} walletId id of the wallet
   * @param {RevokeCredentialInput} revokeCredentialInput RevokeCredential
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RevocationApi
   */
  public revokeCredential(
    walletId: string,
    revokeCredentialInput: RevokeCredentialInput,
    options?: RawAxiosRequestConfig,
  ) {
    return RevocationApiFp(this.configuration)
      .revokeCredential(walletId, revokeCredentialInput, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update index/credential at appropriate revocation list (set revoked is true).
   * @summary Revoke Credentials.
   * @param {string} walletId id of the wallet
   * @param {RevokeCredentialsInput} revokeCredentialsInput RevokeCredentials
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RevocationApi
   */
  public revokeCredentials(
    walletId: string,
    revokeCredentialsInput: RevokeCredentialsInput,
    options?: RawAxiosRequestConfig,
  ) {
    return RevocationApiFp(this.configuration)
      .revokeCredentials(walletId, revokeCredentialsInput, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * WalletApi - axios parameter creator
 * @export
 */
export const WalletApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * creates a wallet
     * @param {CreateWalletInput} [createWalletInput] CreateWallet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWallet: async (
      createWalletInput?: CreateWalletInput,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/wallets`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        createWalletInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Create v2 wallet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWalletV2: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v2/wallets`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * delete wallet by walletId
     * @param {string} walletId id of the wallet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWallet: async (
      walletId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'walletId' is not null or undefined
      assertParamExists('deleteWallet', 'walletId', walletId)
      const localVarPath = `/v1/wallets/{walletId}`.replace(
        `{${'walletId'}}`,
        encodeURIComponent(String(walletId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * get wallet details using wallet Id.
     * @param {string} walletId id of the wallet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWallet: async (
      walletId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'walletId' is not null or undefined
      assertParamExists('getWallet', 'walletId', walletId)
      const localVarPath = `/v1/wallets/{walletId}`.replace(
        `{${'walletId'}}`,
        encodeURIComponent(String(walletId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * lists all wallets
     * @param {ListWalletsDidTypeEnum} [didType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWallets: async (
      didType?: ListWalletsDidTypeEnum,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/wallets`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      if (didType !== undefined) {
        localVarQueryParameter['didType'] = didType
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * signs credential with the wallet
     * @param {string} walletId id of the wallet
     * @param {SignCredentialInputDto} signCredentialInputDto SignCredential
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signCredential: async (
      walletId: string,
      signCredentialInputDto: SignCredentialInputDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'walletId' is not null or undefined
      assertParamExists('signCredential', 'walletId', walletId)
      // verify required parameter 'signCredentialInputDto' is not null or undefined
      assertParamExists(
        'signCredential',
        'signCredentialInputDto',
        signCredentialInputDto,
      )
      const localVarPath = `/v1/wallets/{walletId}/sign-credential`.replace(
        `{${'walletId'}}`,
        encodeURIComponent(String(walletId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        signCredentialInputDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * signs credential with the wallet v2
     * @param {string} walletId id of the wallet
     * @param {SignCredentialsJwtInputDto} signCredentialsJwtInputDto signCredentialsJwt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signCredentialsJwt: async (
      walletId: string,
      signCredentialsJwtInputDto: SignCredentialsJwtInputDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'walletId' is not null or undefined
      assertParamExists('signCredentialsJwt', 'walletId', walletId)
      // verify required parameter 'signCredentialsJwtInputDto' is not null or undefined
      assertParamExists(
        'signCredentialsJwt',
        'signCredentialsJwtInputDto',
        signCredentialsJwtInputDto,
      )
      const localVarPath =
        `/v2/wallets/{walletId}/credentials/jwt/sign`.replace(
          `{${'walletId'}}`,
          encodeURIComponent(String(walletId)),
        )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        signCredentialsJwtInputDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * signs credential with the wallet v2
     * @param {string} walletId id of the wallet
     * @param {SignCredentialsLdpInputDto} signCredentialsLdpInputDto signCredentialsLdp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signCredentialsLdp: async (
      walletId: string,
      signCredentialsLdpInputDto: SignCredentialsLdpInputDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'walletId' is not null or undefined
      assertParamExists('signCredentialsLdp', 'walletId', walletId)
      // verify required parameter 'signCredentialsLdpInputDto' is not null or undefined
      assertParamExists(
        'signCredentialsLdp',
        'signCredentialsLdpInputDto',
        signCredentialsLdpInputDto,
      )
      const localVarPath =
        `/v2/wallets/{walletId}/credentials/ldp/sign`.replace(
          `{${'walletId'}}`,
          encodeURIComponent(String(walletId)),
        )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        signCredentialsLdpInputDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * signs credential with the wallet v2
     * @param {string} walletId id of the wallet
     * @param {SignCredentialsDm2SdJwtInputDto} signCredentialsDm2SdJwtInputDto SignCredentialsDm1SdJwt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signCredentialsSdJwt: async (
      walletId: string,
      signCredentialsDm2SdJwtInputDto: SignCredentialsDm2SdJwtInputDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'walletId' is not null or undefined
      assertParamExists('signCredentialsSdJwt', 'walletId', walletId)
      // verify required parameter 'signCredentialsDm2SdJwtInputDto' is not null or undefined
      assertParamExists(
        'signCredentialsSdJwt',
        'signCredentialsDm2SdJwtInputDto',
        signCredentialsDm2SdJwtInputDto,
      )
      const localVarPath =
        `/v2/wallets/{walletId}/credentials/sd-jwt/sign`.replace(
          `{${'walletId'}}`,
          encodeURIComponent(String(walletId)),
        )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        signCredentialsDm2SdJwtInputDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * signs a jwt token with the wallet
     * @param {string} walletId id of the wallet.
     * @param {SignJwtToken} signJwtToken SignJwtToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signJwtToken: async (
      walletId: string,
      signJwtToken: SignJwtToken,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'walletId' is not null or undefined
      assertParamExists('signJwtToken', 'walletId', walletId)
      // verify required parameter 'signJwtToken' is not null or undefined
      assertParamExists('signJwtToken', 'signJwtToken', signJwtToken)
      const localVarPath = `/v1/wallets/{walletId}/sign-jwt`.replace(
        `{${'walletId'}}`,
        encodeURIComponent(String(walletId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        signJwtToken,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * signs presentation with the wallet
     * @param {string} walletId id of the wallet
     * @param {SignPresentationLdpInputDto} signPresentationLdpInputDto signPresentationLdp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signPresentationsLdp: async (
      walletId: string,
      signPresentationLdpInputDto: SignPresentationLdpInputDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'walletId' is not null or undefined
      assertParamExists('signPresentationsLdp', 'walletId', walletId)
      // verify required parameter 'signPresentationLdpInputDto' is not null or undefined
      assertParamExists(
        'signPresentationsLdp',
        'signPresentationLdpInputDto',
        signPresentationLdpInputDto,
      )
      const localVarPath =
        `/v2/wallets/{walletId}/presentations/ldp/sign`.replace(
          `{${'walletId'}}`,
          encodeURIComponent(String(walletId)),
        )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        signPresentationLdpInputDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * update wallet details using wallet Id.
     * @param {string} walletId id of the wallet
     * @param {UpdateWalletInput} updateWalletInput UpdateWallet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateWallet: async (
      walletId: string,
      updateWalletInput: UpdateWalletInput,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'walletId' is not null or undefined
      assertParamExists('updateWallet', 'walletId', walletId)
      // verify required parameter 'updateWalletInput' is not null or undefined
      assertParamExists('updateWallet', 'updateWalletInput', updateWalletInput)
      const localVarPath = `/v1/wallets/{walletId}`.replace(
        `{${'walletId'}}`,
        encodeURIComponent(String(walletId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateWalletInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * WalletApi - functional programming interface
 * @export
 */
export const WalletApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = WalletApiAxiosParamCreator(configuration)
  return {
    /**
     * creates a wallet
     * @param {CreateWalletInput} [createWalletInput] CreateWallet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createWallet(
      createWalletInput?: CreateWalletInput,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<CreateWalletResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createWallet(
        createWalletInput,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['WalletApi.createWallet']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Create v2 wallet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createWalletV2(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<CreateWalletV2Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createWalletV2(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['WalletApi.createWalletV2']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * delete wallet by walletId
     * @param {string} walletId id of the wallet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteWallet(
      walletId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWallet(
        walletId,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['WalletApi.deleteWallet']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * get wallet details using wallet Id.
     * @param {string} walletId id of the wallet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getWallet(
      walletId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getWallet(
        walletId,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['WalletApi.getWallet']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * lists all wallets
     * @param {ListWalletsDidTypeEnum} [didType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listWallets(
      didType?: ListWalletsDidTypeEnum,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletsListDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listWallets(
        didType,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['WalletApi.listWallets']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * signs credential with the wallet
     * @param {string} walletId id of the wallet
     * @param {SignCredentialInputDto} signCredentialInputDto SignCredential
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signCredential(
      walletId: string,
      signCredentialInputDto: SignCredentialInputDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SignCredentialResultDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.signCredential(
        walletId,
        signCredentialInputDto,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['WalletApi.signCredential']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * signs credential with the wallet v2
     * @param {string} walletId id of the wallet
     * @param {SignCredentialsJwtInputDto} signCredentialsJwtInputDto signCredentialsJwt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signCredentialsJwt(
      walletId: string,
      signCredentialsJwtInputDto: SignCredentialsJwtInputDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SignCredentialsJwtResultDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.signCredentialsJwt(
          walletId,
          signCredentialsJwtInputDto,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['WalletApi.signCredentialsJwt']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * signs credential with the wallet v2
     * @param {string} walletId id of the wallet
     * @param {SignCredentialsLdpInputDto} signCredentialsLdpInputDto signCredentialsLdp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signCredentialsLdp(
      walletId: string,
      signCredentialsLdpInputDto: SignCredentialsLdpInputDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SignCredentialsLdpResultDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.signCredentialsLdp(
          walletId,
          signCredentialsLdpInputDto,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['WalletApi.signCredentialsLdp']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * signs credential with the wallet v2
     * @param {string} walletId id of the wallet
     * @param {SignCredentialsDm2SdJwtInputDto} signCredentialsDm2SdJwtInputDto SignCredentialsDm1SdJwt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signCredentialsSdJwt(
      walletId: string,
      signCredentialsDm2SdJwtInputDto: SignCredentialsDm2SdJwtInputDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SignCredentialsDm2SdJwtResultDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.signCredentialsSdJwt(
          walletId,
          signCredentialsDm2SdJwtInputDto,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['WalletApi.signCredentialsSdJwt']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * signs a jwt token with the wallet
     * @param {string} walletId id of the wallet.
     * @param {SignJwtToken} signJwtToken SignJwtToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signJwtToken(
      walletId: string,
      signJwtToken: SignJwtToken,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignJwtTokenOK>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.signJwtToken(
        walletId,
        signJwtToken,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['WalletApi.signJwtToken']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * signs presentation with the wallet
     * @param {string} walletId id of the wallet
     * @param {SignPresentationLdpInputDto} signPresentationLdpInputDto signPresentationLdp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signPresentationsLdp(
      walletId: string,
      signPresentationLdpInputDto: SignPresentationLdpInputDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SignPresentationLdpResultDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.signPresentationsLdp(
          walletId,
          signPresentationLdpInputDto,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['WalletApi.signPresentationsLdp']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * update wallet details using wallet Id.
     * @param {string} walletId id of the wallet
     * @param {UpdateWalletInput} updateWalletInput UpdateWallet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateWallet(
      walletId: string,
      updateWalletInput: UpdateWalletInput,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateWallet(
        walletId,
        updateWalletInput,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['WalletApi.updateWallet']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * WalletApi - factory interface
 * @export
 */
export const WalletApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = WalletApiFp(configuration)
  return {
    /**
     * creates a wallet
     * @param {CreateWalletInput} [createWalletInput] CreateWallet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWallet(
      createWalletInput?: CreateWalletInput,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<CreateWalletResponse> {
      return localVarFp
        .createWallet(createWalletInput, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Create v2 wallet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWalletV2(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<CreateWalletV2Response> {
      return localVarFp
        .createWalletV2(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * delete wallet by walletId
     * @param {string} walletId id of the wallet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWallet(
      walletId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .deleteWallet(walletId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * get wallet details using wallet Id.
     * @param {string} walletId id of the wallet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWallet(
      walletId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<WalletDto> {
      return localVarFp
        .getWallet(walletId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * lists all wallets
     * @param {ListWalletsDidTypeEnum} [didType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWallets(
      didType?: ListWalletsDidTypeEnum,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<WalletsListDto> {
      return localVarFp
        .listWallets(didType, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * signs credential with the wallet
     * @param {string} walletId id of the wallet
     * @param {SignCredentialInputDto} signCredentialInputDto SignCredential
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signCredential(
      walletId: string,
      signCredentialInputDto: SignCredentialInputDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SignCredentialResultDto> {
      return localVarFp
        .signCredential(walletId, signCredentialInputDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * signs credential with the wallet v2
     * @param {string} walletId id of the wallet
     * @param {SignCredentialsJwtInputDto} signCredentialsJwtInputDto signCredentialsJwt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signCredentialsJwt(
      walletId: string,
      signCredentialsJwtInputDto: SignCredentialsJwtInputDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SignCredentialsJwtResultDto> {
      return localVarFp
        .signCredentialsJwt(walletId, signCredentialsJwtInputDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * signs credential with the wallet v2
     * @param {string} walletId id of the wallet
     * @param {SignCredentialsLdpInputDto} signCredentialsLdpInputDto signCredentialsLdp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signCredentialsLdp(
      walletId: string,
      signCredentialsLdpInputDto: SignCredentialsLdpInputDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SignCredentialsLdpResultDto> {
      return localVarFp
        .signCredentialsLdp(walletId, signCredentialsLdpInputDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * signs credential with the wallet v2
     * @param {string} walletId id of the wallet
     * @param {SignCredentialsDm2SdJwtInputDto} signCredentialsDm2SdJwtInputDto SignCredentialsDm1SdJwt
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signCredentialsSdJwt(
      walletId: string,
      signCredentialsDm2SdJwtInputDto: SignCredentialsDm2SdJwtInputDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SignCredentialsDm2SdJwtResultDto> {
      return localVarFp
        .signCredentialsSdJwt(
          walletId,
          signCredentialsDm2SdJwtInputDto,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * signs a jwt token with the wallet
     * @param {string} walletId id of the wallet.
     * @param {SignJwtToken} signJwtToken SignJwtToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signJwtToken(
      walletId: string,
      signJwtToken: SignJwtToken,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SignJwtTokenOK> {
      return localVarFp
        .signJwtToken(walletId, signJwtToken, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * signs presentation with the wallet
     * @param {string} walletId id of the wallet
     * @param {SignPresentationLdpInputDto} signPresentationLdpInputDto signPresentationLdp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signPresentationsLdp(
      walletId: string,
      signPresentationLdpInputDto: SignPresentationLdpInputDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<SignPresentationLdpResultDto> {
      return localVarFp
        .signPresentationsLdp(walletId, signPresentationLdpInputDto, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * update wallet details using wallet Id.
     * @param {string} walletId id of the wallet
     * @param {UpdateWalletInput} updateWalletInput UpdateWallet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateWallet(
      walletId: string,
      updateWalletInput: UpdateWalletInput,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<WalletDto> {
      return localVarFp
        .updateWallet(walletId, updateWalletInput, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * WalletApi - object-oriented interface
 * @export
 * @class WalletApi
 * @extends {BaseAPI}
 */
export class WalletApi extends BaseAPI {
  /**
   * creates a wallet
   * @param {CreateWalletInput} [createWalletInput] CreateWallet
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletApi
   */
  public createWallet(
    createWalletInput?: CreateWalletInput,
    options?: RawAxiosRequestConfig,
  ) {
    return WalletApiFp(this.configuration)
      .createWallet(createWalletInput, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Create v2 wallet
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletApi
   */
  public createWalletV2(options?: RawAxiosRequestConfig) {
    return WalletApiFp(this.configuration)
      .createWalletV2(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * delete wallet by walletId
   * @param {string} walletId id of the wallet
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletApi
   */
  public deleteWallet(walletId: string, options?: RawAxiosRequestConfig) {
    return WalletApiFp(this.configuration)
      .deleteWallet(walletId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * get wallet details using wallet Id.
   * @param {string} walletId id of the wallet
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletApi
   */
  public getWallet(walletId: string, options?: RawAxiosRequestConfig) {
    return WalletApiFp(this.configuration)
      .getWallet(walletId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * lists all wallets
   * @param {ListWalletsDidTypeEnum} [didType]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletApi
   */
  public listWallets(
    didType?: ListWalletsDidTypeEnum,
    options?: RawAxiosRequestConfig,
  ) {
    return WalletApiFp(this.configuration)
      .listWallets(didType, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * signs credential with the wallet
   * @param {string} walletId id of the wallet
   * @param {SignCredentialInputDto} signCredentialInputDto SignCredential
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletApi
   */
  public signCredential(
    walletId: string,
    signCredentialInputDto: SignCredentialInputDto,
    options?: RawAxiosRequestConfig,
  ) {
    return WalletApiFp(this.configuration)
      .signCredential(walletId, signCredentialInputDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * signs credential with the wallet v2
   * @param {string} walletId id of the wallet
   * @param {SignCredentialsJwtInputDto} signCredentialsJwtInputDto signCredentialsJwt
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletApi
   */
  public signCredentialsJwt(
    walletId: string,
    signCredentialsJwtInputDto: SignCredentialsJwtInputDto,
    options?: RawAxiosRequestConfig,
  ) {
    return WalletApiFp(this.configuration)
      .signCredentialsJwt(walletId, signCredentialsJwtInputDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * signs credential with the wallet v2
   * @param {string} walletId id of the wallet
   * @param {SignCredentialsLdpInputDto} signCredentialsLdpInputDto signCredentialsLdp
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletApi
   */
  public signCredentialsLdp(
    walletId: string,
    signCredentialsLdpInputDto: SignCredentialsLdpInputDto,
    options?: RawAxiosRequestConfig,
  ) {
    return WalletApiFp(this.configuration)
      .signCredentialsLdp(walletId, signCredentialsLdpInputDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * signs credential with the wallet v2
   * @param {string} walletId id of the wallet
   * @param {SignCredentialsDm2SdJwtInputDto} signCredentialsDm2SdJwtInputDto SignCredentialsDm1SdJwt
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletApi
   */
  public signCredentialsSdJwt(
    walletId: string,
    signCredentialsDm2SdJwtInputDto: SignCredentialsDm2SdJwtInputDto,
    options?: RawAxiosRequestConfig,
  ) {
    return WalletApiFp(this.configuration)
      .signCredentialsSdJwt(walletId, signCredentialsDm2SdJwtInputDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * signs a jwt token with the wallet
   * @param {string} walletId id of the wallet.
   * @param {SignJwtToken} signJwtToken SignJwtToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletApi
   */
  public signJwtToken(
    walletId: string,
    signJwtToken: SignJwtToken,
    options?: RawAxiosRequestConfig,
  ) {
    return WalletApiFp(this.configuration)
      .signJwtToken(walletId, signJwtToken, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * signs presentation with the wallet
   * @param {string} walletId id of the wallet
   * @param {SignPresentationLdpInputDto} signPresentationLdpInputDto signPresentationLdp
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletApi
   */
  public signPresentationsLdp(
    walletId: string,
    signPresentationLdpInputDto: SignPresentationLdpInputDto,
    options?: RawAxiosRequestConfig,
  ) {
    return WalletApiFp(this.configuration)
      .signPresentationsLdp(walletId, signPresentationLdpInputDto, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * update wallet details using wallet Id.
   * @param {string} walletId id of the wallet
   * @param {UpdateWalletInput} updateWalletInput UpdateWallet
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WalletApi
   */
  public updateWallet(
    walletId: string,
    updateWalletInput: UpdateWalletInput,
    options?: RawAxiosRequestConfig,
  ) {
    return WalletApiFp(this.configuration)
      .updateWallet(walletId, updateWalletInput, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * @export
 */
export const ListWalletsDidTypeEnum = {
  Web: 'WEB',
  Key: 'KEY',
} as const
export type ListWalletsDidTypeEnum =
  (typeof ListWalletsDidTypeEnum)[keyof typeof ListWalletsDidTypeEnum]
