/* tslint:disable */
/* eslint-disable */
/**
 * ConsumerIam
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: info@affinidi.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration'
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios'
import globalAxios from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common'
import type { RequestArgs } from './base'
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  BaseAPI,
  RequiredError,
  operationServerMap,
} from './base'

/**
 *
 * @export
 * @interface ConsumerAuthTokenEndpointInput
 */
export interface ConsumerAuthTokenEndpointInput {
  /**
   *
   * @type {string}
   * @memberof ConsumerAuthTokenEndpointInput
   */
  grant_type: ConsumerAuthTokenEndpointInputGrantTypeEnum
  /**
   *
   * @type {string}
   * @memberof ConsumerAuthTokenEndpointInput
   */
  client_assertion_type: ConsumerAuthTokenEndpointInputClientAssertionTypeEnum
  /**
   *
   * @type {string}
   * @memberof ConsumerAuthTokenEndpointInput
   */
  client_assertion: string
  /**
   *
   * @type {string}
   * @memberof ConsumerAuthTokenEndpointInput
   */
  client_id: string
}

export const ConsumerAuthTokenEndpointInputGrantTypeEnum = {
  ClientCredentials: 'client_credentials',
  AffinidiDelegation: 'affinidi_delegation',
} as const

export type ConsumerAuthTokenEndpointInputGrantTypeEnum =
  (typeof ConsumerAuthTokenEndpointInputGrantTypeEnum)[keyof typeof ConsumerAuthTokenEndpointInputGrantTypeEnum]
export const ConsumerAuthTokenEndpointInputClientAssertionTypeEnum = {
  UrnIetfParamsOauthClientAssertionTypeJwtBearer:
    'urn:ietf:params:oauth:client-assertion-type:jwt-bearer',
  UrnIetfParamsOauthDelegationAssertionTypeJwtBearer:
    'urn:ietf:params:oauth:delegation-assertion-type:jwt-bearer',
} as const

export type ConsumerAuthTokenEndpointInputClientAssertionTypeEnum =
  (typeof ConsumerAuthTokenEndpointInputClientAssertionTypeEnum)[keyof typeof ConsumerAuthTokenEndpointInputClientAssertionTypeEnum]

/**
 *
 * @export
 * @interface ConsumerAuthTokenEndpointOutput
 */
export interface ConsumerAuthTokenEndpointOutput {
  /**
   * The access token issued by the authorization server.
   * @type {string}
   * @memberof ConsumerAuthTokenEndpointOutput
   */
  access_token?: string
  /**
   * The lifetime in seconds of the access token. For example, the value \"3600\" denotes that the access token will expire in one hour from the time the response was generated.
   * @type {number}
   * @memberof ConsumerAuthTokenEndpointOutput
   */
  expires_in?: number
  /**
   * The scope of the access token
   * @type {string}
   * @memberof ConsumerAuthTokenEndpointOutput
   */
  scope?: string
  /**
   * The type of the token issued
   * @type {string}
   * @memberof ConsumerAuthTokenEndpointOutput
   */
  token_type?: string
}
/**
 *
 * @export
 * @interface CorsConsumerAuthTokenEndpointOK
 */
export interface CorsConsumerAuthTokenEndpointOK {
  /**
   *
   * @type {string}
   * @memberof CorsConsumerAuthTokenEndpointOK
   */
  corsConsumerAuthTokenEndpointOk?: string
}
/**
 *
 * @export
 * @interface GrantAccessInput
 */
export interface GrantAccessInput {
  /**
   * List of permissions
   * @type {Array<Permission>}
   * @memberof GrantAccessInput
   */
  permissions: Array<Permission>
}
/**
 *
 * @export
 * @interface GrantAccessOutput
 */
export interface GrantAccessOutput {
  /**
   *
   * @type {boolean}
   * @memberof GrantAccessOutput
   */
  success: boolean
  /**
   * Unique identifier for the access grant
   * @type {string}
   * @memberof GrantAccessOutput
   */
  grantId?: string
}
/**
 *
 * @export
 * @interface InvalidDIDError
 */
export interface InvalidDIDError {
  /**
   *
   * @type {string}
   * @memberof InvalidDIDError
   */
  name: InvalidDIDErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof InvalidDIDError
   */
  message: InvalidDIDErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof InvalidDIDError
   */
  httpStatusCode: InvalidDIDErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof InvalidDIDError
   */
  traceId: string
  /**
   *
   * @type {Array<InvalidJwtTokenErrorDetailsInner>}
   * @memberof InvalidDIDError
   */
  details?: Array<InvalidJwtTokenErrorDetailsInner>
}

export const InvalidDIDErrorNameEnum = {
  InvalidDidError: 'InvalidDIDError',
} as const

export type InvalidDIDErrorNameEnum =
  (typeof InvalidDIDErrorNameEnum)[keyof typeof InvalidDIDErrorNameEnum]
export const InvalidDIDErrorMessageEnum = {
  UnableToResolveDidMethod: 'Unable to resolve DID method',
} as const

export type InvalidDIDErrorMessageEnum =
  (typeof InvalidDIDErrorMessageEnum)[keyof typeof InvalidDIDErrorMessageEnum]
export const InvalidDIDErrorHttpStatusCodeEnum = {
  NUMBER_400: 400,
} as const

export type InvalidDIDErrorHttpStatusCodeEnum =
  (typeof InvalidDIDErrorHttpStatusCodeEnum)[keyof typeof InvalidDIDErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface InvalidJwtTokenError
 */
export interface InvalidJwtTokenError {
  /**
   *
   * @type {string}
   * @memberof InvalidJwtTokenError
   */
  name: InvalidJwtTokenErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof InvalidJwtTokenError
   */
  message: InvalidJwtTokenErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof InvalidJwtTokenError
   */
  httpStatusCode: InvalidJwtTokenErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof InvalidJwtTokenError
   */
  traceId: string
  /**
   *
   * @type {Array<InvalidJwtTokenErrorDetailsInner>}
   * @memberof InvalidJwtTokenError
   */
  details?: Array<InvalidJwtTokenErrorDetailsInner>
}

export const InvalidJwtTokenErrorNameEnum = {
  InvalidJwtTokenError: 'InvalidJwtTokenError',
} as const

export type InvalidJwtTokenErrorNameEnum =
  (typeof InvalidJwtTokenErrorNameEnum)[keyof typeof InvalidJwtTokenErrorNameEnum]
export const InvalidJwtTokenErrorMessageEnum = {
  JwtTokenIsInvalid: 'JWT token is invalid',
} as const

export type InvalidJwtTokenErrorMessageEnum =
  (typeof InvalidJwtTokenErrorMessageEnum)[keyof typeof InvalidJwtTokenErrorMessageEnum]
export const InvalidJwtTokenErrorHttpStatusCodeEnum = {
  NUMBER_401: 401,
} as const

export type InvalidJwtTokenErrorHttpStatusCodeEnum =
  (typeof InvalidJwtTokenErrorHttpStatusCodeEnum)[keyof typeof InvalidJwtTokenErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface InvalidJwtTokenErrorDetailsInner
 */
export interface InvalidJwtTokenErrorDetailsInner {
  /**
   *
   * @type {string}
   * @memberof InvalidJwtTokenErrorDetailsInner
   */
  issue: string
  /**
   *
   * @type {string}
   * @memberof InvalidJwtTokenErrorDetailsInner
   */
  field?: string
  /**
   *
   * @type {string}
   * @memberof InvalidJwtTokenErrorDetailsInner
   */
  value?: string
  /**
   *
   * @type {string}
   * @memberof InvalidJwtTokenErrorDetailsInner
   */
  location?: string
}
/**
 *
 * @export
 * @interface InvalidParameterError
 */
export interface InvalidParameterError {
  /**
   *
   * @type {string}
   * @memberof InvalidParameterError
   */
  name: InvalidParameterErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof InvalidParameterError
   */
  message: InvalidParameterErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof InvalidParameterError
   */
  httpStatusCode: InvalidParameterErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof InvalidParameterError
   */
  traceId: string
  /**
   *
   * @type {Array<InvalidJwtTokenErrorDetailsInner>}
   * @memberof InvalidParameterError
   */
  details?: Array<InvalidJwtTokenErrorDetailsInner>
}

export const InvalidParameterErrorNameEnum = {
  InvalidParameterError: 'InvalidParameterError',
} as const

export type InvalidParameterErrorNameEnum =
  (typeof InvalidParameterErrorNameEnum)[keyof typeof InvalidParameterErrorNameEnum]
export const InvalidParameterErrorMessageEnum = {
  InvalidParameter: 'Invalid parameter',
} as const

export type InvalidParameterErrorMessageEnum =
  (typeof InvalidParameterErrorMessageEnum)[keyof typeof InvalidParameterErrorMessageEnum]
export const InvalidParameterErrorHttpStatusCodeEnum = {
  NUMBER_400: 400,
} as const

export type InvalidParameterErrorHttpStatusCodeEnum =
  (typeof InvalidParameterErrorHttpStatusCodeEnum)[keyof typeof InvalidParameterErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface JsonWebKeyDto
 */
export interface JsonWebKeyDto {
  /**
   *
   * @type {string}
   * @memberof JsonWebKeyDto
   */
  kid: string
  /**
   *
   * @type {string}
   * @memberof JsonWebKeyDto
   */
  kty: string
  /**
   *
   * @type {string}
   * @memberof JsonWebKeyDto
   */
  n?: string
  /**
   *
   * @type {string}
   * @memberof JsonWebKeyDto
   */
  e?: string
  /**
   *
   * @type {string}
   * @memberof JsonWebKeyDto
   */
  x?: string
  /**
   *
   * @type {string}
   * @memberof JsonWebKeyDto
   */
  y?: string
  /**
   *
   * @type {string}
   * @memberof JsonWebKeyDto
   */
  crv?: string
  /**
   *
   * @type {string}
   * @memberof JsonWebKeyDto
   */
  alg: string
  /**
   *
   * @type {string}
   * @memberof JsonWebKeyDto
   */
  use: string
}
/**
 *
 * @export
 * @interface JsonWebKeySetDto
 */
export interface JsonWebKeySetDto {
  /**
   *
   * @type {Array<JsonWebKeyDto>}
   * @memberof JsonWebKeySetDto
   */
  keys: Array<JsonWebKeyDto>
}
/**
 *
 * @export
 * @interface Permission
 */
export interface Permission {
  /**
   *
   * @type {Array<RightsEnum>}
   * @memberof Permission
   */
  rights: Array<RightsEnum>
  /**
   *
   * @type {Array<string>}
   * @memberof Permission
   */
  nodeIds: Array<string>
}
/**
 *
 * @export
 * @enum {string}
 */

export const RightsEnum = {
  VfsRead: 'vfs-read',
  VfsWrite: 'vfs-write',
} as const

export type RightsEnum = (typeof RightsEnum)[keyof typeof RightsEnum]

/**
 *
 * @export
 * @interface UnauthorizedError
 */
export interface UnauthorizedError {
  /**
   *
   * @type {string}
   * @memberof UnauthorizedError
   */
  name: UnauthorizedErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof UnauthorizedError
   */
  message: UnauthorizedErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof UnauthorizedError
   */
  httpStatusCode: UnauthorizedErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof UnauthorizedError
   */
  traceId: string
  /**
   *
   * @type {Array<InvalidJwtTokenErrorDetailsInner>}
   * @memberof UnauthorizedError
   */
  details?: Array<InvalidJwtTokenErrorDetailsInner>
}

export const UnauthorizedErrorNameEnum = {
  UnauthorizedError: 'UnauthorizedError',
} as const

export type UnauthorizedErrorNameEnum =
  (typeof UnauthorizedErrorNameEnum)[keyof typeof UnauthorizedErrorNameEnum]
export const UnauthorizedErrorMessageEnum = {
  Unauthorized: 'Unauthorized',
} as const

export type UnauthorizedErrorMessageEnum =
  (typeof UnauthorizedErrorMessageEnum)[keyof typeof UnauthorizedErrorMessageEnum]
export const UnauthorizedErrorHttpStatusCodeEnum = {
  NUMBER_403: 403,
} as const

export type UnauthorizedErrorHttpStatusCodeEnum =
  (typeof UnauthorizedErrorHttpStatusCodeEnum)[keyof typeof UnauthorizedErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface UnexpectedError
 */
export interface UnexpectedError {
  /**
   *
   * @type {string}
   * @memberof UnexpectedError
   */
  name: UnexpectedErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof UnexpectedError
   */
  message: UnexpectedErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof UnexpectedError
   */
  httpStatusCode: UnexpectedErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof UnexpectedError
   */
  traceId: string
  /**
   *
   * @type {Array<InvalidJwtTokenErrorDetailsInner>}
   * @memberof UnexpectedError
   */
  details?: Array<InvalidJwtTokenErrorDetailsInner>
}

export const UnexpectedErrorNameEnum = {
  UnexpectedError: 'UnexpectedError',
} as const

export type UnexpectedErrorNameEnum =
  (typeof UnexpectedErrorNameEnum)[keyof typeof UnexpectedErrorNameEnum]
export const UnexpectedErrorMessageEnum = {
  UnexpectedErrorOccurred: 'Unexpected Error Occurred.',
} as const

export type UnexpectedErrorMessageEnum =
  (typeof UnexpectedErrorMessageEnum)[keyof typeof UnexpectedErrorMessageEnum]
export const UnexpectedErrorHttpStatusCodeEnum = {
  NUMBER_500: 500,
} as const

export type UnexpectedErrorHttpStatusCodeEnum =
  (typeof UnexpectedErrorHttpStatusCodeEnum)[keyof typeof UnexpectedErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface UpdateAccessInput
 */
export interface UpdateAccessInput {
  /**
   * List of permissions
   * @type {Array<Permission>}
   * @memberof UpdateAccessInput
   */
  permissions: Array<Permission>
}
/**
 *
 * @export
 * @interface UpdateAccessOutput
 */
export interface UpdateAccessOutput {
  /**
   *
   * @type {boolean}
   * @memberof UpdateAccessOutput
   */
  success: boolean
}

/**
 * AuthzApi - axios parameter creator
 * @export
 */
export const AuthzApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * deleteAccessVfs
     * @summary delete access of granteeDid
     * @param {string} granteeDid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAccessVfs: async (
      granteeDid: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'granteeDid' is not null or undefined
      assertParamExists('deleteAccessVfs', 'granteeDid', granteeDid)
      const localVarPath = `/v1/authz/vfs/access/{granteeDid}`.replace(
        `{${'granteeDid'}}`,
        encodeURIComponent(String(granteeDid)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ConsumerTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Grants access rights to a subject for the virtual file system
     * @summary Grant access to the virtual file system
     * @param {string} granteeDid
     * @param {GrantAccessInput} grantAccessInput Grant access to virtual file system
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    grantAccessVfs: async (
      granteeDid: string,
      grantAccessInput: GrantAccessInput,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'granteeDid' is not null or undefined
      assertParamExists('grantAccessVfs', 'granteeDid', granteeDid)
      // verify required parameter 'grantAccessInput' is not null or undefined
      assertParamExists('grantAccessVfs', 'grantAccessInput', grantAccessInput)
      const localVarPath = `/v1/authz/vfs/access/{granteeDid}`.replace(
        `{${'granteeDid'}}`,
        encodeURIComponent(String(granteeDid)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ConsumerTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        grantAccessInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * updateAccessVfs
     * @summary Update access of granteeDid
     * @param {string} granteeDid
     * @param {UpdateAccessInput} updateAccessInput update access to virtual file system
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAccessVfs: async (
      granteeDid: string,
      updateAccessInput: UpdateAccessInput,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'granteeDid' is not null or undefined
      assertParamExists('updateAccessVfs', 'granteeDid', granteeDid)
      // verify required parameter 'updateAccessInput' is not null or undefined
      assertParamExists(
        'updateAccessVfs',
        'updateAccessInput',
        updateAccessInput,
      )
      const localVarPath = `/v1/authz/vfs/access/{granteeDid}`.replace(
        `{${'granteeDid'}}`,
        encodeURIComponent(String(granteeDid)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ConsumerTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateAccessInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * AuthzApi - functional programming interface
 * @export
 */
export const AuthzApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AuthzApiAxiosParamCreator(configuration)
  return {
    /**
     * deleteAccessVfs
     * @summary delete access of granteeDid
     * @param {string} granteeDid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteAccessVfs(
      granteeDid: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccessVfs(
        granteeDid,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['AuthzApi.deleteAccessVfs']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Grants access rights to a subject for the virtual file system
     * @summary Grant access to the virtual file system
     * @param {string} granteeDid
     * @param {GrantAccessInput} grantAccessInput Grant access to virtual file system
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async grantAccessVfs(
      granteeDid: string,
      grantAccessInput: GrantAccessInput,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<GrantAccessOutput>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.grantAccessVfs(
        granteeDid,
        grantAccessInput,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['AuthzApi.grantAccessVfs']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * updateAccessVfs
     * @summary Update access of granteeDid
     * @param {string} granteeDid
     * @param {UpdateAccessInput} updateAccessInput update access to virtual file system
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateAccessVfs(
      granteeDid: string,
      updateAccessInput: UpdateAccessInput,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UpdateAccessOutput>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateAccessVfs(
        granteeDid,
        updateAccessInput,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['AuthzApi.updateAccessVfs']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * AuthzApi - factory interface
 * @export
 */
export const AuthzApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AuthzApiFp(configuration)
  return {
    /**
     * deleteAccessVfs
     * @summary delete access of granteeDid
     * @param {string} granteeDid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAccessVfs(
      granteeDid: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .deleteAccessVfs(granteeDid, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Grants access rights to a subject for the virtual file system
     * @summary Grant access to the virtual file system
     * @param {string} granteeDid
     * @param {GrantAccessInput} grantAccessInput Grant access to virtual file system
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    grantAccessVfs(
      granteeDid: string,
      grantAccessInput: GrantAccessInput,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GrantAccessOutput> {
      return localVarFp
        .grantAccessVfs(granteeDid, grantAccessInput, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * updateAccessVfs
     * @summary Update access of granteeDid
     * @param {string} granteeDid
     * @param {UpdateAccessInput} updateAccessInput update access to virtual file system
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAccessVfs(
      granteeDid: string,
      updateAccessInput: UpdateAccessInput,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<UpdateAccessOutput> {
      return localVarFp
        .updateAccessVfs(granteeDid, updateAccessInput, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * AuthzApi - object-oriented interface
 * @export
 * @class AuthzApi
 * @extends {BaseAPI}
 */
export class AuthzApi extends BaseAPI {
  /**
   * deleteAccessVfs
   * @summary delete access of granteeDid
   * @param {string} granteeDid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthzApi
   */
  public deleteAccessVfs(granteeDid: string, options?: RawAxiosRequestConfig) {
    return AuthzApiFp(this.configuration)
      .deleteAccessVfs(granteeDid, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Grants access rights to a subject for the virtual file system
   * @summary Grant access to the virtual file system
   * @param {string} granteeDid
   * @param {GrantAccessInput} grantAccessInput Grant access to virtual file system
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthzApi
   */
  public grantAccessVfs(
    granteeDid: string,
    grantAccessInput: GrantAccessInput,
    options?: RawAxiosRequestConfig,
  ) {
    return AuthzApiFp(this.configuration)
      .grantAccessVfs(granteeDid, grantAccessInput, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * updateAccessVfs
   * @summary Update access of granteeDid
   * @param {string} granteeDid
   * @param {UpdateAccessInput} updateAccessInput update access to virtual file system
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthzApi
   */
  public updateAccessVfs(
    granteeDid: string,
    updateAccessInput: UpdateAccessInput,
    options?: RawAxiosRequestConfig,
  ) {
    return AuthzApiFp(this.configuration)
      .updateAccessVfs(granteeDid, updateAccessInput, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ConsumerAuthApi - axios parameter creator
 * @export
 */
export const ConsumerAuthApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary The Consumer OAuth 2.0 Token Endpoint
     * @param {ConsumerAuthTokenEndpointInput} consumerAuthTokenEndpointInput ConsumerAuthTokenEndpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    consumerAuthTokenEndpoint: async (
      consumerAuthTokenEndpointInput: ConsumerAuthTokenEndpointInput,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'consumerAuthTokenEndpointInput' is not null or undefined
      assertParamExists(
        'consumerAuthTokenEndpoint',
        'consumerAuthTokenEndpointInput',
        consumerAuthTokenEndpointInput,
      )
      const localVarPath = `/v1/consumer/oauth2/token`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        consumerAuthTokenEndpointInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ConsumerAuthApi - functional programming interface
 * @export
 */
export const ConsumerAuthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ConsumerAuthApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary The Consumer OAuth 2.0 Token Endpoint
     * @param {ConsumerAuthTokenEndpointInput} consumerAuthTokenEndpointInput ConsumerAuthTokenEndpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async consumerAuthTokenEndpoint(
      consumerAuthTokenEndpointInput: ConsumerAuthTokenEndpointInput,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ConsumerAuthTokenEndpointOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.consumerAuthTokenEndpoint(
          consumerAuthTokenEndpointInput,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ConsumerAuthApi.consumerAuthTokenEndpoint']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * ConsumerAuthApi - factory interface
 * @export
 */
export const ConsumerAuthApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ConsumerAuthApiFp(configuration)
  return {
    /**
     *
     * @summary The Consumer OAuth 2.0 Token Endpoint
     * @param {ConsumerAuthTokenEndpointInput} consumerAuthTokenEndpointInput ConsumerAuthTokenEndpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    consumerAuthTokenEndpoint(
      consumerAuthTokenEndpointInput: ConsumerAuthTokenEndpointInput,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ConsumerAuthTokenEndpointOutput> {
      return localVarFp
        .consumerAuthTokenEndpoint(consumerAuthTokenEndpointInput, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ConsumerAuthApi - object-oriented interface
 * @export
 * @class ConsumerAuthApi
 * @extends {BaseAPI}
 */
export class ConsumerAuthApi extends BaseAPI {
  /**
   *
   * @summary The Consumer OAuth 2.0 Token Endpoint
   * @param {ConsumerAuthTokenEndpointInput} consumerAuthTokenEndpointInput ConsumerAuthTokenEndpoint
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConsumerAuthApi
   */
  public consumerAuthTokenEndpoint(
    consumerAuthTokenEndpointInput: ConsumerAuthTokenEndpointInput,
    options?: RawAxiosRequestConfig,
  ) {
    return ConsumerAuthApiFp(this.configuration)
      .consumerAuthTokenEndpoint(consumerAuthTokenEndpointInput, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * WellKnownApi - axios parameter creator
 * @export
 */
export const WellKnownApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWellKnownJwks: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/.well-known/jwks.json`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * WellKnownApi - functional programming interface
 * @export
 */
export const WellKnownApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = WellKnownApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getWellKnownJwks(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<JsonWebKeySetDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getWellKnownJwks(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['WellKnownApi.getWellKnownJwks']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * WellKnownApi - factory interface
 * @export
 */
export const WellKnownApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = WellKnownApiFp(configuration)
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWellKnownJwks(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<JsonWebKeySetDto> {
      return localVarFp
        .getWellKnownJwks(options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * WellKnownApi - object-oriented interface
 * @export
 * @class WellKnownApi
 * @extends {BaseAPI}
 */
export class WellKnownApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WellKnownApi
   */
  public getWellKnownJwks(options?: RawAxiosRequestConfig) {
    return WellKnownApiFp(this.configuration)
      .getWellKnownJwks(options)
      .then((request) => request(this.axios, this.basePath))
  }
}
