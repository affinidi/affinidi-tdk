/* tslint:disable */
/* eslint-disable */
/**
 * Iam
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: info@affinidi.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration'
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios'
import globalAxios from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common'
import type { RequestArgs } from './base'
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  BaseAPI,
  RequiredError,
  operationServerMap,
} from './base'

/**
 *
 * @export
 * @interface ActionForbiddenError
 */
export interface ActionForbiddenError {
  /**
   *
   * @type {string}
   * @memberof ActionForbiddenError
   */
  name: ActionForbiddenErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof ActionForbiddenError
   */
  message: ActionForbiddenErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof ActionForbiddenError
   */
  httpStatusCode: ActionForbiddenErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof ActionForbiddenError
   */
  traceId: string
  /**
   *
   * @type {Array<ServiceErrorResponseDetailsInner>}
   * @memberof ActionForbiddenError
   */
  details?: Array<ServiceErrorResponseDetailsInner>
}

export const ActionForbiddenErrorNameEnum = {
  ActionForbiddenError: 'ActionForbiddenError',
} as const

export type ActionForbiddenErrorNameEnum =
  (typeof ActionForbiddenErrorNameEnum)[keyof typeof ActionForbiddenErrorNameEnum]
export const ActionForbiddenErrorMessageEnum = {
  PrincipalCanNotExecuteActionOnGivenResource:
    'Principal can not execute action on given resource',
} as const

export type ActionForbiddenErrorMessageEnum =
  (typeof ActionForbiddenErrorMessageEnum)[keyof typeof ActionForbiddenErrorMessageEnum]
export const ActionForbiddenErrorHttpStatusCodeEnum = {
  NUMBER_403: 403,
} as const

export type ActionForbiddenErrorHttpStatusCodeEnum =
  (typeof ActionForbiddenErrorHttpStatusCodeEnum)[keyof typeof ActionForbiddenErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface AddUserToProjectInput
 */
export interface AddUserToProjectInput {
  /**
   *
   * @type {string}
   * @memberof AddUserToProjectInput
   */
  principalId: string
  /**
   *
   * @type {string}
   * @memberof AddUserToProjectInput
   */
  principalType: string
}
/**
 *
 * @export
 * @interface ConsumerAuthTokenEndpointInput
 */
export interface ConsumerAuthTokenEndpointInput {
  [key: string]: any

  /**
   *
   * @type {string}
   * @memberof ConsumerAuthTokenEndpointInput
   */
  grant_type: string
  /**
   *
   * @type {string}
   * @memberof ConsumerAuthTokenEndpointInput
   */
  code?: string
  /**
   *
   * @type {string}
   * @memberof ConsumerAuthTokenEndpointInput
   */
  refresh_token?: string
  /**
   *
   * @type {string}
   * @memberof ConsumerAuthTokenEndpointInput
   */
  redirect_uri?: string
  /**
   *
   * @type {string}
   * @memberof ConsumerAuthTokenEndpointInput
   */
  client_id?: string
}
/**
 *
 * @export
 * @interface ConsumerAuthTokenEndpointOutput
 */
export interface ConsumerAuthTokenEndpointOutput {
  /**
   * The access token issued by the authorization server.
   * @type {string}
   * @memberof ConsumerAuthTokenEndpointOutput
   */
  access_token?: string
  /**
   * The lifetime in seconds of the access token. For example, the value \"3600\" denotes that the access token will expire in one hour from the time the response was generated.
   * @type {number}
   * @memberof ConsumerAuthTokenEndpointOutput
   */
  expires_in?: number
  /**
   * To retrieve a refresh token request the id_token scope.
   * @type {number}
   * @memberof ConsumerAuthTokenEndpointOutput
   */
  id_token?: number
  /**
   * The refresh token, which can be used to obtain new access tokens. To retrieve it add the scope \"offline\" to your access token request.
   * @type {string}
   * @memberof ConsumerAuthTokenEndpointOutput
   */
  refresh_token?: string
  /**
   * The scope of the access token
   * @type {string}
   * @memberof ConsumerAuthTokenEndpointOutput
   */
  scope?: string
  /**
   * The type of the token issued
   * @type {string}
   * @memberof ConsumerAuthTokenEndpointOutput
   */
  token_type?: string
}
/**
 *
 * @export
 * @interface CorsConsumerAuthTokenEndpointOK
 */
export interface CorsConsumerAuthTokenEndpointOK {
  /**
   *
   * @type {string}
   * @memberof CorsConsumerAuthTokenEndpointOK
   */
  corsConsumerAuthTokenEndpointOk?: string
}
/**
 *
 * @export
 * @interface CreateProjectInput
 */
export interface CreateProjectInput {
  /**
   *
   * @type {string}
   * @memberof CreateProjectInput
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof CreateProjectInput
   */
  description?: string
}
/**
 *
 * @export
 * @interface CreateProjectScopedTokenInput
 */
export interface CreateProjectScopedTokenInput {
  /**
   *
   * @type {string}
   * @memberof CreateProjectScopedTokenInput
   */
  projectId: string
}
/**
 *
 * @export
 * @interface CreateProjectScopedTokenOutput
 */
export interface CreateProjectScopedTokenOutput {
  /**
   *
   * @type {string}
   * @memberof CreateProjectScopedTokenOutput
   */
  accessToken: string
  /**
   *
   * @type {number}
   * @memberof CreateProjectScopedTokenOutput
   */
  expiresIn: number
  /**
   *
   * @type {string}
   * @memberof CreateProjectScopedTokenOutput
   */
  scope: string
}
/**
 *
 * @export
 * @interface CreateTokenInput
 */
export interface CreateTokenInput {
  /**
   *
   * @type {string}
   * @memberof CreateTokenInput
   */
  name: string
  /**
   *
   * @type {TokenAuthenticationMethodDto}
   * @memberof CreateTokenInput
   */
  authenticationMethod: TokenAuthenticationMethodDto
  /**
   *
   * @type {string}
   * @memberof CreateTokenInput
   */
  description?: string
}
/**
 *
 * @export
 * @interface GetWellKnownDidOK
 */
export interface GetWellKnownDidOK {
  [key: string]: any
}
/**
 *
 * @export
 * @interface InvalidDIDError
 */
export interface InvalidDIDError {
  /**
   *
   * @type {string}
   * @memberof InvalidDIDError
   */
  name: InvalidDIDErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof InvalidDIDError
   */
  message: InvalidDIDErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof InvalidDIDError
   */
  httpStatusCode: InvalidDIDErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof InvalidDIDError
   */
  traceId: string
  /**
   *
   * @type {Array<ServiceErrorResponseDetailsInner>}
   * @memberof InvalidDIDError
   */
  details?: Array<ServiceErrorResponseDetailsInner>
}

export const InvalidDIDErrorNameEnum = {
  InvalidDidError: 'InvalidDIDError',
} as const

export type InvalidDIDErrorNameEnum =
  (typeof InvalidDIDErrorNameEnum)[keyof typeof InvalidDIDErrorNameEnum]
export const InvalidDIDErrorMessageEnum = {
  UnableToResolveDidMethodInvalidPublicKey:
    'unable to resolve DID method. Invalid public key',
} as const

export type InvalidDIDErrorMessageEnum =
  (typeof InvalidDIDErrorMessageEnum)[keyof typeof InvalidDIDErrorMessageEnum]
export const InvalidDIDErrorHttpStatusCodeEnum = {
  NUMBER_400: 400,
} as const

export type InvalidDIDErrorHttpStatusCodeEnum =
  (typeof InvalidDIDErrorHttpStatusCodeEnum)[keyof typeof InvalidDIDErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface InvalidDidError
 */
export interface InvalidDidError {
  /**
   *
   * @type {string}
   * @memberof InvalidDidError
   */
  name: InvalidDidErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof InvalidDidError
   */
  message: InvalidDidErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof InvalidDidError
   */
  httpStatusCode: InvalidDidErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof InvalidDidError
   */
  traceId: string
  /**
   *
   * @type {Array<ServiceErrorResponseDetailsInner>}
   * @memberof InvalidDidError
   */
  details?: Array<ServiceErrorResponseDetailsInner>
}

export const InvalidDidErrorNameEnum = {
  InvalidDidError: 'InvalidDidError',
} as const

export type InvalidDidErrorNameEnum =
  (typeof InvalidDidErrorNameEnum)[keyof typeof InvalidDidErrorNameEnum]
export const InvalidDidErrorMessageEnum = {
  UnableToResolveDidMethodInvalidPublicKey:
    'Unable to resolve DID method. Invalid public key',
} as const

export type InvalidDidErrorMessageEnum =
  (typeof InvalidDidErrorMessageEnum)[keyof typeof InvalidDidErrorMessageEnum]
export const InvalidDidErrorHttpStatusCodeEnum = {
  NUMBER_400: 400,
} as const

export type InvalidDidErrorHttpStatusCodeEnum =
  (typeof InvalidDidErrorHttpStatusCodeEnum)[keyof typeof InvalidDidErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface InvalidJwtTokenError
 */
export interface InvalidJwtTokenError {
  /**
   *
   * @type {string}
   * @memberof InvalidJwtTokenError
   */
  name: InvalidJwtTokenErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof InvalidJwtTokenError
   */
  message: InvalidJwtTokenErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof InvalidJwtTokenError
   */
  httpStatusCode: InvalidJwtTokenErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof InvalidJwtTokenError
   */
  traceId: string
  /**
   *
   * @type {Array<ServiceErrorResponseDetailsInner>}
   * @memberof InvalidJwtTokenError
   */
  details?: Array<ServiceErrorResponseDetailsInner>
}

export const InvalidJwtTokenErrorNameEnum = {
  InvalidJwtTokenError: 'InvalidJwtTokenError',
} as const

export type InvalidJwtTokenErrorNameEnum =
  (typeof InvalidJwtTokenErrorNameEnum)[keyof typeof InvalidJwtTokenErrorNameEnum]
export const InvalidJwtTokenErrorMessageEnum = {
  JwtTokenIsInvalid: 'JWT token is invalid',
} as const

export type InvalidJwtTokenErrorMessageEnum =
  (typeof InvalidJwtTokenErrorMessageEnum)[keyof typeof InvalidJwtTokenErrorMessageEnum]
export const InvalidJwtTokenErrorHttpStatusCodeEnum = {
  NUMBER_401: 401,
} as const

export type InvalidJwtTokenErrorHttpStatusCodeEnum =
  (typeof InvalidJwtTokenErrorHttpStatusCodeEnum)[keyof typeof InvalidJwtTokenErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface InvalidParameterError
 */
export interface InvalidParameterError {
  /**
   *
   * @type {string}
   * @memberof InvalidParameterError
   */
  name: InvalidParameterErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof InvalidParameterError
   */
  message: InvalidParameterErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof InvalidParameterError
   */
  httpStatusCode: InvalidParameterErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof InvalidParameterError
   */
  traceId: string
  /**
   *
   * @type {Array<ServiceErrorResponseDetailsInner>}
   * @memberof InvalidParameterError
   */
  details?: Array<ServiceErrorResponseDetailsInner>
}

export const InvalidParameterErrorNameEnum = {
  InvalidParameterError: 'InvalidParameterError',
} as const

export type InvalidParameterErrorNameEnum =
  (typeof InvalidParameterErrorNameEnum)[keyof typeof InvalidParameterErrorNameEnum]
export const InvalidParameterErrorMessageEnum = {
  InvalidParameterParam: 'Invalid parameter: ${param}.',
} as const

export type InvalidParameterErrorMessageEnum =
  (typeof InvalidParameterErrorMessageEnum)[keyof typeof InvalidParameterErrorMessageEnum]
export const InvalidParameterErrorHttpStatusCodeEnum = {
  NUMBER_400: 400,
} as const

export type InvalidParameterErrorHttpStatusCodeEnum =
  (typeof InvalidParameterErrorHttpStatusCodeEnum)[keyof typeof InvalidParameterErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface JsonWebKeyDto
 */
export interface JsonWebKeyDto {
  /**
   *
   * @type {string}
   * @memberof JsonWebKeyDto
   */
  kid: string
  /**
   *
   * @type {string}
   * @memberof JsonWebKeyDto
   */
  kty: string
  /**
   *
   * @type {string}
   * @memberof JsonWebKeyDto
   */
  n?: string
  /**
   *
   * @type {string}
   * @memberof JsonWebKeyDto
   */
  e?: string
  /**
   *
   * @type {string}
   * @memberof JsonWebKeyDto
   */
  x?: string
  /**
   *
   * @type {string}
   * @memberof JsonWebKeyDto
   */
  y?: string
  /**
   *
   * @type {string}
   * @memberof JsonWebKeyDto
   */
  crv?: string
  /**
   *
   * @type {string}
   * @memberof JsonWebKeyDto
   */
  alg: string
  /**
   *
   * @type {string}
   * @memberof JsonWebKeyDto
   */
  use: string
}
/**
 *
 * @export
 * @interface JsonWebKeySetDto
 */
export interface JsonWebKeySetDto {
  /**
   *
   * @type {Array<JsonWebKeyDto>}
   * @memberof JsonWebKeySetDto
   */
  keys: Array<JsonWebKeyDto>
}
/**
 *
 * @export
 * @interface NotFoundError
 */
export interface NotFoundError {
  /**
   *
   * @type {string}
   * @memberof NotFoundError
   */
  name: NotFoundErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof NotFoundError
   */
  message: NotFoundErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof NotFoundError
   */
  httpStatusCode: NotFoundErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof NotFoundError
   */
  traceId: string
  /**
   *
   * @type {Array<ServiceErrorResponseDetailsInner>}
   * @memberof NotFoundError
   */
  details?: Array<ServiceErrorResponseDetailsInner>
}

export const NotFoundErrorNameEnum = {
  NotFoundError: 'NotFoundError',
} as const

export type NotFoundErrorNameEnum =
  (typeof NotFoundErrorNameEnum)[keyof typeof NotFoundErrorNameEnum]
export const NotFoundErrorMessageEnum = {
  NotFoundParam: 'Not found: ${param}.',
} as const

export type NotFoundErrorMessageEnum =
  (typeof NotFoundErrorMessageEnum)[keyof typeof NotFoundErrorMessageEnum]
export const NotFoundErrorHttpStatusCodeEnum = {
  NUMBER_404: 404,
} as const

export type NotFoundErrorHttpStatusCodeEnum =
  (typeof NotFoundErrorHttpStatusCodeEnum)[keyof typeof NotFoundErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface PolicyDto
 */
export interface PolicyDto {
  /**
   *
   * @type {string}
   * @memberof PolicyDto
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof PolicyDto
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof PolicyDto
   */
  principalId?: string
  /**
   *
   * @type {string}
   * @memberof PolicyDto
   */
  projectId?: string
  /**
   *
   * @type {string}
   * @memberof PolicyDto
   */
  version: string
  /**
   *
   * @type {Array<PolicyStatementDto>}
   * @memberof PolicyDto
   */
  statement: Array<PolicyStatementDto>
}
/**
 *
 * @export
 * @interface PolicyStatementDto
 */
export interface PolicyStatementDto {
  /**
   *
   * @type {Array<string>}
   * @memberof PolicyStatementDto
   */
  action: Array<string>
  /**
   *
   * @type {string}
   * @memberof PolicyStatementDto
   */
  effect: string
  /**
   *
   * @type {Array<string>}
   * @memberof PolicyStatementDto
   */
  principal: Array<string>
  /**
   *
   * @type {Array<string>}
   * @memberof PolicyStatementDto
   */
  resource: Array<string>
}
/**
 *
 * @export
 * @interface PrincipalCannotBeDeletedError
 */
export interface PrincipalCannotBeDeletedError {
  /**
   *
   * @type {string}
   * @memberof PrincipalCannotBeDeletedError
   */
  name: PrincipalCannotBeDeletedErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof PrincipalCannotBeDeletedError
   */
  message: PrincipalCannotBeDeletedErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof PrincipalCannotBeDeletedError
   */
  httpStatusCode: PrincipalCannotBeDeletedErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof PrincipalCannotBeDeletedError
   */
  traceId: string
  /**
   *
   * @type {Array<ServiceErrorResponseDetailsInner>}
   * @memberof PrincipalCannotBeDeletedError
   */
  details?: Array<ServiceErrorResponseDetailsInner>
}

export const PrincipalCannotBeDeletedErrorNameEnum = {
  PrincipalCannotBeDeletedError: 'PrincipalCannotBeDeletedError',
} as const

export type PrincipalCannotBeDeletedErrorNameEnum =
  (typeof PrincipalCannotBeDeletedErrorNameEnum)[keyof typeof PrincipalCannotBeDeletedErrorNameEnum]
export const PrincipalCannotBeDeletedErrorMessageEnum = {
  CannotDeleteOwnRecordFromTheProjectWithTheSamePrincipalId:
    'Cannot delete own record from the project with the same principalId',
} as const

export type PrincipalCannotBeDeletedErrorMessageEnum =
  (typeof PrincipalCannotBeDeletedErrorMessageEnum)[keyof typeof PrincipalCannotBeDeletedErrorMessageEnum]
export const PrincipalCannotBeDeletedErrorHttpStatusCodeEnum = {
  NUMBER_409: 409,
} as const

export type PrincipalCannotBeDeletedErrorHttpStatusCodeEnum =
  (typeof PrincipalCannotBeDeletedErrorHttpStatusCodeEnum)[keyof typeof PrincipalCannotBeDeletedErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface PrincipalDoesNotBelongToProjectError
 */
export interface PrincipalDoesNotBelongToProjectError {
  /**
   *
   * @type {string}
   * @memberof PrincipalDoesNotBelongToProjectError
   */
  name: PrincipalDoesNotBelongToProjectErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof PrincipalDoesNotBelongToProjectError
   */
  message: PrincipalDoesNotBelongToProjectErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof PrincipalDoesNotBelongToProjectError
   */
  httpStatusCode: PrincipalDoesNotBelongToProjectErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof PrincipalDoesNotBelongToProjectError
   */
  traceId: string
  /**
   *
   * @type {Array<ServiceErrorResponseDetailsInner>}
   * @memberof PrincipalDoesNotBelongToProjectError
   */
  details?: Array<ServiceErrorResponseDetailsInner>
}

export const PrincipalDoesNotBelongToProjectErrorNameEnum = {
  PrincipalDoesNotBelongToProjectError: 'PrincipalDoesNotBelongToProjectError',
} as const

export type PrincipalDoesNotBelongToProjectErrorNameEnum =
  (typeof PrincipalDoesNotBelongToProjectErrorNameEnum)[keyof typeof PrincipalDoesNotBelongToProjectErrorNameEnum]
export const PrincipalDoesNotBelongToProjectErrorMessageEnum = {
  PrincipalDoesNotBelongToTheGivenProject:
    'Principal does not belong to the given project',
} as const

export type PrincipalDoesNotBelongToProjectErrorMessageEnum =
  (typeof PrincipalDoesNotBelongToProjectErrorMessageEnum)[keyof typeof PrincipalDoesNotBelongToProjectErrorMessageEnum]
export const PrincipalDoesNotBelongToProjectErrorHttpStatusCodeEnum = {
  NUMBER_403: 403,
} as const

export type PrincipalDoesNotBelongToProjectErrorHttpStatusCodeEnum =
  (typeof PrincipalDoesNotBelongToProjectErrorHttpStatusCodeEnum)[keyof typeof PrincipalDoesNotBelongToProjectErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface ProjectDto
 */
export interface ProjectDto {
  /**
   *
   * @type {string}
   * @memberof ProjectDto
   */
  id: string
  /**
   *
   * @type {string}
   * @memberof ProjectDto
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof ProjectDto
   */
  ownerId?: string
  /**
   *
   * @type {string}
   * @memberof ProjectDto
   */
  description?: string
  /**
   * creation date and time in ISO-8601 format, e.g. 2023-09-20T07:12:13
   * @type {string}
   * @memberof ProjectDto
   */
  createdAt?: string
  /**
   * last update date and time in ISO-8601 format, e.g. 2023-09-20T07:12:13
   * @type {string}
   * @memberof ProjectDto
   */
  updatedAt?: string
}
/**
 *
 * @export
 * @interface ProjectList
 */
export interface ProjectList {
  /**
   *
   * @type {Array<ProjectDto>}
   * @memberof ProjectList
   */
  projects: Array<ProjectDto>
}
/**
 *
 * @export
 * @interface PublicKeyCannotBeResolvedFromDidError
 */
export interface PublicKeyCannotBeResolvedFromDidError {
  /**
   *
   * @type {string}
   * @memberof PublicKeyCannotBeResolvedFromDidError
   */
  name: PublicKeyCannotBeResolvedFromDidErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof PublicKeyCannotBeResolvedFromDidError
   */
  message: PublicKeyCannotBeResolvedFromDidErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof PublicKeyCannotBeResolvedFromDidError
   */
  httpStatusCode: PublicKeyCannotBeResolvedFromDidErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof PublicKeyCannotBeResolvedFromDidError
   */
  traceId: string
  /**
   *
   * @type {Array<ServiceErrorResponseDetailsInner>}
   * @memberof PublicKeyCannotBeResolvedFromDidError
   */
  details?: Array<ServiceErrorResponseDetailsInner>
}

export const PublicKeyCannotBeResolvedFromDidErrorNameEnum = {
  PublicKeyCannotBeResolvedFromDidError:
    'PublicKeyCannotBeResolvedFromDidError',
} as const

export type PublicKeyCannotBeResolvedFromDidErrorNameEnum =
  (typeof PublicKeyCannotBeResolvedFromDidErrorNameEnum)[keyof typeof PublicKeyCannotBeResolvedFromDidErrorNameEnum]
export const PublicKeyCannotBeResolvedFromDidErrorMessageEnum = {
  UnableToResolveDidMethodInvalidPublicKey:
    'Unable to resolve DID method. Invalid public key',
} as const

export type PublicKeyCannotBeResolvedFromDidErrorMessageEnum =
  (typeof PublicKeyCannotBeResolvedFromDidErrorMessageEnum)[keyof typeof PublicKeyCannotBeResolvedFromDidErrorMessageEnum]
export const PublicKeyCannotBeResolvedFromDidErrorHttpStatusCodeEnum = {
  NUMBER_400: 400,
} as const

export type PublicKeyCannotBeResolvedFromDidErrorHttpStatusCodeEnum =
  (typeof PublicKeyCannotBeResolvedFromDidErrorHttpStatusCodeEnum)[keyof typeof PublicKeyCannotBeResolvedFromDidErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface ServiceErrorResponse
 */
export interface ServiceErrorResponse {
  /**
   * unique id for correlating this specific error to logs
   * @type {string}
   * @memberof ServiceErrorResponse
   */
  debugId: string
  /**
   * name of the error
   * @type {string}
   * @memberof ServiceErrorResponse
   */
  name: string
  /**
   * backwards compatible Affinidi error code
   * @type {string}
   * @memberof ServiceErrorResponse
   */
  code: string
  /**
   *
   * @type {Array<ServiceErrorResponseDetailsInner>}
   * @memberof ServiceErrorResponse
   */
  details?: Array<ServiceErrorResponseDetailsInner>
}
/**
 *
 * @export
 * @interface ServiceErrorResponseDetailsInner
 */
export interface ServiceErrorResponseDetailsInner {
  /**
   *
   * @type {string}
   * @memberof ServiceErrorResponseDetailsInner
   */
  issue: string
  /**
   *
   * @type {string}
   * @memberof ServiceErrorResponseDetailsInner
   */
  field?: string
  /**
   *
   * @type {string}
   * @memberof ServiceErrorResponseDetailsInner
   */
  value?: string
  /**
   *
   * @type {string}
   * @memberof ServiceErrorResponseDetailsInner
   */
  location?: string
}
/**
 * @type TokenAuthenticationMethodDto
 * How the Token will be authenticate against our Authorization Server
 * @export
 */
export type TokenAuthenticationMethodDto =
  TokenPrivateKeyAuthenticationMethodDto

/**
 *
 * @export
 * @interface TokenDto
 */
export interface TokenDto {
  /**
   * Token Id
   * @type {string}
   * @memberof TokenDto
   */
  id: string
  /**
   * Token ARI
   * @type {string}
   * @memberof TokenDto
   */
  ari: string
  /**
   * The Token owner\'s ARI
   * @type {string}
   * @memberof TokenDto
   */
  ownerAri: string
  /**
   * Owner defined Token display name
   * @type {string}
   * @memberof TokenDto
   */
  name: string
  /**
   *
   * @type {TokenAuthenticationMethodDto}
   * @memberof TokenDto
   */
  authenticationMethod: TokenAuthenticationMethodDto
  /**
   * Scopes that will be assigned to the Token on authentication
   * @type {Array<string>}
   * @memberof TokenDto
   */
  scopes: Array<string>
}
/**
 *
 * @export
 * @interface TokenList
 */
export interface TokenList {
  /**
   *
   * @type {Array<TokenDto>}
   * @memberof TokenList
   */
  tokens: Array<TokenDto>
}
/**
 * Private Key JWT Authentication of Client with `private_key_jwt` oAuth Method
 * @export
 * @interface TokenPrivateKeyAuthenticationMethodDto
 */
export interface TokenPrivateKeyAuthenticationMethodDto {
  /**
   *
   * @type {string}
   * @memberof TokenPrivateKeyAuthenticationMethodDto
   */
  type: TokenPrivateKeyAuthenticationMethodDtoTypeEnum
  /**
   *
   * @type {string}
   * @memberof TokenPrivateKeyAuthenticationMethodDto
   */
  signingAlgorithm: TokenPrivateKeyAuthenticationMethodDtoSigningAlgorithmEnum
  /**
   *
   * @type {TokenPrivateKeyAuthenticationMethodDtoPublicKeyInfo}
   * @memberof TokenPrivateKeyAuthenticationMethodDto
   */
  publicKeyInfo: TokenPrivateKeyAuthenticationMethodDtoPublicKeyInfo
}

export const TokenPrivateKeyAuthenticationMethodDtoTypeEnum = {
  PrivateKey: 'PRIVATE_KEY',
} as const

export type TokenPrivateKeyAuthenticationMethodDtoTypeEnum =
  (typeof TokenPrivateKeyAuthenticationMethodDtoTypeEnum)[keyof typeof TokenPrivateKeyAuthenticationMethodDtoTypeEnum]
export const TokenPrivateKeyAuthenticationMethodDtoSigningAlgorithmEnum = {
  Rs256: 'RS256',
  Rs512: 'RS512',
  Es256: 'ES256',
  Es512: 'ES512',
} as const

export type TokenPrivateKeyAuthenticationMethodDtoSigningAlgorithmEnum =
  (typeof TokenPrivateKeyAuthenticationMethodDtoSigningAlgorithmEnum)[keyof typeof TokenPrivateKeyAuthenticationMethodDtoSigningAlgorithmEnum]

/**
 * @type TokenPrivateKeyAuthenticationMethodDtoPublicKeyInfo
 * Corresponding Public Key Info provided either as a URL or a Hardcoded Object
 * @export
 */
export type TokenPrivateKeyAuthenticationMethodDtoPublicKeyInfo =
  | TokenPrivateKeyAuthenticationMethodDtoPublicKeyInfoOneOf
  | TokenPrivateKeyAuthenticationMethodDtoPublicKeyInfoOneOf1

/**
 *
 * @export
 * @interface TokenPrivateKeyAuthenticationMethodDtoPublicKeyInfoOneOf
 */
export interface TokenPrivateKeyAuthenticationMethodDtoPublicKeyInfoOneOf {
  /**
   *
   * @type {JsonWebKeySetDto}
   * @memberof TokenPrivateKeyAuthenticationMethodDtoPublicKeyInfoOneOf
   */
  jwks: JsonWebKeySetDto
}
/**
 *
 * @export
 * @interface TokenPrivateKeyAuthenticationMethodDtoPublicKeyInfoOneOf1
 */
export interface TokenPrivateKeyAuthenticationMethodDtoPublicKeyInfoOneOf1 {
  /**
   *
   * @type {string}
   * @memberof TokenPrivateKeyAuthenticationMethodDtoPublicKeyInfoOneOf1
   */
  jwksUri: string
}
/**
 *
 * @export
 * @interface TypedPricipalId
 */
export interface TypedPricipalId {
  /**
   *
   * @type {string}
   * @memberof TypedPricipalId
   */
  principalId: string
}
/**
 *
 * @export
 * @interface UnauthorizedError
 */
export interface UnauthorizedError {
  /**
   *
   * @type {string}
   * @memberof UnauthorizedError
   */
  name: UnauthorizedErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof UnauthorizedError
   */
  message: UnauthorizedErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof UnauthorizedError
   */
  httpStatusCode: UnauthorizedErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof UnauthorizedError
   */
  traceId: string
  /**
   *
   * @type {Array<ServiceErrorResponseDetailsInner>}
   * @memberof UnauthorizedError
   */
  details?: Array<ServiceErrorResponseDetailsInner>
}

export const UnauthorizedErrorNameEnum = {
  UnauthorizedError: 'UnauthorizedError',
} as const

export type UnauthorizedErrorNameEnum =
  (typeof UnauthorizedErrorNameEnum)[keyof typeof UnauthorizedErrorNameEnum]
export const UnauthorizedErrorMessageEnum = {
  Unauthorized: 'Unauthorized',
} as const

export type UnauthorizedErrorMessageEnum =
  (typeof UnauthorizedErrorMessageEnum)[keyof typeof UnauthorizedErrorMessageEnum]
export const UnauthorizedErrorHttpStatusCodeEnum = {
  NUMBER_403: 403,
} as const

export type UnauthorizedErrorHttpStatusCodeEnum =
  (typeof UnauthorizedErrorHttpStatusCodeEnum)[keyof typeof UnauthorizedErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface UnexpectedError
 */
export interface UnexpectedError {
  /**
   *
   * @type {string}
   * @memberof UnexpectedError
   */
  name: UnexpectedErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof UnexpectedError
   */
  message: UnexpectedErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof UnexpectedError
   */
  httpStatusCode: UnexpectedErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof UnexpectedError
   */
  traceId: string
  /**
   *
   * @type {Array<ServiceErrorResponseDetailsInner>}
   * @memberof UnexpectedError
   */
  details?: Array<ServiceErrorResponseDetailsInner>
}

export const UnexpectedErrorNameEnum = {
  UnexpectedError: 'UnexpectedError',
} as const

export type UnexpectedErrorNameEnum =
  (typeof UnexpectedErrorNameEnum)[keyof typeof UnexpectedErrorNameEnum]
export const UnexpectedErrorMessageEnum = {
  UnexpectedErrorOccurred: 'Unexpected Error Occurred.',
} as const

export type UnexpectedErrorMessageEnum =
  (typeof UnexpectedErrorMessageEnum)[keyof typeof UnexpectedErrorMessageEnum]
export const UnexpectedErrorHttpStatusCodeEnum = {
  NUMBER_500: 500,
} as const

export type UnexpectedErrorHttpStatusCodeEnum =
  (typeof UnexpectedErrorHttpStatusCodeEnum)[keyof typeof UnexpectedErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface UpdateProjectInput
 */
export interface UpdateProjectInput {
  /**
   *
   * @type {string}
   * @memberof UpdateProjectInput
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof UpdateProjectInput
   */
  description?: string
}
/**
 *
 * @export
 * @interface UpdateTokenInput
 */
export interface UpdateTokenInput {
  /**
   *
   * @type {string}
   * @memberof UpdateTokenInput
   */
  name?: string
  /**
   *
   * @type {UpdateTokenPrivateKeyAuthenticationMethodDto}
   * @memberof UpdateTokenInput
   */
  authenticationMethod?: UpdateTokenPrivateKeyAuthenticationMethodDto
}
/**
 * Private Key JWT Authentication of Client with `private_key_jwt` oAuth Method
 * @export
 * @interface UpdateTokenPrivateKeyAuthenticationMethodDto
 */
export interface UpdateTokenPrivateKeyAuthenticationMethodDto {
  /**
   *
   * @type {string}
   * @memberof UpdateTokenPrivateKeyAuthenticationMethodDto
   */
  type?: UpdateTokenPrivateKeyAuthenticationMethodDtoTypeEnum
  /**
   *
   * @type {string}
   * @memberof UpdateTokenPrivateKeyAuthenticationMethodDto
   */
  signingAlgorithm?: UpdateTokenPrivateKeyAuthenticationMethodDtoSigningAlgorithmEnum
  /**
   *
   * @type {TokenPrivateKeyAuthenticationMethodDtoPublicKeyInfo}
   * @memberof UpdateTokenPrivateKeyAuthenticationMethodDto
   */
  publicKeyInfo?: TokenPrivateKeyAuthenticationMethodDtoPublicKeyInfo
}

export const UpdateTokenPrivateKeyAuthenticationMethodDtoTypeEnum = {
  PrivateKey: 'PRIVATE_KEY',
} as const

export type UpdateTokenPrivateKeyAuthenticationMethodDtoTypeEnum =
  (typeof UpdateTokenPrivateKeyAuthenticationMethodDtoTypeEnum)[keyof typeof UpdateTokenPrivateKeyAuthenticationMethodDtoTypeEnum]
export const UpdateTokenPrivateKeyAuthenticationMethodDtoSigningAlgorithmEnum =
  {
    Rs256: 'RS256',
    Rs512: 'RS512',
    Es256: 'ES256',
    Es512: 'ES512',
  } as const

export type UpdateTokenPrivateKeyAuthenticationMethodDtoSigningAlgorithmEnum =
  (typeof UpdateTokenPrivateKeyAuthenticationMethodDtoSigningAlgorithmEnum)[keyof typeof UpdateTokenPrivateKeyAuthenticationMethodDtoSigningAlgorithmEnum]

/**
 *
 * @export
 * @interface UserDto
 */
export interface UserDto {
  /**
   *
   * @type {string}
   * @memberof UserDto
   */
  principalId: string
}
/**
 *
 * @export
 * @interface UserList
 */
export interface UserList {
  /**
   *
   * @type {Array<UserDto>}
   * @memberof UserList
   */
  records: Array<UserDto>
}
/**
 *
 * @export
 * @interface WhoamiDto
 */
export interface WhoamiDto {
  /**
   *
   * @type {string}
   * @memberof WhoamiDto
   */
  principalId: string
  /**
   *
   * @type {string}
   * @memberof WhoamiDto
   */
  principalType: string
}

/**
 * ConsumerAuthApi - axios parameter creator
 * @export
 */
export const ConsumerAuthApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Use open source libraries to perform OAuth 2.0 and OpenID Connect available for any programming language. You can find a list of libraries here https://oauth.net/code/  The Ory SDK is not yet able to this endpoint properly.
     * @summary The Consumer OAuth 2.0 Token Endpoint
     * @param {ConsumerAuthTokenEndpointInput} consumerAuthTokenEndpointInput ConsumerAuthTokenEndpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    consumerAuthTokenEndpoint: async (
      consumerAuthTokenEndpointInput: ConsumerAuthTokenEndpointInput,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'consumerAuthTokenEndpointInput' is not null or undefined
      assertParamExists(
        'consumerAuthTokenEndpoint',
        'consumerAuthTokenEndpointInput',
        consumerAuthTokenEndpointInput,
      )
      const localVarPath = `/v1/consumer/oauth2/token`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        consumerAuthTokenEndpointInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ConsumerAuthApi - functional programming interface
 * @export
 */
export const ConsumerAuthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ConsumerAuthApiAxiosParamCreator(configuration)
  return {
    /**
     * Use open source libraries to perform OAuth 2.0 and OpenID Connect available for any programming language. You can find a list of libraries here https://oauth.net/code/  The Ory SDK is not yet able to this endpoint properly.
     * @summary The Consumer OAuth 2.0 Token Endpoint
     * @param {ConsumerAuthTokenEndpointInput} consumerAuthTokenEndpointInput ConsumerAuthTokenEndpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async consumerAuthTokenEndpoint(
      consumerAuthTokenEndpointInput: ConsumerAuthTokenEndpointInput,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ConsumerAuthTokenEndpointOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.consumerAuthTokenEndpoint(
          consumerAuthTokenEndpointInput,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ConsumerAuthApi.consumerAuthTokenEndpoint']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * ConsumerAuthApi - factory interface
 * @export
 */
export const ConsumerAuthApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ConsumerAuthApiFp(configuration)
  return {
    /**
     * Use open source libraries to perform OAuth 2.0 and OpenID Connect available for any programming language. You can find a list of libraries here https://oauth.net/code/  The Ory SDK is not yet able to this endpoint properly.
     * @summary The Consumer OAuth 2.0 Token Endpoint
     * @param {ConsumerAuthTokenEndpointInput} consumerAuthTokenEndpointInput ConsumerAuthTokenEndpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    consumerAuthTokenEndpoint(
      consumerAuthTokenEndpointInput: ConsumerAuthTokenEndpointInput,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ConsumerAuthTokenEndpointOutput> {
      return localVarFp
        .consumerAuthTokenEndpoint(consumerAuthTokenEndpointInput, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ConsumerAuthApi - object-oriented interface
 * @export
 * @class ConsumerAuthApi
 * @extends {BaseAPI}
 */
export class ConsumerAuthApi extends BaseAPI {
  /**
   * Use open source libraries to perform OAuth 2.0 and OpenID Connect available for any programming language. You can find a list of libraries here https://oauth.net/code/  The Ory SDK is not yet able to this endpoint properly.
   * @summary The Consumer OAuth 2.0 Token Endpoint
   * @param {ConsumerAuthTokenEndpointInput} consumerAuthTokenEndpointInput ConsumerAuthTokenEndpoint
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConsumerAuthApi
   */
  public consumerAuthTokenEndpoint(
    consumerAuthTokenEndpointInput: ConsumerAuthTokenEndpointInput,
    options?: RawAxiosRequestConfig,
  ) {
    return ConsumerAuthApiFp(this.configuration)
      .consumerAuthTokenEndpoint(consumerAuthTokenEndpointInput, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {string} proxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1AuthProxyDelete: async (
      proxy: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'proxy' is not null or undefined
      assertParamExists('v1AuthProxyDelete', 'proxy', proxy)
      const localVarPath = `/v1/auth/{proxy+}`.replace(
        `{${'proxy'}}`,
        encodeURIComponent(String(proxy)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} proxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1AuthProxyGet: async (
      proxy: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'proxy' is not null or undefined
      assertParamExists('v1AuthProxyGet', 'proxy', proxy)
      const localVarPath = `/v1/auth/{proxy+}`.replace(
        `{${'proxy'}}`,
        encodeURIComponent(String(proxy)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} proxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1AuthProxyPatch: async (
      proxy: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'proxy' is not null or undefined
      assertParamExists('v1AuthProxyPatch', 'proxy', proxy)
      const localVarPath = `/v1/auth/{proxy+}`.replace(
        `{${'proxy'}}`,
        encodeURIComponent(String(proxy)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} proxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1AuthProxyPost: async (
      proxy: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'proxy' is not null or undefined
      assertParamExists('v1AuthProxyPost', 'proxy', proxy)
      const localVarPath = `/v1/auth/{proxy+}`.replace(
        `{${'proxy'}}`,
        encodeURIComponent(String(proxy)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} proxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1AuthProxyPut: async (
      proxy: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'proxy' is not null or undefined
      assertParamExists('v1AuthProxyPut', 'proxy', proxy)
      const localVarPath = `/v1/auth/{proxy+}`.replace(
        `{${'proxy'}}`,
        encodeURIComponent(String(proxy)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} proxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1IdpProxyDelete: async (
      proxy: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'proxy' is not null or undefined
      assertParamExists('v1IdpProxyDelete', 'proxy', proxy)
      const localVarPath = `/v1/idp/{proxy+}`.replace(
        `{${'proxy'}}`,
        encodeURIComponent(String(proxy)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} proxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1IdpProxyGet: async (
      proxy: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'proxy' is not null or undefined
      assertParamExists('v1IdpProxyGet', 'proxy', proxy)
      const localVarPath = `/v1/idp/{proxy+}`.replace(
        `{${'proxy'}}`,
        encodeURIComponent(String(proxy)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} proxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1IdpProxyPatch: async (
      proxy: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'proxy' is not null or undefined
      assertParamExists('v1IdpProxyPatch', 'proxy', proxy)
      const localVarPath = `/v1/idp/{proxy+}`.replace(
        `{${'proxy'}}`,
        encodeURIComponent(String(proxy)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} proxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1IdpProxyPost: async (
      proxy: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'proxy' is not null or undefined
      assertParamExists('v1IdpProxyPost', 'proxy', proxy)
      const localVarPath = `/v1/idp/{proxy+}`.replace(
        `{${'proxy'}}`,
        encodeURIComponent(String(proxy)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} proxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1IdpProxyPut: async (
      proxy: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'proxy' is not null or undefined
      assertParamExists('v1IdpProxyPut', 'proxy', proxy)
      const localVarPath = `/v1/idp/{proxy+}`.replace(
        `{${'proxy'}}`,
        encodeURIComponent(String(proxy)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {string} proxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1AuthProxyDelete(
      proxy: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.v1AuthProxyDelete(proxy, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.v1AuthProxyDelete']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {string} proxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1AuthProxyGet(
      proxy: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1AuthProxyGet(
        proxy,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.v1AuthProxyGet']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {string} proxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1AuthProxyPatch(
      proxy: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.v1AuthProxyPatch(proxy, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.v1AuthProxyPatch']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {string} proxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1AuthProxyPost(
      proxy: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1AuthProxyPost(
        proxy,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.v1AuthProxyPost']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {string} proxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1AuthProxyPut(
      proxy: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1AuthProxyPut(
        proxy,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.v1AuthProxyPut']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {string} proxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1IdpProxyDelete(
      proxy: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.v1IdpProxyDelete(proxy, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.v1IdpProxyDelete']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {string} proxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1IdpProxyGet(
      proxy: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1IdpProxyGet(
        proxy,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.v1IdpProxyGet']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {string} proxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1IdpProxyPatch(
      proxy: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1IdpProxyPatch(
        proxy,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.v1IdpProxyPatch']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {string} proxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1IdpProxyPost(
      proxy: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1IdpProxyPost(
        proxy,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.v1IdpProxyPost']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {string} proxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v1IdpProxyPut(
      proxy: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v1IdpProxyPut(
        proxy,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.v1IdpProxyPut']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DefaultApiFp(configuration)
  return {
    /**
     *
     * @param {string} proxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1AuthProxyDelete(
      proxy: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .v1AuthProxyDelete(proxy, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} proxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1AuthProxyGet(
      proxy: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .v1AuthProxyGet(proxy, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} proxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1AuthProxyPatch(
      proxy: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .v1AuthProxyPatch(proxy, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} proxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1AuthProxyPost(
      proxy: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .v1AuthProxyPost(proxy, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} proxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1AuthProxyPut(
      proxy: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .v1AuthProxyPut(proxy, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} proxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1IdpProxyDelete(
      proxy: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .v1IdpProxyDelete(proxy, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} proxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1IdpProxyGet(
      proxy: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .v1IdpProxyGet(proxy, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} proxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1IdpProxyPatch(
      proxy: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .v1IdpProxyPatch(proxy, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} proxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1IdpProxyPost(
      proxy: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .v1IdpProxyPost(proxy, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} proxy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v1IdpProxyPut(
      proxy: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .v1IdpProxyPut(proxy, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
  /**
   *
   * @param {string} proxy
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public v1AuthProxyDelete(proxy: string, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .v1AuthProxyDelete(proxy, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} proxy
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public v1AuthProxyGet(proxy: string, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .v1AuthProxyGet(proxy, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} proxy
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public v1AuthProxyPatch(proxy: string, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .v1AuthProxyPatch(proxy, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} proxy
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public v1AuthProxyPost(proxy: string, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .v1AuthProxyPost(proxy, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} proxy
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public v1AuthProxyPut(proxy: string, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .v1AuthProxyPut(proxy, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} proxy
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public v1IdpProxyDelete(proxy: string, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .v1IdpProxyDelete(proxy, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} proxy
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public v1IdpProxyGet(proxy: string, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .v1IdpProxyGet(proxy, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} proxy
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public v1IdpProxyPatch(proxy: string, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .v1IdpProxyPatch(proxy, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} proxy
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public v1IdpProxyPost(proxy: string, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .v1IdpProxyPost(proxy, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} proxy
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public v1IdpProxyPut(proxy: string, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .v1IdpProxyPut(proxy, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * PoliciesApi - axios parameter creator
 * @export
 */
export const PoliciesApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {string} principalId
     * @param {GetPoliciesPrincipalTypeEnum} principalType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPolicies: async (
      principalId: string,
      principalType: GetPoliciesPrincipalTypeEnum,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'principalId' is not null or undefined
      assertParamExists('getPolicies', 'principalId', principalId)
      // verify required parameter 'principalType' is not null or undefined
      assertParamExists('getPolicies', 'principalType', principalType)
      const localVarPath = `/v1/policies/principals/{principalId}`.replace(
        `{${'principalId'}}`,
        encodeURIComponent(String(principalId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      if (principalType !== undefined) {
        localVarQueryParameter['principalType'] = principalType
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} principalId
     * @param {UpdatePoliciesPrincipalTypeEnum} principalType
     * @param {PolicyDto} policyDto UpdatePolicies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePolicies: async (
      principalId: string,
      principalType: UpdatePoliciesPrincipalTypeEnum,
      policyDto: PolicyDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'principalId' is not null or undefined
      assertParamExists('updatePolicies', 'principalId', principalId)
      // verify required parameter 'principalType' is not null or undefined
      assertParamExists('updatePolicies', 'principalType', principalType)
      // verify required parameter 'policyDto' is not null or undefined
      assertParamExists('updatePolicies', 'policyDto', policyDto)
      const localVarPath = `/v1/policies/principals/{principalId}`.replace(
        `{${'principalId'}}`,
        encodeURIComponent(String(principalId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      if (principalType !== undefined) {
        localVarQueryParameter['principalType'] = principalType
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        policyDto,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * PoliciesApi - functional programming interface
 * @export
 */
export const PoliciesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PoliciesApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {string} principalId
     * @param {GetPoliciesPrincipalTypeEnum} principalType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPolicies(
      principalId: string,
      principalType: GetPoliciesPrincipalTypeEnum,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPolicies(
        principalId,
        principalType,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['PoliciesApi.getPolicies']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {string} principalId
     * @param {UpdatePoliciesPrincipalTypeEnum} principalType
     * @param {PolicyDto} policyDto UpdatePolicies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatePolicies(
      principalId: string,
      principalType: UpdatePoliciesPrincipalTypeEnum,
      policyDto: PolicyDto,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatePolicies(
        principalId,
        principalType,
        policyDto,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['PoliciesApi.updatePolicies']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * PoliciesApi - factory interface
 * @export
 */
export const PoliciesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = PoliciesApiFp(configuration)
  return {
    /**
     *
     * @param {string} principalId
     * @param {GetPoliciesPrincipalTypeEnum} principalType
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPolicies(
      principalId: string,
      principalType: GetPoliciesPrincipalTypeEnum,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<PolicyDto> {
      return localVarFp
        .getPolicies(principalId, principalType, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} principalId
     * @param {UpdatePoliciesPrincipalTypeEnum} principalType
     * @param {PolicyDto} policyDto UpdatePolicies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePolicies(
      principalId: string,
      principalType: UpdatePoliciesPrincipalTypeEnum,
      policyDto: PolicyDto,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<PolicyDto> {
      return localVarFp
        .updatePolicies(principalId, principalType, policyDto, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * PoliciesApi - object-oriented interface
 * @export
 * @class PoliciesApi
 * @extends {BaseAPI}
 */
export class PoliciesApi extends BaseAPI {
  /**
   *
   * @param {string} principalId
   * @param {GetPoliciesPrincipalTypeEnum} principalType
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public getPolicies(
    principalId: string,
    principalType: GetPoliciesPrincipalTypeEnum,
    options?: RawAxiosRequestConfig,
  ) {
    return PoliciesApiFp(this.configuration)
      .getPolicies(principalId, principalType, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} principalId
   * @param {UpdatePoliciesPrincipalTypeEnum} principalType
   * @param {PolicyDto} policyDto UpdatePolicies
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoliciesApi
   */
  public updatePolicies(
    principalId: string,
    principalType: UpdatePoliciesPrincipalTypeEnum,
    policyDto: PolicyDto,
    options?: RawAxiosRequestConfig,
  ) {
    return PoliciesApiFp(this.configuration)
      .updatePolicies(principalId, principalType, policyDto, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * @export
 */
export const GetPoliciesPrincipalTypeEnum = {
  User: 'user',
  Token: 'token',
} as const
export type GetPoliciesPrincipalTypeEnum =
  (typeof GetPoliciesPrincipalTypeEnum)[keyof typeof GetPoliciesPrincipalTypeEnum]
/**
 * @export
 */
export const UpdatePoliciesPrincipalTypeEnum = {
  User: 'user',
  Token: 'token',
} as const
export type UpdatePoliciesPrincipalTypeEnum =
  (typeof UpdatePoliciesPrincipalTypeEnum)[keyof typeof UpdatePoliciesPrincipalTypeEnum]

/**
 * ProjectsApi - axios parameter creator
 * @export
 */
export const ProjectsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {AddUserToProjectInput} addUserToProjectInput AddPrincipalToProject
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addPrincipalToProject: async (
      addUserToProjectInput: AddUserToProjectInput,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'addUserToProjectInput' is not null or undefined
      assertParamExists(
        'addPrincipalToProject',
        'addUserToProjectInput',
        addUserToProjectInput,
      )
      const localVarPath = `/v1/projects/principals`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        addUserToProjectInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {CreateProjectInput} createProjectInput CreateProject
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createProject: async (
      createProjectInput: CreateProjectInput,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createProjectInput' is not null or undefined
      assertParamExists(
        'createProject',
        'createProjectInput',
        createProjectInput,
      )
      const localVarPath = `/v1/projects`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication UserTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        createProjectInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} principalId id of principal
     * @param {DeletePrincipalFromProjectPrincipalTypeEnum} principalType type of principal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePrincipalFromProject: async (
      principalId: string,
      principalType: DeletePrincipalFromProjectPrincipalTypeEnum,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'principalId' is not null or undefined
      assertParamExists(
        'deletePrincipalFromProject',
        'principalId',
        principalId,
      )
      // verify required parameter 'principalType' is not null or undefined
      assertParamExists(
        'deletePrincipalFromProject',
        'principalType',
        principalType,
      )
      const localVarPath = `/v1/projects/principals/{principalId}`.replace(
        `{${'principalId'}}`,
        encodeURIComponent(String(principalId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      if (principalType !== undefined) {
        localVarQueryParameter['principalType'] = principalType
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPrincipalsOfProject: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/projects/principals`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listProject: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/projects`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication UserTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} projectId projectId
     * @param {UpdateProjectInput} updateProjectInput UpdateProject
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProject: async (
      projectId: string,
      updateProjectInput: UpdateProjectInput,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists('updateProject', 'projectId', projectId)
      // verify required parameter 'updateProjectInput' is not null or undefined
      assertParamExists(
        'updateProject',
        'updateProjectInput',
        updateProjectInput,
      )
      const localVarPath = `/v1/projects/{projectId}`.replace(
        `{${'projectId'}}`,
        encodeURIComponent(String(projectId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication UserTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateProjectInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {AddUserToProjectInput} addUserToProjectInput AddPrincipalToProject
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addPrincipalToProject(
      addUserToProjectInput: AddUserToProjectInput,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.addPrincipalToProject(
          addUserToProjectInput,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ProjectsApi.addPrincipalToProject']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {CreateProjectInput} createProjectInput CreateProject
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createProject(
      createProjectInput: CreateProjectInput,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createProject(
        createProjectInput,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ProjectsApi.createProject']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {string} principalId id of principal
     * @param {DeletePrincipalFromProjectPrincipalTypeEnum} principalType type of principal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletePrincipalFromProject(
      principalId: string,
      principalType: DeletePrincipalFromProjectPrincipalTypeEnum,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deletePrincipalFromProject(
          principalId,
          principalType,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ProjectsApi.deletePrincipalFromProject']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listPrincipalsOfProject(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserList>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listPrincipalsOfProject(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ProjectsApi.listPrincipalsOfProject']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listProject(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectList>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listProject(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ProjectsApi.listProject']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {string} projectId projectId
     * @param {UpdateProjectInput} updateProjectInput UpdateProject
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateProject(
      projectId: string,
      updateProjectInput: UpdateProjectInput,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateProject(
        projectId,
        updateProjectInput,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ProjectsApi.updateProject']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ProjectsApiFp(configuration)
  return {
    /**
     *
     * @param {AddUserToProjectInput} addUserToProjectInput AddPrincipalToProject
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addPrincipalToProject(
      addUserToProjectInput: AddUserToProjectInput,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .addPrincipalToProject(addUserToProjectInput, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {CreateProjectInput} createProjectInput CreateProject
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createProject(
      createProjectInput: CreateProjectInput,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ProjectDto> {
      return localVarFp
        .createProject(createProjectInput, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} principalId id of principal
     * @param {DeletePrincipalFromProjectPrincipalTypeEnum} principalType type of principal
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePrincipalFromProject(
      principalId: string,
      principalType: DeletePrincipalFromProjectPrincipalTypeEnum,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .deletePrincipalFromProject(principalId, principalType, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPrincipalsOfProject(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<UserList> {
      return localVarFp
        .listPrincipalsOfProject(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listProject(options?: RawAxiosRequestConfig): AxiosPromise<ProjectList> {
      return localVarFp
        .listProject(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} projectId projectId
     * @param {UpdateProjectInput} updateProjectInput UpdateProject
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProject(
      projectId: string,
      updateProjectInput: UpdateProjectInput,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ProjectDto> {
      return localVarFp
        .updateProject(projectId, updateProjectInput, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI {
  /**
   *
   * @param {AddUserToProjectInput} addUserToProjectInput AddPrincipalToProject
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsApi
   */
  public addPrincipalToProject(
    addUserToProjectInput: AddUserToProjectInput,
    options?: RawAxiosRequestConfig,
  ) {
    return ProjectsApiFp(this.configuration)
      .addPrincipalToProject(addUserToProjectInput, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {CreateProjectInput} createProjectInput CreateProject
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsApi
   */
  public createProject(
    createProjectInput: CreateProjectInput,
    options?: RawAxiosRequestConfig,
  ) {
    return ProjectsApiFp(this.configuration)
      .createProject(createProjectInput, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} principalId id of principal
   * @param {DeletePrincipalFromProjectPrincipalTypeEnum} principalType type of principal
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsApi
   */
  public deletePrincipalFromProject(
    principalId: string,
    principalType: DeletePrincipalFromProjectPrincipalTypeEnum,
    options?: RawAxiosRequestConfig,
  ) {
    return ProjectsApiFp(this.configuration)
      .deletePrincipalFromProject(principalId, principalType, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsApi
   */
  public listPrincipalsOfProject(options?: RawAxiosRequestConfig) {
    return ProjectsApiFp(this.configuration)
      .listPrincipalsOfProject(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsApi
   */
  public listProject(options?: RawAxiosRequestConfig) {
    return ProjectsApiFp(this.configuration)
      .listProject(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} projectId projectId
   * @param {UpdateProjectInput} updateProjectInput UpdateProject
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProjectsApi
   */
  public updateProject(
    projectId: string,
    updateProjectInput: UpdateProjectInput,
    options?: RawAxiosRequestConfig,
  ) {
    return ProjectsApiFp(this.configuration)
      .updateProject(projectId, updateProjectInput, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * @export
 */
export const DeletePrincipalFromProjectPrincipalTypeEnum = {
  User: 'user',
  Token: 'token',
} as const
export type DeletePrincipalFromProjectPrincipalTypeEnum =
  (typeof DeletePrincipalFromProjectPrincipalTypeEnum)[keyof typeof DeletePrincipalFromProjectPrincipalTypeEnum]

/**
 * StsApi - axios parameter creator
 * @export
 */
export const StsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {CreateProjectScopedTokenInput} createProjectScopedTokenInput CreateProjectScopedToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createProjectScopedToken: async (
      createProjectScopedTokenInput: CreateProjectScopedTokenInput,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createProjectScopedTokenInput' is not null or undefined
      assertParamExists(
        'createProjectScopedToken',
        'createProjectScopedTokenInput',
        createProjectScopedTokenInput,
      )
      const localVarPath = `/v1/sts/create-project-scoped-token`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication UserTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        createProjectScopedTokenInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    whoami: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/sts/whoami`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication UserTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * StsApi - functional programming interface
 * @export
 */
export const StsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = StsApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {CreateProjectScopedTokenInput} createProjectScopedTokenInput CreateProjectScopedToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createProjectScopedToken(
      createProjectScopedTokenInput: CreateProjectScopedTokenInput,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<CreateProjectScopedTokenOutput>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createProjectScopedToken(
          createProjectScopedTokenInput,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['StsApi.createProjectScopedToken']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async whoami(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<WhoamiDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.whoami(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['StsApi.whoami']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * StsApi - factory interface
 * @export
 */
export const StsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = StsApiFp(configuration)
  return {
    /**
     *
     * @param {CreateProjectScopedTokenInput} createProjectScopedTokenInput CreateProjectScopedToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createProjectScopedToken(
      createProjectScopedTokenInput: CreateProjectScopedTokenInput,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<CreateProjectScopedTokenOutput> {
      return localVarFp
        .createProjectScopedToken(createProjectScopedTokenInput, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    whoami(options?: RawAxiosRequestConfig): AxiosPromise<WhoamiDto> {
      return localVarFp
        .whoami(options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * StsApi - object-oriented interface
 * @export
 * @class StsApi
 * @extends {BaseAPI}
 */
export class StsApi extends BaseAPI {
  /**
   *
   * @param {CreateProjectScopedTokenInput} createProjectScopedTokenInput CreateProjectScopedToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StsApi
   */
  public createProjectScopedToken(
    createProjectScopedTokenInput: CreateProjectScopedTokenInput,
    options?: RawAxiosRequestConfig,
  ) {
    return StsApiFp(this.configuration)
      .createProjectScopedToken(createProjectScopedTokenInput, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StsApi
   */
  public whoami(options?: RawAxiosRequestConfig) {
    return StsApiFp(this.configuration)
      .whoami(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * TokensApi - axios parameter creator
 * @export
 */
export const TokensApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {CreateTokenInput} createTokenInput CreateToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createToken: async (
      createTokenInput: CreateTokenInput,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createTokenInput' is not null or undefined
      assertParamExists('createToken', 'createTokenInput', createTokenInput)
      const localVarPath = `/v1/tokens`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication UserTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        createTokenInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} tokenId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteToken: async (
      tokenId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'tokenId' is not null or undefined
      assertParamExists('deleteToken', 'tokenId', tokenId)
      const localVarPath = `/v1/tokens/{tokenId}`.replace(
        `{${'tokenId'}}`,
        encodeURIComponent(String(tokenId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication UserTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} tokenId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getToken: async (
      tokenId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'tokenId' is not null or undefined
      assertParamExists('getToken', 'tokenId', tokenId)
      const localVarPath = `/v1/tokens/{tokenId}`.replace(
        `{${'tokenId'}}`,
        encodeURIComponent(String(tokenId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication UserTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listToken: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/tokens`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication UserTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} tokenId
     * @param {UpdateTokenInput} updateTokenInput UpdateToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateToken: async (
      tokenId: string,
      updateTokenInput: UpdateTokenInput,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'tokenId' is not null or undefined
      assertParamExists('updateToken', 'tokenId', tokenId)
      // verify required parameter 'updateTokenInput' is not null or undefined
      assertParamExists('updateToken', 'updateTokenInput', updateTokenInput)
      const localVarPath = `/v1/tokens/{tokenId}`.replace(
        `{${'tokenId'}}`,
        encodeURIComponent(String(tokenId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication UserTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateTokenInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * TokensApi - functional programming interface
 * @export
 */
export const TokensApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TokensApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {CreateTokenInput} createTokenInput CreateToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createToken(
      createTokenInput: CreateTokenInput,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createToken(
        createTokenInput,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['TokensApi.createToken']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {string} tokenId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteToken(
      tokenId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteToken(
        tokenId,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['TokensApi.deleteToken']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {string} tokenId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getToken(
      tokenId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getToken(
        tokenId,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['TokensApi.getToken']?.[localVarOperationServerIndex]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listToken(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenList>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listToken(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['TokensApi.listToken']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {string} tokenId
     * @param {UpdateTokenInput} updateTokenInput UpdateToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateToken(
      tokenId: string,
      updateTokenInput: UpdateTokenInput,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateToken(
        tokenId,
        updateTokenInput,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['TokensApi.updateToken']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * TokensApi - factory interface
 * @export
 */
export const TokensApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = TokensApiFp(configuration)
  return {
    /**
     *
     * @param {CreateTokenInput} createTokenInput CreateToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createToken(
      createTokenInput: CreateTokenInput,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<TokenDto> {
      return localVarFp
        .createToken(createTokenInput, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} tokenId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteToken(
      tokenId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .deleteToken(tokenId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} tokenId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getToken(
      tokenId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<TokenDto> {
      return localVarFp
        .getToken(tokenId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listToken(options?: RawAxiosRequestConfig): AxiosPromise<TokenList> {
      return localVarFp
        .listToken(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} tokenId
     * @param {UpdateTokenInput} updateTokenInput UpdateToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateToken(
      tokenId: string,
      updateTokenInput: UpdateTokenInput,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<TokenDto> {
      return localVarFp
        .updateToken(tokenId, updateTokenInput, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * TokensApi - object-oriented interface
 * @export
 * @class TokensApi
 * @extends {BaseAPI}
 */
export class TokensApi extends BaseAPI {
  /**
   *
   * @param {CreateTokenInput} createTokenInput CreateToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TokensApi
   */
  public createToken(
    createTokenInput: CreateTokenInput,
    options?: RawAxiosRequestConfig,
  ) {
    return TokensApiFp(this.configuration)
      .createToken(createTokenInput, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} tokenId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TokensApi
   */
  public deleteToken(tokenId: string, options?: RawAxiosRequestConfig) {
    return TokensApiFp(this.configuration)
      .deleteToken(tokenId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} tokenId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TokensApi
   */
  public getToken(tokenId: string, options?: RawAxiosRequestConfig) {
    return TokensApiFp(this.configuration)
      .getToken(tokenId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TokensApi
   */
  public listToken(options?: RawAxiosRequestConfig) {
    return TokensApiFp(this.configuration)
      .listToken(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} tokenId
   * @param {UpdateTokenInput} updateTokenInput UpdateToken
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TokensApi
   */
  public updateToken(
    tokenId: string,
    updateTokenInput: UpdateTokenInput,
    options?: RawAxiosRequestConfig,
  ) {
    return TokensApiFp(this.configuration)
      .updateToken(tokenId, updateTokenInput, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * WellKnownApi - axios parameter creator
 * @export
 */
export const WellKnownApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWellKnownDid: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/.well-known/did.json`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWellKnownJwks: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/.well-known/jwks.json`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * WellKnownApi - functional programming interface
 * @export
 */
export const WellKnownApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = WellKnownApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getWellKnownDid(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<GetWellKnownDidOK>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getWellKnownDid(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['WellKnownApi.getWellKnownDid']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getWellKnownJwks(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<JsonWebKeySetDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getWellKnownJwks(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['WellKnownApi.getWellKnownJwks']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * WellKnownApi - factory interface
 * @export
 */
export const WellKnownApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = WellKnownApiFp(configuration)
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWellKnownDid(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GetWellKnownDidOK> {
      return localVarFp
        .getWellKnownDid(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWellKnownJwks(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<JsonWebKeySetDto> {
      return localVarFp
        .getWellKnownJwks(options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * WellKnownApi - object-oriented interface
 * @export
 * @class WellKnownApi
 * @extends {BaseAPI}
 */
export class WellKnownApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WellKnownApi
   */
  public getWellKnownDid(options?: RawAxiosRequestConfig) {
    return WellKnownApiFp(this.configuration)
      .getWellKnownDid(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WellKnownApi
   */
  public getWellKnownJwks(options?: RawAxiosRequestConfig) {
    return WellKnownApiFp(this.configuration)
      .getWellKnownJwks(options)
      .then((request) => request(this.axios, this.basePath))
  }
}
