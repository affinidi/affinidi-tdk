/* tslint:disable */
/* eslint-disable */
/**
 * VaultFileSystem
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: info@affinidi.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration'
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios'
import globalAxios from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common'
import type { RequestArgs } from './base'
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  BaseAPI,
  RequiredError,
  operationServerMap,
} from './base'

/**
 *
 * @export
 * @interface AccountDto
 */
export interface AccountDto {
  /**
   * number that is used for profile DID derivation
   * @type {number}
   * @memberof AccountDto
   */
  accountIndex: number
  /**
   * Profile DID that is associated with the account number
   * @type {string}
   * @memberof AccountDto
   */
  accountDid: string
  /**
   * Alias of account
   * @type {string}
   * @memberof AccountDto
   */
  alias?: string
  /**
   * Metadata of account
   * @type {object}
   * @memberof AccountDto
   */
  metadata?: object
  /**
   * Description of account
   * @type {string}
   * @memberof AccountDto
   */
  description?: string
}
/**
 *
 * @export
 * @interface AwsCredentialExchangeOperationOK
 */
export interface AwsCredentialExchangeOperationOK {
  /**
   *
   * @type {string}
   * @memberof AwsCredentialExchangeOperationOK
   */
  token: string
  /**
   *
   * @type {string}
   * @memberof AwsCredentialExchangeOperationOK
   */
  identityId: string
}
/**
 *
 * @export
 * @interface ConsumerMetadataDto
 */
export interface ConsumerMetadataDto {
  /**
   *
   * @type {string}
   * @memberof ConsumerMetadataDto
   */
  nodeId: string
  /**
   *
   * @type {NodeStatus}
   * @memberof ConsumerMetadataDto
   */
  status: NodeStatus
  /**
   *
   * @type {number}
   * @memberof ConsumerMetadataDto
   */
  fileCount?: number
  /**
   *
   * @type {number}
   * @memberof ConsumerMetadataDto
   */
  folderCount?: number
  /**
   *
   * @type {number}
   * @memberof ConsumerMetadataDto
   */
  profileCount?: number
  /**
   *
   * @type {string}
   * @memberof ConsumerMetadataDto
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof ConsumerMetadataDto
   */
  consumerId: string
  /**
   * creation date/time
   * @type {string}
   * @memberof ConsumerMetadataDto
   */
  createdAt: string
  /**
   * modification date/time
   * @type {string}
   * @memberof ConsumerMetadataDto
   */
  modifiedAt: string
  /**
   * Identifier of the user who created
   * @type {string}
   * @memberof ConsumerMetadataDto
   */
  createdBy: string
  /**
   * Identifier of the user who last updated
   * @type {string}
   * @memberof ConsumerMetadataDto
   */
  modifiedBy: string
  /**
   * Description of the node
   * @type {string}
   * @memberof ConsumerMetadataDto
   */
  description?: string
  /**
   *
   * @type {NodeType}
   * @memberof ConsumerMetadataDto
   */
  type: NodeType
  /**
   * Tracks the amount of bytes used by the stored data.
   * @type {number}
   * @memberof ConsumerMetadataDto
   */
  consumedFileStorage: number
}

/**
 *
 * @export
 * @interface CorsAwsCredentialExchangeOK
 */
export interface CorsAwsCredentialExchangeOK {
  /**
   *
   * @type {string}
   * @memberof CorsAwsCredentialExchangeOK
   */
  corsAwsCredentialExchangeOk?: string
}
/**
 *
 * @export
 * @interface CorsDeleteNodeOK
 */
export interface CorsDeleteNodeOK {
  /**
   *
   * @type {string}
   * @memberof CorsDeleteNodeOK
   */
  corsDeleteNodeOk?: string
}
/**
 *
 * @export
 * @interface CorsGetConfigOK
 */
export interface CorsGetConfigOK {
  /**
   *
   * @type {string}
   * @memberof CorsGetConfigOK
   */
  corsGetConfigOk?: string
}
/**
 *
 * @export
 * @interface CorsGetScannedFileInfoOK
 */
export interface CorsGetScannedFileInfoOK {
  /**
   *
   * @type {string}
   * @memberof CorsGetScannedFileInfoOK
   */
  corsGetScannedFileInfoOk?: string
}
/**
 *
 * @export
 * @interface CorsGetWellKnownJwksOK
 */
export interface CorsGetWellKnownJwksOK {
  /**
   *
   * @type {string}
   * @memberof CorsGetWellKnownJwksOK
   */
  corsGetWellKnownJwksOk?: string
}
/**
 *
 * @export
 * @interface CorsInitNodesOK
 */
export interface CorsInitNodesOK {
  /**
   *
   * @type {string}
   * @memberof CorsInitNodesOK
   */
  corsInitNodesOk?: string
}
/**
 *
 * @export
 * @interface CorsListNodeChildrenOK
 */
export interface CorsListNodeChildrenOK {
  /**
   *
   * @type {string}
   * @memberof CorsListNodeChildrenOK
   */
  corsListNodeChildrenOk?: string
}
/**
 *
 * @export
 * @interface CorsListRootNodeChildrenOK
 */
export interface CorsListRootNodeChildrenOK {
  /**
   *
   * @type {string}
   * @memberof CorsListRootNodeChildrenOK
   */
  corsListRootNodeChildrenOk?: string
}
/**
 *
 * @export
 * @interface CorsListScannedFilesOK
 */
export interface CorsListScannedFilesOK {
  /**
   *
   * @type {string}
   * @memberof CorsListScannedFilesOK
   */
  corsListScannedFilesOk?: string
}
/**
 *
 * @export
 * @interface CorsMoveNodeOK
 */
export interface CorsMoveNodeOK {
  /**
   *
   * @type {string}
   * @memberof CorsMoveNodeOK
   */
  corsMoveNodeOk?: string
}
/**
 *
 * @export
 * @interface CorsPermanentlyDeleteNodeOK
 */
export interface CorsPermanentlyDeleteNodeOK {
  /**
   *
   * @type {string}
   * @memberof CorsPermanentlyDeleteNodeOK
   */
  corsPermanentlyDeleteNodeOk?: string
}
/**
 *
 * @export
 * @interface CorsRestoreNodeFromTrashbinOK
 */
export interface CorsRestoreNodeFromTrashbinOK {
  /**
   *
   * @type {string}
   * @memberof CorsRestoreNodeFromTrashbinOK
   */
  corsRestoreNodeFromTrashbinOk?: string
}
/**
 *
 * @export
 * @interface CorsStartFileScanOK
 */
export interface CorsStartFileScanOK {
  /**
   *
   * @type {string}
   * @memberof CorsStartFileScanOK
   */
  corsStartFileScanOk?: string
}
/**
 *
 * @export
 * @interface CorsUpdateProfileDataOK
 */
export interface CorsUpdateProfileDataOK {
  /**
   *
   * @type {string}
   * @memberof CorsUpdateProfileDataOK
   */
  corsUpdateProfileDataOk?: string
}
/**
 *
 * @export
 * @interface CreateAccountInput
 */
export interface CreateAccountInput {
  /**
   * number that is used for profile DID derivation
   * @type {number}
   * @memberof CreateAccountInput
   */
  accountIndex: number
  /**
   * DID that is associated with the account number
   * @type {string}
   * @memberof CreateAccountInput
   */
  accountDid: string
  /**
   * JWT that proves ownership of profile DID by requester
   * @type {string}
   * @memberof CreateAccountInput
   */
  didProof: string
  /**
   * Alias of account
   * @type {string}
   * @memberof CreateAccountInput
   */
  alias?: string
  /**
   * Metadata of account
   * @type {object}
   * @memberof CreateAccountInput
   */
  metadata?: object
  /**
   * Description of account
   * @type {string}
   * @memberof CreateAccountInput
   */
  description?: string
}
/**
 *
 * @export
 * @interface CreateAccountOK
 */
export interface CreateAccountOK {
  /**
   *
   * @type {number}
   * @memberof CreateAccountOK
   */
  accountIndex: number
  /**
   *
   * @type {string}
   * @memberof CreateAccountOK
   */
  accountDid: string
  /**
   *
   * @type {object}
   * @memberof CreateAccountOK
   */
  metadata?: object
}
/**
 *
 * @export
 * @interface CreateNodeInput
 */
export interface CreateNodeInput {
  /**
   * Name of the item
   * @type {string}
   * @memberof CreateNodeInput
   */
  name: string
  /**
   *
   * @type {NodeType}
   * @memberof CreateNodeInput
   */
  type: NodeType
  /**
   * description of profile if creating a new profile
   * @type {string}
   * @memberof CreateNodeInput
   */
  description?: string
  /**
   * parent node id, if not provided then root element is used
   * @type {string}
   * @memberof CreateNodeInput
   */
  parentNodeId?: string
  /**
   *
   * @type {EdekInfo}
   * @memberof CreateNodeInput
   */
  edekInfo?: EdekInfo
  /**
   * A base64 encoded data encryption key, encrypted using VFS public key, required for node types [FILE, PROFILE]
   * @type {string}
   * @memberof CreateNodeInput
   */
  dek?: string
  /**
   * metadata of the node in stringified json format
   * @type {string}
   * @memberof CreateNodeInput
   */
  metadata?: string
}

/**
 *
 * @export
 * @interface CreateNodeOK
 */
export interface CreateNodeOK {
  /**
   *
   * @type {string}
   * @memberof CreateNodeOK
   */
  nodeId: string
  /**
   *
   * @type {string}
   * @memberof CreateNodeOK
   */
  url?: string
  /**
   *
   * @type {string}
   * @memberof CreateNodeOK
   */
  link?: string
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof CreateNodeOK
   */
  fields?: { [key: string]: any }
}
/**
 *
 * @export
 * @interface DeleteAccountDto
 */
export interface DeleteAccountDto {
  /**
   *
   * @type {number}
   * @memberof DeleteAccountDto
   */
  accountIndex?: number
}
/**
 *
 * @export
 * @interface DeleteNodeDto
 */
export interface DeleteNodeDto {
  /**
   *
   * @type {string}
   * @memberof DeleteNodeDto
   */
  newNodeId?: string
}
/**
 * A base64 encoded data encryption key, encrypted with consumer DEKEK, required for node types [FILE, PROFILE]
 * @export
 * @interface EdekInfo
 */
export interface EdekInfo {
  /**
   *
   * @type {string}
   * @memberof EdekInfo
   */
  edek: string
  /**
   *
   * @type {string}
   * @memberof EdekInfo
   */
  dekekId: string
}
/**
 *
 * @export
 * @interface GetConfigOK
 */
export interface GetConfigOK {
  /**
   *
   * @type {string}
   * @memberof GetConfigOK
   */
  profileName: string
  /**
   *
   * @type {number}
   * @memberof GetConfigOK
   */
  maximumProfiles: number
}
/**
 *
 * @export
 * @interface GetDetailedNodeInfoOK
 */
export interface GetDetailedNodeInfoOK {
  /**
   * A unique identifier of current node
   * @type {string}
   * @memberof GetDetailedNodeInfoOK
   */
  nodeId: string
  /**
   *
   * @type {NodeStatus}
   * @memberof GetDetailedNodeInfoOK
   */
  status: NodeStatus
  /**
   * number of files in current node
   * @type {number}
   * @memberof GetDetailedNodeInfoOK
   */
  fileCount?: number
  /**
   * number of profiles in current node
   * @type {number}
   * @memberof GetDetailedNodeInfoOK
   */
  profileCount?: number
  /**
   * number of folders in current node
   * @type {number}
   * @memberof GetDetailedNodeInfoOK
   */
  folderCount?: number
  /**
   * number of vcCount in current node
   * @type {number}
   * @memberof GetDetailedNodeInfoOK
   */
  vcCount?: number
  /**
   * display name of current node
   * @type {string}
   * @memberof GetDetailedNodeInfoOK
   */
  name: string
  /**
   * unique identifier for consumer
   * @type {string}
   * @memberof GetDetailedNodeInfoOK
   */
  consumerId: string
  /**
   * parent node path
   * @type {string}
   * @memberof GetDetailedNodeInfoOK
   */
  parentNodeId: string
  /**
   * A unique identifier of profile, under which current node is created
   * @type {string}
   * @memberof GetDetailedNodeInfoOK
   */
  profileId: string
  /**
   * creation date/time of the node
   * @type {string}
   * @memberof GetDetailedNodeInfoOK
   */
  createdAt: string
  /**
   * modification date/time of the node
   * @type {string}
   * @memberof GetDetailedNodeInfoOK
   */
  modifiedAt: string
  /**
   * Identifier of the user who created the node
   * @type {string}
   * @memberof GetDetailedNodeInfoOK
   */
  createdBy: string
  /**
   * Identifier of the user who last updated the node
   * @type {string}
   * @memberof GetDetailedNodeInfoOK
   */
  modifiedBy: string
  /**
   * Description of the node
   * @type {string}
   * @memberof GetDetailedNodeInfoOK
   */
  description?: string
  /**
   *
   * @type {NodeType}
   * @memberof GetDetailedNodeInfoOK
   */
  type: NodeType
  /**
   * id of the file, used for FILE node only
   * @type {string}
   * @memberof GetDetailedNodeInfoOK
   */
  link?: string
  /**
   * name of the schema, used for PROFILE node only
   * @type {string}
   * @memberof GetDetailedNodeInfoOK
   */
  schema?: string
  /**
   * amount of bytes used by the stored data, used for ROOT_ELEMENT only for now
   * @type {number}
   * @memberof GetDetailedNodeInfoOK
   */
  consumedFileStorage?: number
  /**
   *
   * @type {EdekInfo}
   * @memberof GetDetailedNodeInfoOK
   */
  edekInfo?: EdekInfo
  /**
   * A JSON string format containing metadata of the node
   * @type {string}
   * @memberof GetDetailedNodeInfoOK
   */
  metadata?: string
  /**
   *
   * @type {string}
   * @memberof GetDetailedNodeInfoOK
   */
  getUrl?: string
}

/**
 *
 * @export
 * @interface GetScannedFileInfoOK
 */
export interface GetScannedFileInfoOK {
  /**
   *
   * @type {object}
   * @memberof GetScannedFileInfoOK
   */
  data: object
  /**
   * A unique, randomly generated idetifier
   * @type {string}
   * @memberof GetScannedFileInfoOK
   */
  jobId: string
  /**
   * Status of the file scanning once initiated
   * @type {string}
   * @memberof GetScannedFileInfoOK
   */
  status: string
  /**
   * A unique, randomly generated identifier
   * @type {string}
   * @memberof GetScannedFileInfoOK
   */
  profileId: string
  /**
   * The base64url encoded key of the first item that this operation will evaluate (it is not returned). Use the value that was returned in the previous operation.
   * @type {string}
   * @memberof GetScannedFileInfoOK
   */
  exclusiveStartKey?: string
  /**
   * A unique, randomly generated identifier
   * @type {string}
   * @memberof GetScannedFileInfoOK
   */
  nodeId: string
  /**
   *
   * @type {string}
   * @memberof GetScannedFileInfoOK
   */
  createdAt: string
  /**
   *
   * @type {string}
   * @memberof GetScannedFileInfoOK
   */
  name: string
}
/**
 *
 * @export
 * @interface InitNodesOK
 */
export interface InitNodesOK {
  /**
   *
   * @type {ConsumerMetadataDto}
   * @memberof InitNodesOK
   */
  consumerMetadata?: ConsumerMetadataDto
  /**
   *
   * @type {NodeDto}
   * @memberof InitNodesOK
   */
  defaultProfile?: NodeDto
}
/**
 * Some of the parameters are invalid
 * @export
 * @interface InvalidParameterError
 */
export interface InvalidParameterError {
  /**
   *
   * @type {string}
   * @memberof InvalidParameterError
   */
  name: InvalidParameterErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof InvalidParameterError
   */
  message: InvalidParameterErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof InvalidParameterError
   */
  httpStatusCode: InvalidParameterErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof InvalidParameterError
   */
  traceId: string
  /**
   *
   * @type {Array<InvalidParameterErrorDetailsInner>}
   * @memberof InvalidParameterError
   */
  details?: Array<InvalidParameterErrorDetailsInner>
}

export const InvalidParameterErrorNameEnum = {
  InvalidParameterError: 'InvalidParameterError',
} as const

export type InvalidParameterErrorNameEnum =
  (typeof InvalidParameterErrorNameEnum)[keyof typeof InvalidParameterErrorNameEnum]
export const InvalidParameterErrorMessageEnum = {
  InvalidParameterParam: 'Invalid parameter: ${param}.',
} as const

export type InvalidParameterErrorMessageEnum =
  (typeof InvalidParameterErrorMessageEnum)[keyof typeof InvalidParameterErrorMessageEnum]
export const InvalidParameterErrorHttpStatusCodeEnum = {
  NUMBER_400: 400,
} as const

export type InvalidParameterErrorHttpStatusCodeEnum =
  (typeof InvalidParameterErrorHttpStatusCodeEnum)[keyof typeof InvalidParameterErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface InvalidParameterErrorDetailsInner
 */
export interface InvalidParameterErrorDetailsInner {
  /**
   *
   * @type {string}
   * @memberof InvalidParameterErrorDetailsInner
   */
  issue: string
  /**
   *
   * @type {string}
   * @memberof InvalidParameterErrorDetailsInner
   */
  field?: string
  /**
   *
   * @type {string}
   * @memberof InvalidParameterErrorDetailsInner
   */
  value?: string
  /**
   *
   * @type {string}
   * @memberof InvalidParameterErrorDetailsInner
   */
  location?: string
}
/**
 *
 * @export
 * @interface JsonWebKeyDto
 */
export interface JsonWebKeyDto {
  /**
   *
   * @type {string}
   * @memberof JsonWebKeyDto
   */
  kid: string
  /**
   *
   * @type {string}
   * @memberof JsonWebKeyDto
   */
  kty: string
  /**
   *
   * @type {string}
   * @memberof JsonWebKeyDto
   */
  n?: string
  /**
   *
   * @type {string}
   * @memberof JsonWebKeyDto
   */
  e?: string
  /**
   *
   * @type {string}
   * @memberof JsonWebKeyDto
   */
  x?: string
  /**
   *
   * @type {string}
   * @memberof JsonWebKeyDto
   */
  y?: string
  /**
   *
   * @type {string}
   * @memberof JsonWebKeyDto
   */
  crv?: string
  /**
   *
   * @type {string}
   * @memberof JsonWebKeyDto
   */
  alg: string
  /**
   *
   * @type {string}
   * @memberof JsonWebKeyDto
   */
  use: string
}
/**
 *
 * @export
 * @interface JsonWebKeySetDto
 */
export interface JsonWebKeySetDto {
  /**
   *
   * @type {Array<JsonWebKeyDto>}
   * @memberof JsonWebKeySetDto
   */
  keys: Array<JsonWebKeyDto>
}
/**
 *
 * @export
 * @interface ListAccountsDto
 */
export interface ListAccountsDto {
  /**
   *
   * @type {Array<AccountDto>}
   * @memberof ListAccountsDto
   */
  records: Array<AccountDto>
  /**
   *
   * @type {string}
   * @memberof ListAccountsDto
   */
  lastEvaluatedKey?: string
}
/**
 *
 * @export
 * @interface ListNodeChildrenOK
 */
export interface ListNodeChildrenOK {
  /**
   *
   * @type {Array<NodeDto>}
   * @memberof ListNodeChildrenOK
   */
  nodes?: Array<NodeDto>
  /**
   *
   * @type {string}
   * @memberof ListNodeChildrenOK
   */
  lastEvaluatedKey?: string
}
/**
 *
 * @export
 * @interface ListRootNodeChildrenOK
 */
export interface ListRootNodeChildrenOK {
  /**
   *
   * @type {Array<NodeDto>}
   * @memberof ListRootNodeChildrenOK
   */
  nodes?: Array<NodeDto>
}
/**
 *
 * @export
 * @interface ListScannedFilesOK
 */
export interface ListScannedFilesOK {
  /**
   *
   * @type {Array<ListScannedFilesOKScannedFilesInner>}
   * @memberof ListScannedFilesOK
   */
  scannedFiles: Array<ListScannedFilesOKScannedFilesInner>
}
/**
 *
 * @export
 * @interface ListScannedFilesOKScannedFilesInner
 */
export interface ListScannedFilesOKScannedFilesInner {
  /**
   * A unique, randomly generated identifier
   * @type {string}
   * @memberof ListScannedFilesOKScannedFilesInner
   */
  jobId: string
  /**
   * The Status of the listed files
   * @type {string}
   * @memberof ListScannedFilesOKScannedFilesInner
   */
  status: string
  /**
   * A unique, randomly generated identifier
   * @type {string}
   * @memberof ListScannedFilesOKScannedFilesInner
   */
  profileId: string
  /**
   *
   * @type {string}
   * @memberof ListScannedFilesOKScannedFilesInner
   */
  nodeId: string
  /**
   *
   * @type {string}
   * @memberof ListScannedFilesOKScannedFilesInner
   */
  createdAt: string
  /**
   *
   * @type {string}
   * @memberof ListScannedFilesOKScannedFilesInner
   */
  name: string
}
/**
 *
 * @export
 * @interface MoveNodeDto
 */
export interface MoveNodeDto {
  /**
   *
   * @type {string}
   * @memberof MoveNodeDto
   */
  newNodeId?: string
}
/**
 *
 * @export
 * @interface MoveNodeInput
 */
export interface MoveNodeInput {
  /**
   * Parent to which current node should be moved
   * @type {string}
   * @memberof MoveNodeInput
   */
  destinationNodeId: string
  /**
   * automatically update the name of Node if target Node has children with the same name. If not provided, name won\'t be updated automatically
   * @type {boolean}
   * @memberof MoveNodeInput
   */
  resolveNameConflictsAutomatically?: boolean
}
/**
 *
 * @export
 * @interface NodeDto
 */
export interface NodeDto {
  /**
   * A unique identifier of current node
   * @type {string}
   * @memberof NodeDto
   */
  nodeId: string
  /**
   *
   * @type {NodeStatus}
   * @memberof NodeDto
   */
  status: NodeStatus
  /**
   * number of files in current node
   * @type {number}
   * @memberof NodeDto
   */
  fileCount?: number
  /**
   * number of profiles in current node
   * @type {number}
   * @memberof NodeDto
   */
  profileCount?: number
  /**
   * number of folders in current node
   * @type {number}
   * @memberof NodeDto
   */
  folderCount?: number
  /**
   * number of vcCount in current node
   * @type {number}
   * @memberof NodeDto
   */
  vcCount?: number
  /**
   * display name of current node
   * @type {string}
   * @memberof NodeDto
   */
  name: string
  /**
   * unique identifier for consumer
   * @type {string}
   * @memberof NodeDto
   */
  consumerId: string
  /**
   * parent node path
   * @type {string}
   * @memberof NodeDto
   */
  parentNodeId: string
  /**
   * A unique identifier of profile, under which current node is created
   * @type {string}
   * @memberof NodeDto
   */
  profileId: string
  /**
   * creation date/time of the node
   * @type {string}
   * @memberof NodeDto
   */
  createdAt: string
  /**
   * modification date/time of the node
   * @type {string}
   * @memberof NodeDto
   */
  modifiedAt: string
  /**
   * Identifier of the user who created the node
   * @type {string}
   * @memberof NodeDto
   */
  createdBy: string
  /**
   * Identifier of the user who last updated the node
   * @type {string}
   * @memberof NodeDto
   */
  modifiedBy: string
  /**
   * Description of the node
   * @type {string}
   * @memberof NodeDto
   */
  description?: string
  /**
   *
   * @type {NodeType}
   * @memberof NodeDto
   */
  type: NodeType
  /**
   * id of the file, used for FILE node only
   * @type {string}
   * @memberof NodeDto
   */
  link?: string
  /**
   * name of the schema, used for PROFILE node only
   * @type {string}
   * @memberof NodeDto
   */
  schema?: string
  /**
   * amount of bytes used by the stored data, used for ROOT_ELEMENT only for now
   * @type {number}
   * @memberof NodeDto
   */
  consumedFileStorage?: number
  /**
   *
   * @type {EdekInfo}
   * @memberof NodeDto
   */
  edekInfo?: EdekInfo
  /**
   * A JSON string format containing metadata of the node
   * @type {string}
   * @memberof NodeDto
   */
  metadata?: string
}

/**
 * status of current node. INITIALIZED status is used for PROFILE/FILE node that was just created, before file was uploaded in s3 CREATED status is used, when the file for node is uploaded in s3. HIDDEN and DELETED statuses are used for deletion of Nodes
 * @export
 * @enum {string}
 */

export const NodeStatus = {
  NotSet: 'NOT_SET',
  Hidden: 'HIDDEN',
  Deleted: 'DELETED',
  Initialized: 'INITIALIZED',
  Created: 'CREATED',
} as const

export type NodeStatus = (typeof NodeStatus)[keyof typeof NodeStatus]

/**
 * type of the Node
 * @export
 * @enum {string}
 */

export const NodeType = {
  VcRoot: 'VC_ROOT',
  Vc: 'VC',
  File: 'FILE',
  Folder: 'FOLDER',
  Profile: 'PROFILE',
  RootElement: 'ROOT_ELEMENT',
  TrashBin: 'TRASH_BIN',
} as const

export type NodeType = (typeof NodeType)[keyof typeof NodeType]

/**
 *
 * @export
 * @interface NotFoundError
 */
export interface NotFoundError {
  /**
   *
   * @type {string}
   * @memberof NotFoundError
   */
  name: NotFoundErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof NotFoundError
   */
  message: NotFoundErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof NotFoundError
   */
  httpStatusCode: NotFoundErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof NotFoundError
   */
  traceId: string
  /**
   *
   * @type {Array<InvalidParameterErrorDetailsInner>}
   * @memberof NotFoundError
   */
  details?: Array<InvalidParameterErrorDetailsInner>
}

export const NotFoundErrorNameEnum = {
  NotFoundError: 'NotFoundError',
} as const

export type NotFoundErrorNameEnum =
  (typeof NotFoundErrorNameEnum)[keyof typeof NotFoundErrorNameEnum]
export const NotFoundErrorMessageEnum = {
  NotFoundParam: 'Not found: ${param}.',
} as const

export type NotFoundErrorMessageEnum =
  (typeof NotFoundErrorMessageEnum)[keyof typeof NotFoundErrorMessageEnum]
export const NotFoundErrorHttpStatusCodeEnum = {
  NUMBER_404: 404,
} as const

export type NotFoundErrorHttpStatusCodeEnum =
  (typeof NotFoundErrorHttpStatusCodeEnum)[keyof typeof NotFoundErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface QueryProfileDataOK
 */
export interface QueryProfileDataOK {
  /**
   *
   * @type {object}
   * @memberof QueryProfileDataOK
   */
  data?: object
}
/**
 *
 * @export
 * @interface RestoreNodeFromTrashbin
 */
export interface RestoreNodeFromTrashbin {
  /**
   * The base64 encoded nodeId of the profile which is base64 encoded, to which node will be restored
   * @type {string}
   * @memberof RestoreNodeFromTrashbin
   */
  restoreToProfileId?: string
}
/**
 *
 * @export
 * @interface StartFileScanInput
 */
export interface StartFileScanInput {
  /**
   * A base64 encoded data encryption key, encrypted using VFS public key. This is important as this is used when starting document scan and also while uploading the file to s3
   * @type {string}
   * @memberof StartFileScanInput
   */
  dek: string
}
/**
 *
 * @export
 * @interface StartFileScanOK
 */
export interface StartFileScanOK {
  /**
   *
   * @type {string}
   * @memberof StartFileScanOK
   */
  jobId: string
  /**
   *
   * @type {string}
   * @memberof StartFileScanOK
   */
  status: StartFileScanOKStatusEnum
}

export const StartFileScanOKStatusEnum = {
  Started: 'STARTED',
  Failed: 'FAILED',
  Completed: 'COMPLETED',
} as const

export type StartFileScanOKStatusEnum =
  (typeof StartFileScanOKStatusEnum)[keyof typeof StartFileScanOKStatusEnum]

/**
 *
 * @export
 * @interface UnexpectedError
 */
export interface UnexpectedError {
  /**
   *
   * @type {string}
   * @memberof UnexpectedError
   */
  name: UnexpectedErrorNameEnum
  /**
   *
   * @type {string}
   * @memberof UnexpectedError
   */
  message: UnexpectedErrorMessageEnum
  /**
   *
   * @type {number}
   * @memberof UnexpectedError
   */
  httpStatusCode: UnexpectedErrorHttpStatusCodeEnum
  /**
   *
   * @type {string}
   * @memberof UnexpectedError
   */
  traceId: string
  /**
   *
   * @type {Array<InvalidParameterErrorDetailsInner>}
   * @memberof UnexpectedError
   */
  details?: Array<InvalidParameterErrorDetailsInner>
}

export const UnexpectedErrorNameEnum = {
  UnexpectedError: 'UnexpectedError',
} as const

export type UnexpectedErrorNameEnum =
  (typeof UnexpectedErrorNameEnum)[keyof typeof UnexpectedErrorNameEnum]
export const UnexpectedErrorMessageEnum = {
  UnexpectedErrorOccurred: 'Unexpected Error Occurred.',
} as const

export type UnexpectedErrorMessageEnum =
  (typeof UnexpectedErrorMessageEnum)[keyof typeof UnexpectedErrorMessageEnum]
export const UnexpectedErrorHttpStatusCodeEnum = {
  NUMBER_500: 500,
} as const

export type UnexpectedErrorHttpStatusCodeEnum =
  (typeof UnexpectedErrorHttpStatusCodeEnum)[keyof typeof UnexpectedErrorHttpStatusCodeEnum]

/**
 *
 * @export
 * @interface UpdateAccountDto
 */
export interface UpdateAccountDto {
  /**
   *
   * @type {number}
   * @memberof UpdateAccountDto
   */
  accountIndex: number
  /**
   * Profile DID that is associated with the account number
   * @type {string}
   * @memberof UpdateAccountDto
   */
  accountDid: string
  /**
   *
   * @type {object}
   * @memberof UpdateAccountDto
   */
  metadata?: object
}
/**
 *
 * @export
 * @interface UpdateAccountInput
 */
export interface UpdateAccountInput {
  /**
   * Name of the account
   * @type {string}
   * @memberof UpdateAccountInput
   */
  name: string
  /**
   * Description of the account
   * @type {string}
   * @memberof UpdateAccountInput
   */
  description: string
  /**
   * Alias of the account
   * @type {string}
   * @memberof UpdateAccountInput
   */
  alias?: string
  /**
   * JWT that proves ownership of profile DID by requester
   * @type {string}
   * @memberof UpdateAccountInput
   */
  didProof: string
  /**
   * Description of metadata
   * @type {object}
   * @memberof UpdateAccountInput
   */
  metadata?: object
  /**
   * DID that is associated with the account number
   * @type {string}
   * @memberof UpdateAccountInput
   */
  accountDid: string
}
/**
 *
 * @export
 * @interface UpdateNodeInput
 */
export interface UpdateNodeInput {
  /**
   * Name of the node
   * @type {string}
   * @memberof UpdateNodeInput
   */
  name?: string
  /**
   * Description of the node
   * @type {string}
   * @memberof UpdateNodeInput
   */
  description?: string
  /**
   * metadata of the node in stringified json format
   * @type {string}
   * @memberof UpdateNodeInput
   */
  metadata?: string
}
/**
 *
 * @export
 * @interface UpdateProfileDataInput
 */
export interface UpdateProfileDataInput {
  /**
   * A base64 encoded data encryption key, encrypted using VFS public key. This is used to get profile data from s3
   * @type {string}
   * @memberof UpdateProfileDataInput
   */
  dek: string
  /**
   *
   * @type {object}
   * @memberof UpdateProfileDataInput
   */
  data: object
}
/**
 *
 * @export
 * @interface UpdateProfileDataOK
 */
export interface UpdateProfileDataOK {
  /**
   *
   * @type {object}
   * @memberof UpdateProfileDataOK
   */
  data?: object
}

/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * creates account
     * @param {CreateAccountInput} createAccountInput CreateAccount
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAccount: async (
      createAccountInput: CreateAccountInput,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createAccountInput' is not null or undefined
      assertParamExists(
        'createAccount',
        'createAccountInput',
        createAccountInput,
      )
      const localVarPath = `/v1/accounts`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ConsumerTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        createAccountInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete account.
     * @param {number} accountIndex
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAccount: async (
      accountIndex: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountIndex' is not null or undefined
      assertParamExists('deleteAccount', 'accountIndex', accountIndex)
      const localVarPath = `/v1/accounts/{accountIndex}`.replace(
        `{${'accountIndex'}}`,
        encodeURIComponent(String(accountIndex)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ConsumerTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List accounts of associated profiles.
     * @param {number} [limit] Maximum number of accounts to fetch in a list
     * @param {string} [exclusiveStartKey] The base64url encoded key of the first item that this operation will evaluate (it is not returned). Use the value that was returned in the previous operation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAccounts: async (
      limit?: number,
      exclusiveStartKey?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/accounts`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ConsumerTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (exclusiveStartKey !== undefined) {
        localVarQueryParameter['exclusiveStartKey'] = exclusiveStartKey
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Update account.
     * @param {number} accountIndex
     * @param {UpdateAccountInput} updateAccountInput UpdateAccount
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAccount: async (
      accountIndex: number,
      updateAccountInput: UpdateAccountInput,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountIndex' is not null or undefined
      assertParamExists('updateAccount', 'accountIndex', accountIndex)
      // verify required parameter 'updateAccountInput' is not null or undefined
      assertParamExists(
        'updateAccount',
        'updateAccountInput',
        updateAccountInput,
      )
      const localVarPath = `/v1/accounts/{accountIndex}`.replace(
        `{${'accountIndex'}}`,
        encodeURIComponent(String(accountIndex)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ConsumerTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateAccountInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
  return {
    /**
     * creates account
     * @param {CreateAccountInput} createAccountInput CreateAccount
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createAccount(
      createAccountInput: CreateAccountInput,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<CreateAccountOK>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createAccount(
        createAccountInput,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['AccountsApi.createAccount']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Delete account.
     * @param {number} accountIndex
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteAccount(
      accountIndex: number,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<DeleteAccountDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccount(
        accountIndex,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['AccountsApi.deleteAccount']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * List accounts of associated profiles.
     * @param {number} [limit] Maximum number of accounts to fetch in a list
     * @param {string} [exclusiveStartKey] The base64url encoded key of the first item that this operation will evaluate (it is not returned). Use the value that was returned in the previous operation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listAccounts(
      limit?: number,
      exclusiveStartKey?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ListAccountsDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listAccounts(
        limit,
        exclusiveStartKey,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['AccountsApi.listAccounts']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Update account.
     * @param {number} accountIndex
     * @param {UpdateAccountInput} updateAccountInput UpdateAccount
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateAccount(
      accountIndex: number,
      updateAccountInput: UpdateAccountInput,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UpdateAccountDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateAccount(
        accountIndex,
        updateAccountInput,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['AccountsApi.updateAccount']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AccountsApiFp(configuration)
  return {
    /**
     * creates account
     * @param {CreateAccountInput} createAccountInput CreateAccount
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAccount(
      createAccountInput: CreateAccountInput,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<CreateAccountOK> {
      return localVarFp
        .createAccount(createAccountInput, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Delete account.
     * @param {number} accountIndex
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAccount(
      accountIndex: number,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<DeleteAccountDto> {
      return localVarFp
        .deleteAccount(accountIndex, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * List accounts of associated profiles.
     * @param {number} [limit] Maximum number of accounts to fetch in a list
     * @param {string} [exclusiveStartKey] The base64url encoded key of the first item that this operation will evaluate (it is not returned). Use the value that was returned in the previous operation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAccounts(
      limit?: number,
      exclusiveStartKey?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ListAccountsDto> {
      return localVarFp
        .listAccounts(limit, exclusiveStartKey, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Update account.
     * @param {number} accountIndex
     * @param {UpdateAccountInput} updateAccountInput UpdateAccount
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAccount(
      accountIndex: number,
      updateAccountInput: UpdateAccountInput,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<UpdateAccountDto> {
      return localVarFp
        .updateAccount(accountIndex, updateAccountInput, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
  /**
   * creates account
   * @param {CreateAccountInput} createAccountInput CreateAccount
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public createAccount(
    createAccountInput: CreateAccountInput,
    options?: RawAxiosRequestConfig,
  ) {
    return AccountsApiFp(this.configuration)
      .createAccount(createAccountInput, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Delete account.
   * @param {number} accountIndex
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public deleteAccount(accountIndex: number, options?: RawAxiosRequestConfig) {
    return AccountsApiFp(this.configuration)
      .deleteAccount(accountIndex, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List accounts of associated profiles.
   * @param {number} [limit] Maximum number of accounts to fetch in a list
   * @param {string} [exclusiveStartKey] The base64url encoded key of the first item that this operation will evaluate (it is not returned). Use the value that was returned in the previous operation.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public listAccounts(
    limit?: number,
    exclusiveStartKey?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return AccountsApiFp(this.configuration)
      .listAccounts(limit, exclusiveStartKey, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Update account.
   * @param {number} accountIndex
   * @param {UpdateAccountInput} updateAccountInput UpdateAccount
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public updateAccount(
    accountIndex: number,
    updateAccountInput: UpdateAccountInput,
    options?: RawAxiosRequestConfig,
  ) {
    return AccountsApiFp(this.configuration)
      .updateAccount(accountIndex, updateAccountInput, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ConfigApi - axios parameter creator
 * @export
 */
export const ConfigApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Retrieves the user profile name and the maximum number of profiles, with default values set to \'default\' and 1, respectively.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConfig: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/config`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AwsSigV4 required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'Authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ConfigApi - functional programming interface
 * @export
 */
export const ConfigApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ConfigApiAxiosParamCreator(configuration)
  return {
    /**
     * Retrieves the user profile name and the maximum number of profiles, with default values set to \'default\' and 1, respectively.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getConfig(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetConfigOK>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getConfig(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ConfigApi.getConfig']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * ConfigApi - factory interface
 * @export
 */
export const ConfigApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ConfigApiFp(configuration)
  return {
    /**
     * Retrieves the user profile name and the maximum number of profiles, with default values set to \'default\' and 1, respectively.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConfig(options?: RawAxiosRequestConfig): AxiosPromise<GetConfigOK> {
      return localVarFp
        .getConfig(options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ConfigApi - object-oriented interface
 * @export
 * @class ConfigApi
 * @extends {BaseAPI}
 */
export class ConfigApi extends BaseAPI {
  /**
   * Retrieves the user profile name and the maximum number of profiles, with default values set to \'default\' and 1, respectively.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConfigApi
   */
  public getConfig(options?: RawAxiosRequestConfig) {
    return ConfigApiFp(this.configuration)
      .getConfig(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * FilesApi - axios parameter creator
 * @export
 */
export const FilesApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Get the details of a scanned file using the textract jobId
     * @param {string} scannedFileJobId Scanned file jobId.
     * @param {string} [exclusiveStartKey] The base64url encoded key of the first item that this operation will evaluate (it is not returned). Use the value that was returned in the previous operation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getScannedFileInfo: async (
      scannedFileJobId: string,
      exclusiveStartKey?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'scannedFileJobId' is not null or undefined
      assertParamExists(
        'getScannedFileInfo',
        'scannedFileJobId',
        scannedFileJobId,
      )
      const localVarPath = `/v1/scanned-files/{scannedFileJobId}`.replace(
        `{${'scannedFileJobId'}}`,
        encodeURIComponent(String(scannedFileJobId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ConsumerTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      if (exclusiveStartKey !== undefined) {
        localVarQueryParameter['exclusiveStartKey'] = exclusiveStartKey
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * List all the the scanned files with all the details, e.g. status and jobId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listScannedFiles: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/scanned-files/`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ConsumerTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Start a scan of the file under this node and provide a textract job
     * @param {string} nodeId Description for nodeId.
     * @param {StartFileScanInput} startFileScanInput StartFileScan
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startFileScan: async (
      nodeId: string,
      startFileScanInput: StartFileScanInput,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'nodeId' is not null or undefined
      assertParamExists('startFileScan', 'nodeId', nodeId)
      // verify required parameter 'startFileScanInput' is not null or undefined
      assertParamExists(
        'startFileScan',
        'startFileScanInput',
        startFileScanInput,
      )
      const localVarPath = `/v1/nodes/{nodeId}/file/scan`.replace(
        `{${'nodeId'}}`,
        encodeURIComponent(String(nodeId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ConsumerTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        startFileScanInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * FilesApi - functional programming interface
 * @export
 */
export const FilesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = FilesApiAxiosParamCreator(configuration)
  return {
    /**
     * Get the details of a scanned file using the textract jobId
     * @param {string} scannedFileJobId Scanned file jobId.
     * @param {string} [exclusiveStartKey] The base64url encoded key of the first item that this operation will evaluate (it is not returned). Use the value that was returned in the previous operation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getScannedFileInfo(
      scannedFileJobId: string,
      exclusiveStartKey?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<GetScannedFileInfoOK>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getScannedFileInfo(
          scannedFileJobId,
          exclusiveStartKey,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['FilesApi.getScannedFileInfo']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * List all the the scanned files with all the details, e.g. status and jobId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listScannedFiles(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ListScannedFilesOK>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listScannedFiles(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['FilesApi.listScannedFiles']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Start a scan of the file under this node and provide a textract job
     * @param {string} nodeId Description for nodeId.
     * @param {StartFileScanInput} startFileScanInput StartFileScan
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async startFileScan(
      nodeId: string,
      startFileScanInput: StartFileScanInput,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<StartFileScanOK>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.startFileScan(
        nodeId,
        startFileScanInput,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['FilesApi.startFileScan']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * FilesApi - factory interface
 * @export
 */
export const FilesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = FilesApiFp(configuration)
  return {
    /**
     * Get the details of a scanned file using the textract jobId
     * @param {string} scannedFileJobId Scanned file jobId.
     * @param {string} [exclusiveStartKey] The base64url encoded key of the first item that this operation will evaluate (it is not returned). Use the value that was returned in the previous operation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getScannedFileInfo(
      scannedFileJobId: string,
      exclusiveStartKey?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GetScannedFileInfoOK> {
      return localVarFp
        .getScannedFileInfo(scannedFileJobId, exclusiveStartKey, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * List all the the scanned files with all the details, e.g. status and jobId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listScannedFiles(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ListScannedFilesOK> {
      return localVarFp
        .listScannedFiles(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Start a scan of the file under this node and provide a textract job
     * @param {string} nodeId Description for nodeId.
     * @param {StartFileScanInput} startFileScanInput StartFileScan
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startFileScan(
      nodeId: string,
      startFileScanInput: StartFileScanInput,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<StartFileScanOK> {
      return localVarFp
        .startFileScan(nodeId, startFileScanInput, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export class FilesApi extends BaseAPI {
  /**
   * Get the details of a scanned file using the textract jobId
   * @param {string} scannedFileJobId Scanned file jobId.
   * @param {string} [exclusiveStartKey] The base64url encoded key of the first item that this operation will evaluate (it is not returned). Use the value that was returned in the previous operation.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FilesApi
   */
  public getScannedFileInfo(
    scannedFileJobId: string,
    exclusiveStartKey?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return FilesApiFp(this.configuration)
      .getScannedFileInfo(scannedFileJobId, exclusiveStartKey, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * List all the the scanned files with all the details, e.g. status and jobId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FilesApi
   */
  public listScannedFiles(options?: RawAxiosRequestConfig) {
    return FilesApiFp(this.configuration)
      .listScannedFiles(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Start a scan of the file under this node and provide a textract job
   * @param {string} nodeId Description for nodeId.
   * @param {StartFileScanInput} startFileScanInput StartFileScan
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FilesApi
   */
  public startFileScan(
    nodeId: string,
    startFileScanInput: StartFileScanInput,
    options?: RawAxiosRequestConfig,
  ) {
    return FilesApiFp(this.configuration)
      .startFileScan(nodeId, startFileScanInput, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * NodesApi - axios parameter creator
 * @export
 */
export const NodesApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * creates node
     * @param {CreateNodeInput} createNodeInput CreateNode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNode: async (
      createNodeInput: CreateNodeInput,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createNodeInput' is not null or undefined
      assertParamExists('createNode', 'createNodeInput', createNodeInput)
      const localVarPath = `/v1/nodes`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ConsumerTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        createNodeInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Mark a node and any attached files for deletion. If the node is a folder, perform the same action for all its children if the profile type is PROFILE, VC_ROOT, or VC. For other node types, move them to the TRASH_BIN node.
     * @param {string} nodeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteNode: async (
      nodeId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'nodeId' is not null or undefined
      assertParamExists('deleteNode', 'nodeId', nodeId)
      const localVarPath = `/v1/nodes/{nodeId}`.replace(
        `{${'nodeId'}}`,
        encodeURIComponent(String(nodeId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ConsumerTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Gets detailed information about the node
     * @param {string} nodeId
     * @param {string} [dek] A base64url encoded data encryption key, encrypted using VFS public key. getUrl will not be returned if dek is not provided
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDetailedNodeInfo: async (
      nodeId: string,
      dek?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'nodeId' is not null or undefined
      assertParamExists('getDetailedNodeInfo', 'nodeId', nodeId)
      const localVarPath = `/v1/nodes/{nodeId}`.replace(
        `{${'nodeId'}}`,
        encodeURIComponent(String(nodeId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ConsumerTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      if (dek !== undefined) {
        localVarQueryParameter['dek'] = dek
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Initialize root node, and TRASH_BIN
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    initNodes: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/nodes/init`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ConsumerTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * lists children of the node
     * @param {string} nodeId Description for nodeId.
     * @param {number} [limit] Maximum number of records to fetch in a list
     * @param {string} [exclusiveStartKey] exclusiveStartKey for retrieving the next batch of data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listNodeChildren: async (
      nodeId: string,
      limit?: number,
      exclusiveStartKey?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'nodeId' is not null or undefined
      assertParamExists('listNodeChildren', 'nodeId', nodeId)
      const localVarPath = `/v1/nodes/{nodeId}/children`.replace(
        `{${'nodeId'}}`,
        encodeURIComponent(String(nodeId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ConsumerTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (exclusiveStartKey !== undefined) {
        localVarQueryParameter['exclusiveStartKey'] = exclusiveStartKey
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * lists children of the root node for the consumer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listRootNodeChildren: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/nodes`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ConsumerTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Moves a node from source to destination along with the hierarchy
     * @param {string} nodeId
     * @param {MoveNodeInput} moveNodeInput MoveNode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    moveNode: async (
      nodeId: string,
      moveNodeInput: MoveNodeInput,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'nodeId' is not null or undefined
      assertParamExists('moveNode', 'nodeId', nodeId)
      // verify required parameter 'moveNodeInput' is not null or undefined
      assertParamExists('moveNode', 'moveNodeInput', moveNodeInput)
      const localVarPath = `/v1/nodes/{nodeId}/move`.replace(
        `{${'nodeId'}}`,
        encodeURIComponent(String(nodeId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ConsumerTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        moveNodeInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Permanently delete a node from TRASH_BIN, if the node is not in the TRASH_BIN it cannot delete.
     * @param {string} nodeId nodeId of the TRASH_BIN
     * @param {string} nodeIdToRemove nodeId of the node to be deleted from TRASH_BIN
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    permanentlyDeleteNode: async (
      nodeId: string,
      nodeIdToRemove: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'nodeId' is not null or undefined
      assertParamExists('permanentlyDeleteNode', 'nodeId', nodeId)
      // verify required parameter 'nodeIdToRemove' is not null or undefined
      assertParamExists(
        'permanentlyDeleteNode',
        'nodeIdToRemove',
        nodeIdToRemove,
      )
      const localVarPath = `/v1/nodes/{nodeId}/remove/{nodeIdToRemove}`
        .replace(`{${'nodeId'}}`, encodeURIComponent(String(nodeId)))
        .replace(
          `{${'nodeIdToRemove'}}`,
          encodeURIComponent(String(nodeIdToRemove)),
        )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ConsumerTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Restore node marked for deletion from TRASH_BIN
     * @param {string} nodeId nodeId of the TRASH_BIN
     * @param {string} nodeIdToRestore nodeId of the node to be restored from TRASH_BIN
     * @param {RestoreNodeFromTrashbin} restoreNodeFromTrashbin RestoreNodeFromTrashbin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    restoreNodeFromTrashbin: async (
      nodeId: string,
      nodeIdToRestore: string,
      restoreNodeFromTrashbin: RestoreNodeFromTrashbin,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'nodeId' is not null or undefined
      assertParamExists('restoreNodeFromTrashbin', 'nodeId', nodeId)
      // verify required parameter 'nodeIdToRestore' is not null or undefined
      assertParamExists(
        'restoreNodeFromTrashbin',
        'nodeIdToRestore',
        nodeIdToRestore,
      )
      // verify required parameter 'restoreNodeFromTrashbin' is not null or undefined
      assertParamExists(
        'restoreNodeFromTrashbin',
        'restoreNodeFromTrashbin',
        restoreNodeFromTrashbin,
      )
      const localVarPath = `/v1/nodes/{nodeId}/restore/{nodeIdToRestore}`
        .replace(`{${'nodeId'}}`, encodeURIComponent(String(nodeId)))
        .replace(
          `{${'nodeIdToRestore'}}`,
          encodeURIComponent(String(nodeIdToRestore)),
        )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ConsumerTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        restoreNodeFromTrashbin,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Updates a node
     * @param {string} nodeId Description for nodeId.
     * @param {UpdateNodeInput} updateNodeInput UpdateNodeInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateNode: async (
      nodeId: string,
      updateNodeInput: UpdateNodeInput,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'nodeId' is not null or undefined
      assertParamExists('updateNode', 'nodeId', nodeId)
      // verify required parameter 'updateNodeInput' is not null or undefined
      assertParamExists('updateNode', 'updateNodeInput', updateNodeInput)
      const localVarPath = `/v1/nodes/{nodeId}`.replace(
        `{${'nodeId'}}`,
        encodeURIComponent(String(nodeId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ConsumerTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateNodeInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * NodesApi - functional programming interface
 * @export
 */
export const NodesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = NodesApiAxiosParamCreator(configuration)
  return {
    /**
     * creates node
     * @param {CreateNodeInput} createNodeInput CreateNode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createNode(
      createNodeInput: CreateNodeInput,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateNodeOK>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createNode(
        createNodeInput,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['NodesApi.createNode']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Mark a node and any attached files for deletion. If the node is a folder, perform the same action for all its children if the profile type is PROFILE, VC_ROOT, or VC. For other node types, move them to the TRASH_BIN node.
     * @param {string} nodeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteNode(
      nodeId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteNodeDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNode(
        nodeId,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['NodesApi.deleteNode']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Gets detailed information about the node
     * @param {string} nodeId
     * @param {string} [dek] A base64url encoded data encryption key, encrypted using VFS public key. getUrl will not be returned if dek is not provided
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDetailedNodeInfo(
      nodeId: string,
      dek?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<GetDetailedNodeInfoOK>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getDetailedNodeInfo(
          nodeId,
          dek,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['NodesApi.getDetailedNodeInfo']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Initialize root node, and TRASH_BIN
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async initNodes(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<InitNodesOK>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.initNodes(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['NodesApi.initNodes']?.[localVarOperationServerIndex]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * lists children of the node
     * @param {string} nodeId Description for nodeId.
     * @param {number} [limit] Maximum number of records to fetch in a list
     * @param {string} [exclusiveStartKey] exclusiveStartKey for retrieving the next batch of data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listNodeChildren(
      nodeId: string,
      limit?: number,
      exclusiveStartKey?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ListNodeChildrenOK>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listNodeChildren(
          nodeId,
          limit,
          exclusiveStartKey,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['NodesApi.listNodeChildren']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * lists children of the root node for the consumer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listRootNodeChildren(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ListRootNodeChildrenOK>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.listRootNodeChildren(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['NodesApi.listRootNodeChildren']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Moves a node from source to destination along with the hierarchy
     * @param {string} nodeId
     * @param {MoveNodeInput} moveNodeInput MoveNode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async moveNode(
      nodeId: string,
      moveNodeInput: MoveNodeInput,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<MoveNodeDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.moveNode(
        nodeId,
        moveNodeInput,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['NodesApi.moveNode']?.[localVarOperationServerIndex]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Permanently delete a node from TRASH_BIN, if the node is not in the TRASH_BIN it cannot delete.
     * @param {string} nodeId nodeId of the TRASH_BIN
     * @param {string} nodeIdToRemove nodeId of the node to be deleted from TRASH_BIN
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async permanentlyDeleteNode(
      nodeId: string,
      nodeIdToRemove: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.permanentlyDeleteNode(
          nodeId,
          nodeIdToRemove,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['NodesApi.permanentlyDeleteNode']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Restore node marked for deletion from TRASH_BIN
     * @param {string} nodeId nodeId of the TRASH_BIN
     * @param {string} nodeIdToRestore nodeId of the node to be restored from TRASH_BIN
     * @param {RestoreNodeFromTrashbin} restoreNodeFromTrashbin RestoreNodeFromTrashbin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async restoreNodeFromTrashbin(
      nodeId: string,
      nodeIdToRestore: string,
      restoreNodeFromTrashbin: RestoreNodeFromTrashbin,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<MoveNodeDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.restoreNodeFromTrashbin(
          nodeId,
          nodeIdToRestore,
          restoreNodeFromTrashbin,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['NodesApi.restoreNodeFromTrashbin']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Updates a node
     * @param {string} nodeId Description for nodeId.
     * @param {UpdateNodeInput} updateNodeInput UpdateNodeInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateNode(
      nodeId: string,
      updateNodeInput: UpdateNodeInput,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<NodeDto>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateNode(
        nodeId,
        updateNodeInput,
        options,
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['NodesApi.updateNode']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * NodesApi - factory interface
 * @export
 */
export const NodesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = NodesApiFp(configuration)
  return {
    /**
     * creates node
     * @param {CreateNodeInput} createNodeInput CreateNode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNode(
      createNodeInput: CreateNodeInput,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<CreateNodeOK> {
      return localVarFp
        .createNode(createNodeInput, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Mark a node and any attached files for deletion. If the node is a folder, perform the same action for all its children if the profile type is PROFILE, VC_ROOT, or VC. For other node types, move them to the TRASH_BIN node.
     * @param {string} nodeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteNode(
      nodeId: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<DeleteNodeDto> {
      return localVarFp
        .deleteNode(nodeId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Gets detailed information about the node
     * @param {string} nodeId
     * @param {string} [dek] A base64url encoded data encryption key, encrypted using VFS public key. getUrl will not be returned if dek is not provided
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDetailedNodeInfo(
      nodeId: string,
      dek?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<GetDetailedNodeInfoOK> {
      return localVarFp
        .getDetailedNodeInfo(nodeId, dek, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Initialize root node, and TRASH_BIN
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    initNodes(options?: RawAxiosRequestConfig): AxiosPromise<InitNodesOK> {
      return localVarFp
        .initNodes(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * lists children of the node
     * @param {string} nodeId Description for nodeId.
     * @param {number} [limit] Maximum number of records to fetch in a list
     * @param {string} [exclusiveStartKey] exclusiveStartKey for retrieving the next batch of data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listNodeChildren(
      nodeId: string,
      limit?: number,
      exclusiveStartKey?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ListNodeChildrenOK> {
      return localVarFp
        .listNodeChildren(nodeId, limit, exclusiveStartKey, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * lists children of the root node for the consumer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listRootNodeChildren(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<ListRootNodeChildrenOK> {
      return localVarFp
        .listRootNodeChildren(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Moves a node from source to destination along with the hierarchy
     * @param {string} nodeId
     * @param {MoveNodeInput} moveNodeInput MoveNode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    moveNode(
      nodeId: string,
      moveNodeInput: MoveNodeInput,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<MoveNodeDto> {
      return localVarFp
        .moveNode(nodeId, moveNodeInput, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Permanently delete a node from TRASH_BIN, if the node is not in the TRASH_BIN it cannot delete.
     * @param {string} nodeId nodeId of the TRASH_BIN
     * @param {string} nodeIdToRemove nodeId of the node to be deleted from TRASH_BIN
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    permanentlyDeleteNode(
      nodeId: string,
      nodeIdToRemove: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .permanentlyDeleteNode(nodeId, nodeIdToRemove, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Restore node marked for deletion from TRASH_BIN
     * @param {string} nodeId nodeId of the TRASH_BIN
     * @param {string} nodeIdToRestore nodeId of the node to be restored from TRASH_BIN
     * @param {RestoreNodeFromTrashbin} restoreNodeFromTrashbin RestoreNodeFromTrashbin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    restoreNodeFromTrashbin(
      nodeId: string,
      nodeIdToRestore: string,
      restoreNodeFromTrashbin: RestoreNodeFromTrashbin,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<MoveNodeDto> {
      return localVarFp
        .restoreNodeFromTrashbin(
          nodeId,
          nodeIdToRestore,
          restoreNodeFromTrashbin,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Updates a node
     * @param {string} nodeId Description for nodeId.
     * @param {UpdateNodeInput} updateNodeInput UpdateNodeInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateNode(
      nodeId: string,
      updateNodeInput: UpdateNodeInput,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<NodeDto> {
      return localVarFp
        .updateNode(nodeId, updateNodeInput, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * NodesApi - object-oriented interface
 * @export
 * @class NodesApi
 * @extends {BaseAPI}
 */
export class NodesApi extends BaseAPI {
  /**
   * creates node
   * @param {CreateNodeInput} createNodeInput CreateNode
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NodesApi
   */
  public createNode(
    createNodeInput: CreateNodeInput,
    options?: RawAxiosRequestConfig,
  ) {
    return NodesApiFp(this.configuration)
      .createNode(createNodeInput, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Mark a node and any attached files for deletion. If the node is a folder, perform the same action for all its children if the profile type is PROFILE, VC_ROOT, or VC. For other node types, move them to the TRASH_BIN node.
   * @param {string} nodeId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NodesApi
   */
  public deleteNode(nodeId: string, options?: RawAxiosRequestConfig) {
    return NodesApiFp(this.configuration)
      .deleteNode(nodeId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Gets detailed information about the node
   * @param {string} nodeId
   * @param {string} [dek] A base64url encoded data encryption key, encrypted using VFS public key. getUrl will not be returned if dek is not provided
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NodesApi
   */
  public getDetailedNodeInfo(
    nodeId: string,
    dek?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return NodesApiFp(this.configuration)
      .getDetailedNodeInfo(nodeId, dek, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Initialize root node, and TRASH_BIN
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof NodesApi
   */
  public initNodes(options?: RawAxiosRequestConfig) {
    return NodesApiFp(this.configuration)
      .initNodes(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * lists children of the node
   * @param {string} nodeId Description for nodeId.
   * @param {number} [limit] Maximum number of records to fetch in a list
   * @param {string} [exclusiveStartKey] exclusiveStartKey for retrieving the next batch of data.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NodesApi
   */
  public listNodeChildren(
    nodeId: string,
    limit?: number,
    exclusiveStartKey?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return NodesApiFp(this.configuration)
      .listNodeChildren(nodeId, limit, exclusiveStartKey, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * lists children of the root node for the consumer
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NodesApi
   */
  public listRootNodeChildren(options?: RawAxiosRequestConfig) {
    return NodesApiFp(this.configuration)
      .listRootNodeChildren(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Moves a node from source to destination along with the hierarchy
   * @param {string} nodeId
   * @param {MoveNodeInput} moveNodeInput MoveNode
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NodesApi
   */
  public moveNode(
    nodeId: string,
    moveNodeInput: MoveNodeInput,
    options?: RawAxiosRequestConfig,
  ) {
    return NodesApiFp(this.configuration)
      .moveNode(nodeId, moveNodeInput, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Permanently delete a node from TRASH_BIN, if the node is not in the TRASH_BIN it cannot delete.
   * @param {string} nodeId nodeId of the TRASH_BIN
   * @param {string} nodeIdToRemove nodeId of the node to be deleted from TRASH_BIN
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NodesApi
   */
  public permanentlyDeleteNode(
    nodeId: string,
    nodeIdToRemove: string,
    options?: RawAxiosRequestConfig,
  ) {
    return NodesApiFp(this.configuration)
      .permanentlyDeleteNode(nodeId, nodeIdToRemove, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Restore node marked for deletion from TRASH_BIN
   * @param {string} nodeId nodeId of the TRASH_BIN
   * @param {string} nodeIdToRestore nodeId of the node to be restored from TRASH_BIN
   * @param {RestoreNodeFromTrashbin} restoreNodeFromTrashbin RestoreNodeFromTrashbin
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NodesApi
   */
  public restoreNodeFromTrashbin(
    nodeId: string,
    nodeIdToRestore: string,
    restoreNodeFromTrashbin: RestoreNodeFromTrashbin,
    options?: RawAxiosRequestConfig,
  ) {
    return NodesApiFp(this.configuration)
      .restoreNodeFromTrashbin(
        nodeId,
        nodeIdToRestore,
        restoreNodeFromTrashbin,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Updates a node
   * @param {string} nodeId Description for nodeId.
   * @param {UpdateNodeInput} updateNodeInput UpdateNodeInput
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NodesApi
   */
  public updateNode(
    nodeId: string,
    updateNodeInput: UpdateNodeInput,
    options?: RawAxiosRequestConfig,
  ) {
    return NodesApiFp(this.configuration)
      .updateNode(nodeId, updateNodeInput, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ProfileDataApi - axios parameter creator
 * @export
 */
export const ProfileDataApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Retrieves information from a profile.
     * @param {string} nodeId the nodeId of the node being operated on
     * @param {string} dek A base64url encoded data encryption key, encrypted using VFS public
     * @param {string} [query] data query, TBD maybe encode it with base64 to make it url friendly?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryProfileData: async (
      nodeId: string,
      dek: string,
      query?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'nodeId' is not null or undefined
      assertParamExists('queryProfileData', 'nodeId', nodeId)
      // verify required parameter 'dek' is not null or undefined
      assertParamExists('queryProfileData', 'dek', dek)
      const localVarPath = `/v1/nodes/{nodeId}/profile-data`.replace(
        `{${'nodeId'}}`,
        encodeURIComponent(String(nodeId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ConsumerTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      if (query !== undefined) {
        localVarQueryParameter['query'] = query
      }

      if (dek !== undefined) {
        localVarQueryParameter['dek'] = dek
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Updates the profile with the given data
     * @param {string} nodeId
     * @param {UpdateProfileDataInput} updateProfileDataInput Updates the schema with the given data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProfileData: async (
      nodeId: string,
      updateProfileDataInput: UpdateProfileDataInput,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'nodeId' is not null or undefined
      assertParamExists('updateProfileData', 'nodeId', nodeId)
      // verify required parameter 'updateProfileDataInput' is not null or undefined
      assertParamExists(
        'updateProfileData',
        'updateProfileDataInput',
        updateProfileDataInput,
      )
      const localVarPath = `/v1/nodes/{nodeId}/profile-data`.replace(
        `{${'nodeId'}}`,
        encodeURIComponent(String(nodeId)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication ConsumerTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration,
      )

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateProfileDataInput,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ProfileDataApi - functional programming interface
 * @export
 */
export const ProfileDataApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ProfileDataApiAxiosParamCreator(configuration)
  return {
    /**
     * Retrieves information from a profile.
     * @param {string} nodeId the nodeId of the node being operated on
     * @param {string} dek A base64url encoded data encryption key, encrypted using VFS public
     * @param {string} [query] data query, TBD maybe encode it with base64 to make it url friendly?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async queryProfileData(
      nodeId: string,
      dek: string,
      query?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<QueryProfileDataOK>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.queryProfileData(
          nodeId,
          dek,
          query,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ProfileDataApi.queryProfileData']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Updates the profile with the given data
     * @param {string} nodeId
     * @param {UpdateProfileDataInput} updateProfileDataInput Updates the schema with the given data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateProfileData(
      nodeId: string,
      updateProfileDataInput: UpdateProfileDataInput,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UpdateProfileDataOK>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateProfileData(
          nodeId,
          updateProfileDataInput,
          options,
        )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['ProfileDataApi.updateProfileData']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * ProfileDataApi - factory interface
 * @export
 */
export const ProfileDataApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ProfileDataApiFp(configuration)
  return {
    /**
     * Retrieves information from a profile.
     * @param {string} nodeId the nodeId of the node being operated on
     * @param {string} dek A base64url encoded data encryption key, encrypted using VFS public
     * @param {string} [query] data query, TBD maybe encode it with base64 to make it url friendly?
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryProfileData(
      nodeId: string,
      dek: string,
      query?: string,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<QueryProfileDataOK> {
      return localVarFp
        .queryProfileData(nodeId, dek, query, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Updates the profile with the given data
     * @param {string} nodeId
     * @param {UpdateProfileDataInput} updateProfileDataInput Updates the schema with the given data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateProfileData(
      nodeId: string,
      updateProfileDataInput: UpdateProfileDataInput,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<UpdateProfileDataOK> {
      return localVarFp
        .updateProfileData(nodeId, updateProfileDataInput, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ProfileDataApi - object-oriented interface
 * @export
 * @class ProfileDataApi
 * @extends {BaseAPI}
 */
export class ProfileDataApi extends BaseAPI {
  /**
   * Retrieves information from a profile.
   * @param {string} nodeId the nodeId of the node being operated on
   * @param {string} dek A base64url encoded data encryption key, encrypted using VFS public
   * @param {string} [query] data query, TBD maybe encode it with base64 to make it url friendly?
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProfileDataApi
   */
  public queryProfileData(
    nodeId: string,
    dek: string,
    query?: string,
    options?: RawAxiosRequestConfig,
  ) {
    return ProfileDataApiFp(this.configuration)
      .queryProfileData(nodeId, dek, query, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Updates the profile with the given data
   * @param {string} nodeId
   * @param {UpdateProfileDataInput} updateProfileDataInput Updates the schema with the given data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProfileDataApi
   */
  public updateProfileData(
    nodeId: string,
    updateProfileDataInput: UpdateProfileDataInput,
    options?: RawAxiosRequestConfig,
  ) {
    return ProfileDataApiFp(this.configuration)
      .updateProfileData(nodeId, updateProfileDataInput, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * WellKnownApi - axios parameter creator
 * @export
 */
export const WellKnownApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWellKnownJwks: async (
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/.well-known/jwks.json`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * WellKnownApi - functional programming interface
 * @export
 */
export const WellKnownApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = WellKnownApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getWellKnownJwks(
      options?: RawAxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<JsonWebKeySetDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getWellKnownJwks(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['WellKnownApi.getWellKnownJwks']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * WellKnownApi - factory interface
 * @export
 */
export const WellKnownApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = WellKnownApiFp(configuration)
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWellKnownJwks(
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<JsonWebKeySetDto> {
      return localVarFp
        .getWellKnownJwks(options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * WellKnownApi - object-oriented interface
 * @export
 * @class WellKnownApi
 * @extends {BaseAPI}
 */
export class WellKnownApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WellKnownApi
   */
  public getWellKnownJwks(options?: RawAxiosRequestConfig) {
    return WellKnownApiFp(this.configuration)
      .getWellKnownJwks(options)
      .then((request) => request(this.axios, this.basePath))
  }
}
