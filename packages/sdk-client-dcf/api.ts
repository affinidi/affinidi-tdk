/* tslint:disable */
/* eslint-disable */
/**
 * DcfOrchestrator
 * # Affinidi Data Connector Framework (DCF) Affinidi DCF is a developer/contributor-focused suite of tools that enables contributors to configure, create, validate and manage data connectors for public consumption. This involves configuring connections to a third party data source and configuring transformation mapping from the data source to a target, “canonical” schema. After setup, DCF validates the configuration of the data connectors and transformation mapping. Following successful validation, created connectors are published.  The Affinidi DCF Orchestrator API covers every step of the data ingestion process, enabling builders to onboard new third-party services as connectors, create authenticated user connections, and pull data to be streamed to Affinidi Vault. It provides a standardized approach to interact with REST APIs, which is also configuration-driven, allowing builders to easily customise the connector\'s behaviour by modifying configuration files.  The DCF Orchestrator API is organised around three main concepts: Data Source & Configuration, Connector, and User Connection. Below you will find a brief explanation of these and other useful terms:  *Data Source & Configuration* Data Sources represent the third-party service API in our framework. They consist of two entities: the details on how to authenticate with the third-party service are mapped to DataSourceConfig, while the service’s endpoints and data transformation templates are mapped to  DataSource .  Builders can list available DataSourceConfigs and DataSources, create new ones and modify them using our API.  *Connector* This is the building block of our framework. It brings together a Data Source and its Configuration with the builder credentials necessary for connections to be made, for example client ID or client secret. Our endpoints allow builders to list available Connectors, create new ones and modify them.  *User Connection* A user connection is created each time an end user authenticates with a data source via DCF. It holds user specific information relative to a connector and application, including credentials. Our API enables builders to list, create and delete available Connections as well as to execute them to pull data.  *Templates* Builder-defined configuration objects that describe how to interact with a specific third-party service\'s API, allowing developers to easily connect to and interact with a variety of sources, as well as customising the connector\'s behaviour.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: robert.k@affinidi.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// URLSearchParams not necessarily used
// @ts-ignore
import { URL, URLSearchParams } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  BaseAPI,
  RequiredError,
  operationServerMap,
} from './base';

/**
 * Object describing the information about an active connection.
 * @export
 * @interface ActiveConnectionsDto
 */
export interface ActiveConnectionsDto {
  /**
   * The ID of the data connector.
   * @type {string}
   * @memberof ActiveConnectionsDto
   */
  connectorId?: string;
  /**
   * The ID of the data connection.
   * @type {string}
   * @memberof ActiveConnectionsDto
   */
  connectionId?: string;
  /**
   * The name of the data connector.
   * @type {string}
   * @memberof ActiveConnectionsDto
   */
  connectorName?: string;
  /**
   * The date and time at which the connection has been created.
   * @type {string}
   * @memberof ActiveConnectionsDto
   */
  createdAt?: string;
  /**
   * The date and time at which the connection has been updated.
   * @type {string}
   * @memberof ActiveConnectionsDto
   */
  activatedAt?: string;
}
/**
 * Response payload after requesting a list of active connections.
 * @export
 * @interface ActiveConnectionsResponse
 */
export interface ActiveConnectionsResponse {
  /**
   * A list of active connections.
   * @type {Array<ActiveConnectionsDto>}
   * @memberof ActiveConnectionsResponse
   */
  connections: Array<ActiveConnectionsDto>;
}
/**
 * An object containing the name and id of a given data source.
 * @export
 * @interface AuthConfig
 */
export interface AuthConfig {
  /**
   * The ID of the data source.
   * @type {string}
   * @memberof AuthConfig
   */
  id: string;
  /**
   * The name of the data source configuration.
   * @type {string}
   * @memberof AuthConfig
   */
  dataSourceConfigName: string;
}
/**
 * Object describing the information needed for a valid authentication configuration.
 * @export
 * @interface AuthConfigDto
 */
export interface AuthConfigDto {
  /**
   * The ID of the data source.
   * @type {string}
   * @memberof AuthConfigDto
   */
  id?: string;
  /**
   * The name of the data source configuration connected to this authentication configuration.
   * @type {string}
   * @memberof AuthConfigDto
   */
  dataSourceConfigName?: string;
  /**
   * The status of the data source config.
   * @type {string}
   * @memberof AuthConfigDto
   */
  status?: AuthConfigDtoStatusEnum;
  /**
   *
   * @type {AuthConfigInfoDto}
   * @memberof AuthConfigDto
   */
  authConfigInfo?: AuthConfigInfoDto;
}

export const AuthConfigDtoStatusEnum = {
  Draft: 'DRAFT',
  Active: 'ACTIVE',
} as const;

export type AuthConfigDtoStatusEnum =
  (typeof AuthConfigDtoStatusEnum)[keyof typeof AuthConfigDtoStatusEnum];

/**
 * The information needed to onboard and use a data source.
 * @export
 * @interface AuthConfigInfoDto
 */
export interface AuthConfigInfoDto {
  /**
   *
   * @type {AuthConfigInfoDtoAuthDetails}
   * @memberof AuthConfigInfoDto
   */
  authDetails: AuthConfigInfoDtoAuthDetails;
  /**
   *
   * @type {AuthConfigInfoDtoExchangeTokenTemplate}
   * @memberof AuthConfigInfoDto
   */
  exchangeTokenTemplate: AuthConfigInfoDtoExchangeTokenTemplate;
  /**
   *
   * @type {AuthConfigInfoDtoRefreshTokenTemplate}
   * @memberof AuthConfigInfoDto
   */
  refreshTokenTemplate?: AuthConfigInfoDtoRefreshTokenTemplate;
}
/**
 * The authentication information needed to connect with a data source.
 * @export
 * @interface AuthConfigInfoDtoAuthDetails
 */
export interface AuthConfigInfoDtoAuthDetails {
  /**
   * The base URL with which the data connector framework (DCF) can get authenticated for using the connector. Should be obtained from the API documentation of the third-party service.
   * @type {string}
   * @memberof AuthConfigInfoDtoAuthDetails
   */
  authUrl: string;
  /**
   * The template for generating the full authentication URL for authenticating the DCF.
   * @type {string}
   * @memberof AuthConfigInfoDtoAuthDetails
   */
  template: string;
}
/**
 * Template for defining the requirements of authentication token exchange with the external data source.
 * @export
 * @interface AuthConfigInfoDtoExchangeTokenTemplate
 */
export interface AuthConfigInfoDtoExchangeTokenTemplate {
  /**
   * Defines all request and auth headers which are common for each operation.
   * @type {{ [key: string]: any; }}
   * @memberof AuthConfigInfoDtoExchangeTokenTemplate
   */
  options: { [key: string]: any };
  /**
   * A list of REST operations to exchange authentication token with the data source.
   * @type {Array<AuthConfigInfoDtoExchangeTokenTemplateOperationsInner>}
   * @memberof AuthConfigInfoDtoExchangeTokenTemplate
   */
  operations: Array<AuthConfigInfoDtoExchangeTokenTemplateOperationsInner>;
}
/**
 * Describes the configuration for a single REST operation for authenticating with the data source.
 * @export
 * @interface AuthConfigInfoDtoExchangeTokenTemplateOperationsInner
 */
export interface AuthConfigInfoDtoExchangeTokenTemplateOperationsInner {
  /**
   * An object which defines the REST operation as well as the URL to issue the request.
   * @type {{ [key: string]: any; }}
   * @memberof AuthConfigInfoDtoExchangeTokenTemplateOperationsInner
   */
  template: { [key: string]: any };
  /**
   *
   * @type {AuthConfigInfoDtoExchangeTokenTemplateOperationsInnerFunctions}
   * @memberof AuthConfigInfoDtoExchangeTokenTemplateOperationsInner
   */
  functions: AuthConfigInfoDtoExchangeTokenTemplateOperationsInnerFunctions;
}
/**
 * An object defining functions which process the received authentication data from the operation.
 * @export
 * @interface AuthConfigInfoDtoExchangeTokenTemplateOperationsInnerFunctions
 */
export interface AuthConfigInfoDtoExchangeTokenTemplateOperationsInnerFunctions {
  /**
   * Should always be an empty array.
   * @type {Array<string>}
   * @memberof AuthConfigInfoDtoExchangeTokenTemplateOperationsInnerFunctions
   */
  getData: Array<string>;
}
/**
 * Template for defining the requirements of renewing the authentication token with the external data source.
 * @export
 * @interface AuthConfigInfoDtoRefreshTokenTemplate
 */
export interface AuthConfigInfoDtoRefreshTokenTemplate {
  /**
   * Defines all request and auth headers which are common for each operation.
   * @type {object}
   * @memberof AuthConfigInfoDtoRefreshTokenTemplate
   */
  options: object;
  /**
   * A list of REST operations to retrieve an exchange token from the data source.
   * @type {Array<AuthConfigInfoDtoRefreshTokenTemplateOperationsInner>}
   * @memberof AuthConfigInfoDtoRefreshTokenTemplate
   */
  operations: Array<AuthConfigInfoDtoRefreshTokenTemplateOperationsInner>;
}
/**
 * Describes the configuration for a single REST operation retrieving an exchange token from the data source.
 * @export
 * @interface AuthConfigInfoDtoRefreshTokenTemplateOperationsInner
 */
export interface AuthConfigInfoDtoRefreshTokenTemplateOperationsInner {
  /**
   * An object which defines the REST operation as well as the URL to issue the request.
   * @type {{ [key: string]: any; }}
   * @memberof AuthConfigInfoDtoRefreshTokenTemplateOperationsInner
   */
  template: { [key: string]: any };
  /**
   *
   * @type {AuthConfigInfoDtoRefreshTokenTemplateOperationsInnerFunctions}
   * @memberof AuthConfigInfoDtoRefreshTokenTemplateOperationsInner
   */
  functions: AuthConfigInfoDtoRefreshTokenTemplateOperationsInnerFunctions;
}
/**
 * An object defining functions which process the received refresh token data from the operation.
 * @export
 * @interface AuthConfigInfoDtoRefreshTokenTemplateOperationsInnerFunctions
 */
export interface AuthConfigInfoDtoRefreshTokenTemplateOperationsInnerFunctions {
  /**
   *
   * @type {Array<string>}
   * @memberof AuthConfigInfoDtoRefreshTokenTemplateOperationsInnerFunctions
   */
  getData: Array<string>;
}
/**
 * The information needed to onboard and use a data source.
 * @export
 * @interface AuthConfigInfoPatchDto
 */
export interface AuthConfigInfoPatchDto {
  /**
   *
   * @type {AuthConfigInfoPatchDtoAuthDetails}
   * @memberof AuthConfigInfoPatchDto
   */
  authDetails?: AuthConfigInfoPatchDtoAuthDetails;
  /**
   *
   * @type {AuthConfigInfoPatchDtoExchangeTokenTemplate}
   * @memberof AuthConfigInfoPatchDto
   */
  exchangeTokenTemplate?: AuthConfigInfoPatchDtoExchangeTokenTemplate;
  /**
   *
   * @type {AuthConfigInfoPatchDtoRefreshTokenTemplate}
   * @memberof AuthConfigInfoPatchDto
   */
  refreshTokenTemplate?: AuthConfigInfoPatchDtoRefreshTokenTemplate;
}
/**
 * The authentication information needed to connect with a Data Source.
 * @export
 * @interface AuthConfigInfoPatchDtoAuthDetails
 */
export interface AuthConfigInfoPatchDtoAuthDetails {
  /**
   * The base URL with which the data connector framework (DCF) can get authenticated for using the connector. Should be obtained from the API documentation of the third-party service.
   * @type {string}
   * @memberof AuthConfigInfoPatchDtoAuthDetails
   */
  authUrl?: string;
  /**
   * The template for generating the full authentication URL for authenticating the DCF.
   * @type {string}
   * @memberof AuthConfigInfoPatchDtoAuthDetails
   */
  template?: string;
}
/**
 * Template for defining the requirements of authentication token exchange with the external data source.
 * @export
 * @interface AuthConfigInfoPatchDtoExchangeTokenTemplate
 */
export interface AuthConfigInfoPatchDtoExchangeTokenTemplate {
  /**
   * Defines all request and auth headers which are common for each operation.s
   * @type {{ [key: string]: any; }}
   * @memberof AuthConfigInfoPatchDtoExchangeTokenTemplate
   */
  options?: { [key: string]: any };
  /**
   * A list of REST operations to exchange authentication token with the data source.
   * @type {Array<AuthConfigInfoPatchDtoExchangeTokenTemplateOperationsInner>}
   * @memberof AuthConfigInfoPatchDtoExchangeTokenTemplate
   */
  operations?: Array<AuthConfigInfoPatchDtoExchangeTokenTemplateOperationsInner>;
}
/**
 * Describes the configuration for a single REST operation for authenticating with the data source.
 * @export
 * @interface AuthConfigInfoPatchDtoExchangeTokenTemplateOperationsInner
 */
export interface AuthConfigInfoPatchDtoExchangeTokenTemplateOperationsInner {
  /**
   * An object which defines the REST operation as well as the URL to issue the request.
   * @type {{ [key: string]: any; }}
   * @memberof AuthConfigInfoPatchDtoExchangeTokenTemplateOperationsInner
   */
  template?: { [key: string]: any };
  /**
   *
   * @type {AuthConfigInfoPatchDtoExchangeTokenTemplateOperationsInnerFunctions}
   * @memberof AuthConfigInfoPatchDtoExchangeTokenTemplateOperationsInner
   */
  functions?: AuthConfigInfoPatchDtoExchangeTokenTemplateOperationsInnerFunctions;
}
/**
 * An object defining functions which process the received authentication data from the operation.
 * @export
 * @interface AuthConfigInfoPatchDtoExchangeTokenTemplateOperationsInnerFunctions
 */
export interface AuthConfigInfoPatchDtoExchangeTokenTemplateOperationsInnerFunctions {
  /**
   *
   * @type {Array<string>}
   * @memberof AuthConfigInfoPatchDtoExchangeTokenTemplateOperationsInnerFunctions
   */
  getData?: Array<string>;
}
/**
 * Template for defining the requirements of renewing the authentication token with the external data source.
 * @export
 * @interface AuthConfigInfoPatchDtoRefreshTokenTemplate
 */
export interface AuthConfigInfoPatchDtoRefreshTokenTemplate {
  /**
   * Defines all request and auth headers which are common for each operation.
   * @type {object}
   * @memberof AuthConfigInfoPatchDtoRefreshTokenTemplate
   */
  options?: object;
  /**
   * A list of REST operations to retrieve an exchange token from the data source.
   * @type {Array<AuthConfigInfoPatchDtoRefreshTokenTemplateOperationsInner>}
   * @memberof AuthConfigInfoPatchDtoRefreshTokenTemplate
   */
  operations?: Array<AuthConfigInfoPatchDtoRefreshTokenTemplateOperationsInner>;
}
/**
 * Describes the configuration for a single REST operation retrieving an exchange token from the data source.
 * @export
 * @interface AuthConfigInfoPatchDtoRefreshTokenTemplateOperationsInner
 */
export interface AuthConfigInfoPatchDtoRefreshTokenTemplateOperationsInner {
  /**
   * An object which defines the REST operation as well as the URL to issue the request.
   * @type {{ [key: string]: any; }}
   * @memberof AuthConfigInfoPatchDtoRefreshTokenTemplateOperationsInner
   */
  template?: { [key: string]: any };
  /**
   *
   * @type {AuthConfigInfoPatchDtoRefreshTokenTemplateOperationsInnerFunctions}
   * @memberof AuthConfigInfoPatchDtoRefreshTokenTemplateOperationsInner
   */
  functions?: AuthConfigInfoPatchDtoRefreshTokenTemplateOperationsInnerFunctions;
}
/**
 * An object defining functions which process the received refresh token data from the operation.
 * @export
 * @interface AuthConfigInfoPatchDtoRefreshTokenTemplateOperationsInnerFunctions
 */
export interface AuthConfigInfoPatchDtoRefreshTokenTemplateOperationsInnerFunctions {
  /**
   * Should always be an empty array.
   * @type {Array<string>}
   * @memberof AuthConfigInfoPatchDtoRefreshTokenTemplateOperationsInnerFunctions
   */
  getData?: Array<string>;
}
/**
 * Defines the consumer facing information of a connector.
 * @export
 * @interface AvailableConnectorDTO
 */
export interface AvailableConnectorDTO {
  /**
   * The ID of the connector.
   * @type {string}
   * @memberof AvailableConnectorDTO
   */
  id: string;
  /**
   * The name of the connector.
   * @type {string}
   * @memberof AvailableConnectorDTO
   */
  name: string;
  /**
   * The icon of the connector as base64 encoded string.
   * @type {string}
   * @memberof AvailableConnectorDTO
   */
  icon: string;
  /**
   * The URL of the website for the connector.
   * @type {string}
   * @memberof AvailableConnectorDTO
   */
  websiteUri?: string;
}
/**
 * List of all available connectors.
 * @export
 * @interface AvailableConnectorsResponse
 */
export interface AvailableConnectorsResponse {
  /**
   * A list of available connectors.
   * @type {Array<AvailableConnectorDTO>}
   * @memberof AvailableConnectorsResponse
   */
  connectors: Array<AvailableConnectorDTO>;
}
/**
 * A basic connector information needed for mapping with a common schema
 * @export
 * @interface BasicConnectorDTO
 */
export interface BasicConnectorDTO {
  /**
   * The name of the connector.
   * @type {string}
   * @memberof BasicConnectorDTO
   */
  name: string;
  /**
   * The website of the connector.
   * @type {string}
   * @memberof BasicConnectorDTO
   */
  website: string;
  /**
   * The icon of the connector as base64 encoded string.
   * @type {string}
   * @memberof BasicConnectorDTO
   */
  icon?: string;
  /**
   * The ID of the connector.
   * @type {string}
   * @memberof BasicConnectorDTO
   */
  connectorId: string;
}
/**
 * @type CallbackResponse
 * @export
 */
export type CallbackResponse =
  | CallbackResponseOneOf
  | PatchDataSourceConfigStatusResponse
  | PatchDataSourceStatusResponse;

/**
 * Response payload sent after calling the callback endpoint.
 * @export
 * @interface CallbackResponseOneOf
 */
export interface CallbackResponseOneOf {
  /**
   * The ID of the data connector.
   * @type {string}
   * @memberof CallbackResponseOneOf
   */
  connectionId?: string;
  /**
   * The name of the data source.
   * @type {string}
   * @memberof CallbackResponseOneOf
   */
  dataSource?: string;
}
/**
 * A list to define templates fields which need to have specific names for the Connector. For example `clientSecret` needs to be named `secret` for the Deezer connector.
 * @export
 * @interface ConfigTemplateDto
 */
export interface ConfigTemplateDto extends Array<ConfigTemplateDtoInner> {}
/**
 *
 * @export
 * @interface ConfigTemplateDtoInner
 */
export interface ConfigTemplateDtoInner {
  /**
   * The placeholder name from any template within the postDataSourceConfig payload.
   * @type {string}
   * @memberof ConfigTemplateDtoInner
   */
  key: string;
  /**
   * The replacement field name as required by the data connector for the postDataSourceConfig templates.
   * @type {string}
   * @memberof ConfigTemplateDtoInner
   */
  value: string;
  /**
   * A descriptive comment giving context for the need of this custom field.
   * @type {string}
   * @memberof ConfigTemplateDtoInner
   */
  description?: string;
}
/**
 * Request payload for creating a new connection.
 * @export
 * @interface ConnectionCreationRequest
 */
export interface ConnectionCreationRequest {
  /**
   * The ID of the data connector.
   * @type {string}
   * @memberof ConnectionCreationRequest
   */
  connectorId: string;
  /**
   * The ID of the data source.
   * @type {string}
   * @memberof ConnectionCreationRequest
   */
  dataSourceId?: string;
}
/**
 * Response payload after successful creation of a connection.
 * @export
 * @interface ConnectionCreationResponse
 */
export interface ConnectionCreationResponse {
  /**
   * the Single-Sign-On address through which a user need to authenticate the connection  with the use of the data connector framework (DCF).
   * @type {string}
   * @memberof ConnectionCreationResponse
   */
  ssoStartUrl?: string;
}
/**
 * Represents a default API response communicating result details of the request.
 * @export
 * @interface ConnectionExecutedTempResponse
 */
export interface ConnectionExecutedTempResponse {
  /**
   * The actual response message.
   * @type {object}
   * @memberof ConnectionExecutedTempResponse
   */
  credentials?: object;
}
/**
 * The configuration object for the Connector containing builder\'s credentials and customs fields.
 * @export
 * @interface ConnectorAuthConfig
 */
export interface ConnectorAuthConfig {
  /**
   * The client ID acquired while registering at a third-party service. Might be named differently at each individual service. Reflect these differences within the `customFields` property.
   * @type {string}
   * @memberof ConnectorAuthConfig
   */
  clientId: string;
  /**
   *
   * @type {ConfigTemplateDto}
   * @memberof ConnectorAuthConfig
   */
  customFields?: ConfigTemplateDto;
}
/**
 * An object containing required information to define a connector.
 * @export
 * @interface ConnectorDTO
 */
export interface ConnectorDTO {
  /**
   * The ID of the connector.
   * @type {string}
   * @memberof ConnectorDTO
   */
  id: string;
  /**
   * The name of the connector.
   * @type {string}
   * @memberof ConnectorDTO
   */
  name: string;
  /**
   * The date and time at which the connector has been created.
   * @type {string}
   * @memberof ConnectorDTO
   */
  createdAt?: string;
  /**
   * A list of IDs of related data sources.
   * @type {Array<string>}
   * @memberof ConnectorDTO
   */
  dataSourceIds: Array<string>;
  /**
   *
   * @type {ConnectorAuthConfig}
   * @memberof ConnectorDTO
   */
  config: ConnectorAuthConfig;
  /**
   * The state in which the connector is currently.
   * @type {string}
   * @memberof ConnectorDTO
   */
  status?: ConnectorDTOStatusEnum;
  /**
   * The icon of the connector as base64 encoded string.
   * @type {string}
   * @memberof ConnectorDTO
   */
  icon: string;
  /**
   * The URL of the website for the connector.
   * @type {string}
   * @memberof ConnectorDTO
   */
  websiteUri?: string;
}

export const ConnectorDTOStatusEnum = {
  Draft: 'DRAFT',
  Ready: 'READY',
} as const;

export type ConnectorDTOStatusEnum =
  (typeof ConnectorDTOStatusEnum)[keyof typeof ConnectorDTOStatusEnum];

/**
 * The requested connector.
 * @export
 * @interface ConnectorsByIdResponse
 */
export interface ConnectorsByIdResponse {
  /**
   *
   * @type {ConnectorDTO}
   * @memberof ConnectorsByIdResponse
   */
  connector?: ConnectorDTO;
}
/**
 * Request to create a new connector.
 * @export
 * @interface ConnectorsCreationRequest
 */
export interface ConnectorsCreationRequest {
  /**
   * The name of the connector.
   * @type {string}
   * @memberof ConnectorsCreationRequest
   */
  name: string;
  /**
   * The list of data source IDs for the connector.
   * @type {Array<string>}
   * @memberof ConnectorsCreationRequest
   */
  dataSourceIds: Array<string>;
  /**
   *
   * @type {ConnectorAuthConfig}
   * @memberof ConnectorsCreationRequest
   */
  config: ConnectorAuthConfig;
  /**
   * The icon of the connector as base64 encoded string.
   * @type {string}
   * @memberof ConnectorsCreationRequest
   */
  icon: string;
  /**
   * The URL of the website for the connector.
   * @type {string}
   * @memberof ConnectorsCreationRequest
   */
  websiteUri?: string;
}
/**
 * List of all configured connectors.
 * @export
 * @interface ConnectorsResponse
 */
export interface ConnectorsResponse {
  /**
   * A list of available connectors.
   * @type {Array<ConnectorDTO>}
   * @memberof ConnectorsResponse
   */
  connectors: Array<ConnectorDTO>;
}
/**
 * Request payload for creating of a transformation template for a given data source.
 * @export
 * @interface CreateTransformationTemplateRequest
 */
export interface CreateTransformationTemplateRequest {
  /**
   *
   * @type {TransformationTemplateDto}
   * @memberof CreateTransformationTemplateRequest
   */
  transformationTemplate: TransformationTemplateDto;
}
/**
 * An object that contains endpoint configurations for data retrieval
 * @export
 * @interface DataSource
 */
export interface DataSource {
  /**
   * The ID of the data source.
   * @type {string}
   * @memberof DataSource
   */
  dataSourceId?: string;
  /**
   * The ID of the data source configuration.
   * @type {string}
   * @memberof DataSource
   */
  dataSourceConfigId: string;
  /**
   * The name of the data source.
   * @type {string}
   * @memberof DataSource
   */
  dataSourceName: string;
  /**
   * The human readable description of the data source.
   * @type {string}
   * @memberof DataSource
   */
  description?: string;
  /**
   * Data-scoped permissions as string, requested from the third-party service API so that DCF can access that data on behalf of end users.
   * @type {string}
   * @memberof DataSource
   */
  scope: string;
  /**
   * The status of the data source.
   * @type {string}
   * @memberof DataSource
   */
  status?: DataSourceStatusEnum;
  /**
   *
   * @type {EndpointConfigDto}
   * @memberof DataSource
   */
  endpointConfig: EndpointConfigDto;
  /**
   *
   * @type {TransformationTemplateDto}
   * @memberof DataSource
   */
  transformationTemplate?: TransformationTemplateDto;
}

export const DataSourceStatusEnum = {
  Draft: 'DRAFT',
  Active: 'ACTIVE',
} as const;

export type DataSourceStatusEnum =
  (typeof DataSourceStatusEnum)[keyof typeof DataSourceStatusEnum];

/**
 * An object that contains configurations for authenticating with a given data source.
 * @export
 * @interface DataSourceConfig
 */
export interface DataSourceConfig {
  /**
   * The name of the data source configuration.
   * @type {string}
   * @memberof DataSourceConfig
   */
  dataSourceConfigName: string;
  /**
   * The status of the data source config.
   * @type {string}
   * @memberof DataSourceConfig
   */
  status?: DataSourceConfigStatusEnum;
  /**
   *
   * @type {AuthConfigInfoDto}
   * @memberof DataSourceConfig
   */
  authConfigInfo: AuthConfigInfoDto;
}

export const DataSourceConfigStatusEnum = {
  Draft: 'DRAFT',
  Active: 'ACTIVE',
} as const;

export type DataSourceConfigStatusEnum =
  (typeof DataSourceConfigStatusEnum)[keyof typeof DataSourceConfigStatusEnum];

/**
 * @type DataSourceConfigByIdResponse
 * @export
 */
export type DataSourceConfigByIdResponse =
  | DataSourceConfigByIdResponseOneOf
  | DataSourceConfigValidationResult;

/**
 * Specific data source configuration based on id provided
 * @export
 * @interface DataSourceConfigByIdResponseOneOf
 */
export interface DataSourceConfigByIdResponseOneOf {
  /**
   *
   * @type {AuthConfigDto}
   * @memberof DataSourceConfigByIdResponseOneOf
   */
  dataSourceConfig: AuthConfigDto;
}
/**
 * Request payload for updating certain authentication information of a data source configuration.
 * @export
 * @interface DataSourceConfigPatchRequest
 */
export interface DataSourceConfigPatchRequest {
  /**
   *
   * @type {AuthConfigInfoPatchDto}
   * @memberof DataSourceConfigPatchRequest
   */
  authConfigInfo?: AuthConfigInfoPatchDto;
}
/**
 * Updates a data source config\'s status.
 * @export
 * @interface DataSourceConfigPatchStatusRequest
 */
export interface DataSourceConfigPatchStatusRequest {
  /**
   * The new status of the data source config.
   * @type {string}
   * @memberof DataSourceConfigPatchStatusRequest
   */
  status: DataSourceConfigPatchStatusRequestStatusEnum;
  /**
   *
   * @type {string}
   * @memberof DataSourceConfigPatchStatusRequest
   */
  scope?: string;
  /**
   *
   * @type {ConnectorAuthConfig}
   * @memberof DataSourceConfigPatchStatusRequest
   */
  config?: ConnectorAuthConfig;
}

export const DataSourceConfigPatchStatusRequestStatusEnum = {
  Draft: 'DRAFT',
  Active: 'ACTIVE',
} as const;

export type DataSourceConfigPatchStatusRequestStatusEnum =
  (typeof DataSourceConfigPatchStatusRequestStatusEnum)[keyof typeof DataSourceConfigPatchStatusRequestStatusEnum];

/**
 * List of all available configurations of data sources.
 * @export
 * @interface DataSourceConfigResponse
 */
export interface DataSourceConfigResponse {
  /**
   * The list of all available data source configurations.
   * @type {Array<AuthConfig>}
   * @memberof DataSourceConfigResponse
   */
  dataSourceConfigs: Array<AuthConfig>;
}
/**
 *
 * @export
 * @interface DataSourceConfigValidationResult
 */
export interface DataSourceConfigValidationResult {
  /**
   *
   * @type {DataSourceConfigValidationResultValidationResult}
   * @memberof DataSourceConfigValidationResult
   */
  validationResult?: DataSourceConfigValidationResultValidationResult;
}
/**
 *
 * @export
 * @interface DataSourceConfigValidationResultValidationResult
 */
export interface DataSourceConfigValidationResultValidationResult {
  /**
   *
   * @type {boolean}
   * @memberof DataSourceConfigValidationResultValidationResult
   */
  isSuccessful?: boolean;
  /**
   *
   * @type {string}
   * @memberof DataSourceConfigValidationResultValidationResult
   */
  connectionId?: string;
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof DataSourceConfigValidationResultValidationResult
   */
  response?: { [key: string]: any };
}
/**
 * Response payload after successful creation of a data source configuration.
 * @export
 * @interface DataSourceCreationResponse
 */
export interface DataSourceCreationResponse {
  /**
   * The ID of the data source.
   * @type {string}
   * @memberof DataSourceCreationResponse
   */
  dataSourceId?: string;
}
/**
 * Request payload for updating of a data source.
 * @export
 * @interface DataSourcePatchRequest
 */
export interface DataSourcePatchRequest {
  /**
   * The name of the data source.
   * @type {string}
   * @memberof DataSourcePatchRequest
   */
  dataSourceName?: string;
  /**
   * The human readable description of the data source.
   * @type {string}
   * @memberof DataSourcePatchRequest
   */
  description?: string;
  /**
   * Data-scoped permissions as string, requested from the third-party service API so that DCF can access that data on behalf of end users.
   * @type {string}
   * @memberof DataSourcePatchRequest
   */
  scope?: string;
  /**
   *
   * @type {EndpointConfigPatchRequest}
   * @memberof DataSourcePatchRequest
   */
  endpointConfig?: EndpointConfigPatchRequest;
  /**
   *
   * @type {TransformationTemplateDto}
   * @memberof DataSourcePatchRequest
   */
  transformationTemplate?: TransformationTemplateDto;
}
/**
 * Updates a data source status.
 * @export
 * @interface DataSourcePatchStatusRequest
 */
export interface DataSourcePatchStatusRequest {
  /**
   * The status of the data source.
   * @type {string}
   * @memberof DataSourcePatchStatusRequest
   */
  status: DataSourcePatchStatusRequestStatusEnum;
  /**
   *
   * @type {ConnectorAuthConfig}
   * @memberof DataSourcePatchStatusRequest
   */
  config?: ConnectorAuthConfig;
}

export const DataSourcePatchStatusRequestStatusEnum = {
  Draft: 'DRAFT',
  Active: 'ACTIVE',
} as const;

export type DataSourcePatchStatusRequestStatusEnum =
  (typeof DataSourcePatchStatusRequestStatusEnum)[keyof typeof DataSourcePatchStatusRequestStatusEnum];

/**
 * List of all data source configurations.
 * @export
 * @interface DataSourceResponse
 */
export interface DataSourceResponse {
  /**
   * A list of data source configurations.
   * @type {Array<DataSourceResponseDto>}
   * @memberof DataSourceResponse
   */
  dataSources?: Array<DataSourceResponseDto>;
}
/**
 * An object that contains endpoint configurations for data retrievel
 * @export
 * @interface DataSourceResponseDto
 */
export interface DataSourceResponseDto {
  /**
   * The ID of the data source.
   * @type {string}
   * @memberof DataSourceResponseDto
   */
  dataSourceId: string;
  /**
   * The ID of the data source configuration.
   * @type {string}
   * @memberof DataSourceResponseDto
   */
  dataSourceConfigId: string;
  /**
   * The name of the data source.
   * @type {string}
   * @memberof DataSourceResponseDto
   */
  dataSourceName: string;
  /**
   * The human readable description of the data source.
   * @type {string}
   * @memberof DataSourceResponseDto
   */
  description?: string;
  /**
   * Data-scoped permissions as string, requested from the third-party service API so that DCF can access that data on behalf of end users.
   * @type {string}
   * @memberof DataSourceResponseDto
   */
  scope: string;
  /**
   * The status of the data source.
   * @type {string}
   * @memberof DataSourceResponseDto
   */
  status: DataSourceResponseDtoStatusEnum;
  /**
   *
   * @type {EndpointConfigDto}
   * @memberof DataSourceResponseDto
   */
  endpointConfig: EndpointConfigDto;
  /**
   *
   * @type {TransformationTemplateDto}
   * @memberof DataSourceResponseDto
   */
  transformationTemplate?: TransformationTemplateDto;
}

export const DataSourceResponseDtoStatusEnum = {
  Draft: 'DRAFT',
  Active: 'ACTIVE',
} as const;

export type DataSourceResponseDtoStatusEnum =
  (typeof DataSourceResponseDtoStatusEnum)[keyof typeof DataSourceResponseDtoStatusEnum];

/**
 *
 * @export
 * @interface DataSourceValidationResult
 */
export interface DataSourceValidationResult {
  /**
   *
   * @type {DataSourceValidationResultValidationResult}
   * @memberof DataSourceValidationResult
   */
  validationResult?: DataSourceValidationResultValidationResult;
}
/**
 *
 * @export
 * @interface DataSourceValidationResultValidationResult
 */
export interface DataSourceValidationResultValidationResult {
  /**
   *
   * @type {boolean}
   * @memberof DataSourceValidationResultValidationResult
   */
  isSuccessful?: boolean;
  /**
   *
   * @type {string}
   * @memberof DataSourceValidationResultValidationResult
   */
  connectionId?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof DataSourceValidationResultValidationResult
   */
  response?: Array<string>;
}
/**
 * Defines the executable operations provided by the data connector in order to retrieve data.
 * @export
 * @interface EndpointConfigDto
 */
export interface EndpointConfigDto {
  /**
   * Defines all request and auth headers which are common for each operation.
   * @type {{ [key: string]: any; }}
   * @memberof EndpointConfigDto
   */
  options: { [key: string]: any };
  /**
   * A list of REST operations to retrieve data from the data connector.
   * @type {Array<EndpointConfigDtoOperationsInner>}
   * @memberof EndpointConfigDto
   */
  operations: Array<EndpointConfigDtoOperationsInner>;
}
/**
 * Describes the configuration for a single REST operation for the data connector.
 * @export
 * @interface EndpointConfigDtoOperationsInner
 */
export interface EndpointConfigDtoOperationsInner {
  /**
   * An object which defines the REST operation as well as the URL to issue the request.
   * @type {{ [key: string]: any; }}
   * @memberof EndpointConfigDtoOperationsInner
   */
  template: { [key: string]: any };
  /**
   * An object defining functions which process the received data from the defined operation.
   * @type {{ [key: string]: any; }}
   * @memberof EndpointConfigDtoOperationsInner
   */
  functions: { [key: string]: any };
  /**
   * An optional object defining how paginated results will be collected.
   * @type {{ [key: string]: any; }}
   * @memberof EndpointConfigDtoOperationsInner
   */
  pagination?: { [key: string]: any };
  /**
   * Schema of the response returned by the chosen API endpoint. It serves as a reference to understand the structure and format of data returned by the data source API.
   * @type {{ [key: string]: any; }}
   * @memberof EndpointConfigDtoOperationsInner
   */
  sourceSchema: { [key: string]: any };
}
/**
 * Defines the executable operations provided by the data connector in order to retrieve data.
 * @export
 * @interface EndpointConfigPatchRequest
 */
export interface EndpointConfigPatchRequest {
  /**
   * Defines all request and auth headers which are common for each operation.
   * @type {{ [key: string]: any; }}
   * @memberof EndpointConfigPatchRequest
   */
  options?: { [key: string]: any };
  /**
   *
   * @type {Array<EndpointConfigPatchRequestOperationsInner>}
   * @memberof EndpointConfigPatchRequest
   */
  operations?: Array<EndpointConfigPatchRequestOperationsInner>;
}
/**
 *
 * @export
 * @interface EndpointConfigPatchRequestOperationsInner
 */
export interface EndpointConfigPatchRequestOperationsInner {
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof EndpointConfigPatchRequestOperationsInner
   */
  template?: { [key: string]: any };
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof EndpointConfigPatchRequestOperationsInner
   */
  functions?: { [key: string]: any };
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof EndpointConfigPatchRequestOperationsInner
   */
  pagination?: { [key: string]: any };
  /**
   * Schema of the response returned by the chosen API endpoint. It serves as a reference to understand the structure and format of data returned by the data source API.
   * @type {{ [key: string]: any; }}
   * @memberof EndpointConfigPatchRequestOperationsInner
   */
  sourceSchema?: { [key: string]: any };
}
/**
 * Represents the results of executed connection request
 * @export
 * @interface ExecutedConnectionRequestResponse
 */
export interface ExecutedConnectionRequestResponse {
  /**
   * The status of the executed connection request.
   * @type {string}
   * @memberof ExecutedConnectionRequestResponse
   */
  status?: string;
  /**
   * A list of errors that occurred during the execution of the connection request.
   * @type {Array<string>}
   * @memberof ExecutedConnectionRequestResponse
   */
  errors?: Array<string>;
  /**
   * The ID of the connector.
   * @type {string}
   * @memberof ExecutedConnectionRequestResponse
   */
  connectorId?: string;
  /**
   * The ID of the connection.
   * @type {string}
   * @memberof ExecutedConnectionRequestResponse
   */
  connectionId?: string;
  /**
   * The name of the connector.
   * @type {string}
   * @memberof ExecutedConnectionRequestResponse
   */
  connectorName?: string;
  /**
   * The date and time at which the connection has been created.
   * @type {string}
   * @memberof ExecutedConnectionRequestResponse
   */
  createdAt?: string;
  /**
   * The date and time at which the connection has been activated.
   * @type {string}
   * @memberof ExecutedConnectionRequestResponse
   */
  activatedAt?: string;
}
/**
 * Represents a default API response communicating result details of the request.
 * @export
 * @interface GenericResponse
 */
export interface GenericResponse {
  /**
   * The actual response message.
   * @type {string}
   * @memberof GenericResponse
   */
  message?: string;
}
/**
 * @type GetDataSourcebyIdResponse
 * @export
 */
export type GetDataSourcebyIdResponse = DataSource | DataSourceValidationResult;

/**
 * @type GetExecutedConnection404Response
 * @export
 */
export type GetExecutedConnection404Response =
  | NotFoundError
  | ResourceNotFoundError;

/**
 *
 * @export
 * @interface InvalidParameterError
 */
export interface InvalidParameterError {
  /**
   *
   * @type {string}
   * @memberof InvalidParameterError
   */
  name?: InvalidParameterErrorNameEnum;
  /**
   *
   * @type {string}
   * @memberof InvalidParameterError
   */
  message?: InvalidParameterErrorMessageEnum;
  /**
   *
   * @type {number}
   * @memberof InvalidParameterError
   */
  httpStatusCode?: InvalidParameterErrorHttpStatusCodeEnum;
}

export const InvalidParameterErrorNameEnum = {
  InvalidParameterError: 'InvalidParameterError',
} as const;

export type InvalidParameterErrorNameEnum =
  (typeof InvalidParameterErrorNameEnum)[keyof typeof InvalidParameterErrorNameEnum];
export const InvalidParameterErrorMessageEnum = {
  InvalidParameterParam: 'Invalid parameter: ${param}.',
} as const;

export type InvalidParameterErrorMessageEnum =
  (typeof InvalidParameterErrorMessageEnum)[keyof typeof InvalidParameterErrorMessageEnum];
export const InvalidParameterErrorHttpStatusCodeEnum = {
  NUMBER_400: 400,
} as const;

export type InvalidParameterErrorHttpStatusCodeEnum =
  (typeof InvalidParameterErrorHttpStatusCodeEnum)[keyof typeof InvalidParameterErrorHttpStatusCodeEnum];

/**
 *
 * @export
 * @interface InvalidParametersError
 */
export interface InvalidParametersError {
  /**
   *
   * @type {string}
   * @memberof InvalidParametersError
   */
  name?: InvalidParametersErrorNameEnum;
  /**
   *
   * @type {string}
   * @memberof InvalidParametersError
   */
  message?: InvalidParametersErrorMessageEnum;
  /**
   *
   * @type {number}
   * @memberof InvalidParametersError
   */
  httpStatusCode?: InvalidParametersErrorHttpStatusCodeEnum;
}

export const InvalidParametersErrorNameEnum = {
  InvalidParametersError: 'InvalidParametersError',
} as const;

export type InvalidParametersErrorNameEnum =
  (typeof InvalidParametersErrorNameEnum)[keyof typeof InvalidParametersErrorNameEnum];
export const InvalidParametersErrorMessageEnum = {
  ClassNameInvalidParameters: '${className} invalid parameters.',
} as const;

export type InvalidParametersErrorMessageEnum =
  (typeof InvalidParametersErrorMessageEnum)[keyof typeof InvalidParametersErrorMessageEnum];
export const InvalidParametersErrorHttpStatusCodeEnum = {
  NUMBER_400: 400,
} as const;

export type InvalidParametersErrorHttpStatusCodeEnum =
  (typeof InvalidParametersErrorHttpStatusCodeEnum)[keyof typeof InvalidParametersErrorHttpStatusCodeEnum];

/**
 *
 * @export
 * @interface ItemAlreadyExistsError
 */
export interface ItemAlreadyExistsError {
  /**
   *
   * @type {string}
   * @memberof ItemAlreadyExistsError
   */
  name?: ItemAlreadyExistsErrorNameEnum;
  /**
   *
   * @type {string}
   * @memberof ItemAlreadyExistsError
   */
  message?: ItemAlreadyExistsErrorMessageEnum;
  /**
   *
   * @type {number}
   * @memberof ItemAlreadyExistsError
   */
  httpStatusCode?: ItemAlreadyExistsErrorHttpStatusCodeEnum;
}

export const ItemAlreadyExistsErrorNameEnum = {
  ItemAlreadyExistsError: 'ItemAlreadyExistsError',
} as const;

export type ItemAlreadyExistsErrorNameEnum =
  (typeof ItemAlreadyExistsErrorNameEnum)[keyof typeof ItemAlreadyExistsErrorNameEnum];
export const ItemAlreadyExistsErrorMessageEnum = {
  ItemAlreadyExists: 'Item already exists',
} as const;

export type ItemAlreadyExistsErrorMessageEnum =
  (typeof ItemAlreadyExistsErrorMessageEnum)[keyof typeof ItemAlreadyExistsErrorMessageEnum];
export const ItemAlreadyExistsErrorHttpStatusCodeEnum = {
  NUMBER_409: 409,
} as const;

export type ItemAlreadyExistsErrorHttpStatusCodeEnum =
  (typeof ItemAlreadyExistsErrorHttpStatusCodeEnum)[keyof typeof ItemAlreadyExistsErrorHttpStatusCodeEnum];

/**
 * Mappings between common schemas and connectors
 * @export
 * @interface MappingsResponse
 */
export interface MappingsResponse {
  /**
   * A dictionary containing mappings between a common schema and a list of connectors
   * @type {{ [key: string]: Array<BasicConnectorDTO>; }}
   * @memberof MappingsResponse
   */
  mappings: { [key: string]: Array<BasicConnectorDTO> };
}
/**
 *
 * @export
 * @interface NotFoundError
 */
export interface NotFoundError {
  /**
   *
   * @type {string}
   * @memberof NotFoundError
   */
  name?: NotFoundErrorNameEnum;
  /**
   *
   * @type {string}
   * @memberof NotFoundError
   */
  message?: NotFoundErrorMessageEnum;
  /**
   *
   * @type {number}
   * @memberof NotFoundError
   */
  httpStatusCode?: NotFoundErrorHttpStatusCodeEnum;
}

export const NotFoundErrorNameEnum = {
  NotFoundError: 'NotFoundError',
} as const;

export type NotFoundErrorNameEnum =
  (typeof NotFoundErrorNameEnum)[keyof typeof NotFoundErrorNameEnum];
export const NotFoundErrorMessageEnum = {
  NotFoundParam: 'Not found: ${param}.',
} as const;

export type NotFoundErrorMessageEnum =
  (typeof NotFoundErrorMessageEnum)[keyof typeof NotFoundErrorMessageEnum];
export const NotFoundErrorHttpStatusCodeEnum = {
  NUMBER_404: 404,
} as const;

export type NotFoundErrorHttpStatusCodeEnum =
  (typeof NotFoundErrorHttpStatusCodeEnum)[keyof typeof NotFoundErrorHttpStatusCodeEnum];

/**
 * Updates a connector\'s data source IDs or configuration.
 * @export
 * @interface PatchConnectorRequest
 */
export interface PatchConnectorRequest {
  /**
   * The updated list of data source IDs for the connector.
   * @type {Array<string>}
   * @memberof PatchConnectorRequest
   */
  dataSourceIds?: Array<string>;
  /**
   *
   * @type {ConnectorAuthConfig}
   * @memberof PatchConnectorRequest
   */
  config?: ConnectorAuthConfig;
  /**
   * The name of the connector.
   * @type {string}
   * @memberof PatchConnectorRequest
   */
  name?: string;
  /**
   * The new status of the connector.
   * @type {string}
   * @memberof PatchConnectorRequest
   */
  status?: PatchConnectorRequestStatusEnum;
  /**
   * The icon of the connector as base64 encoded string.
   * @type {string}
   * @memberof PatchConnectorRequest
   */
  icon?: string;
  /**
   * The URL of the website for the connector.
   * @type {string}
   * @memberof PatchConnectorRequest
   */
  websiteUri?: string;
}

export const PatchConnectorRequestStatusEnum = {
  Draft: 'DRAFT',
  Ready: 'READY',
} as const;

export type PatchConnectorRequestStatusEnum =
  (typeof PatchConnectorRequestStatusEnum)[keyof typeof PatchConnectorRequestStatusEnum];

/**
 * The response for activating or deactivating
 * @export
 * @interface PatchDataSourceConfigStatusResponse
 */
export interface PatchDataSourceConfigStatusResponse {
  /**
   *
   * @type {string}
   * @memberof PatchDataSourceConfigStatusResponse
   */
  ssoUrl?: string;
  /**
   *
   * @type {DataSourceConfig}
   * @memberof PatchDataSourceConfigStatusResponse
   */
  dataSourceConfig?: DataSourceConfig;
}
/**
 * The response for activating or deactivating
 * @export
 * @interface PatchDataSourceStatusResponse
 */
export interface PatchDataSourceStatusResponse {
  /**
   *
   * @type {string}
   * @memberof PatchDataSourceStatusResponse
   */
  ssoUrl?: string;
  /**
   *
   * @type {DataSource}
   * @memberof PatchDataSourceStatusResponse
   */
  dataSource?: DataSource;
}
/**
 * The Connector that hast just been created.
 * @export
 * @interface PostConnectorsResponse
 */
export interface PostConnectorsResponse {
  /**
   *
   * @type {ConnectorDTO}
   * @memberof PostConnectorsResponse
   */
  connector: ConnectorDTO;
}
/**
 *
 * @export
 * @interface ReferentialIntegrityError
 */
export interface ReferentialIntegrityError {
  /**
   *
   * @type {string}
   * @memberof ReferentialIntegrityError
   */
  name?: ReferentialIntegrityErrorNameEnum;
  /**
   *
   * @type {string}
   * @memberof ReferentialIntegrityError
   */
  message?: ReferentialIntegrityErrorMessageEnum;
  /**
   *
   * @type {number}
   * @memberof ReferentialIntegrityError
   */
  httpStatusCode?: ReferentialIntegrityErrorHttpStatusCodeEnum;
}

export const ReferentialIntegrityErrorNameEnum = {
  ReferentialIntegrityError: 'ReferentialIntegrityError',
} as const;

export type ReferentialIntegrityErrorNameEnum =
  (typeof ReferentialIntegrityErrorNameEnum)[keyof typeof ReferentialIntegrityErrorNameEnum];
export const ReferentialIntegrityErrorMessageEnum = {
  IntegrityConstraint: 'Integrity constraint',
} as const;

export type ReferentialIntegrityErrorMessageEnum =
  (typeof ReferentialIntegrityErrorMessageEnum)[keyof typeof ReferentialIntegrityErrorMessageEnum];
export const ReferentialIntegrityErrorHttpStatusCodeEnum = {
  NUMBER_409: 409,
} as const;

export type ReferentialIntegrityErrorHttpStatusCodeEnum =
  (typeof ReferentialIntegrityErrorHttpStatusCodeEnum)[keyof typeof ReferentialIntegrityErrorHttpStatusCodeEnum];

/**
 *
 * @export
 * @interface ResourceNotFoundError
 */
export interface ResourceNotFoundError {
  /**
   *
   * @type {string}
   * @memberof ResourceNotFoundError
   */
  name?: ResourceNotFoundErrorNameEnum;
  /**
   *
   * @type {string}
   * @memberof ResourceNotFoundError
   */
  message?: ResourceNotFoundErrorMessageEnum;
  /**
   *
   * @type {number}
   * @memberof ResourceNotFoundError
   */
  httpStatusCode?: ResourceNotFoundErrorHttpStatusCodeEnum;
}

export const ResourceNotFoundErrorNameEnum = {
  ResourceNotFoundError: 'ResourceNotFoundError',
} as const;

export type ResourceNotFoundErrorNameEnum =
  (typeof ResourceNotFoundErrorNameEnum)[keyof typeof ResourceNotFoundErrorNameEnum];
export const ResourceNotFoundErrorMessageEnum = {
  TheRequestedResourceHasNotBeenFound:
    'The requested resource has not been found',
} as const;

export type ResourceNotFoundErrorMessageEnum =
  (typeof ResourceNotFoundErrorMessageEnum)[keyof typeof ResourceNotFoundErrorMessageEnum];
export const ResourceNotFoundErrorHttpStatusCodeEnum = {
  NUMBER_404: 404,
} as const;

export type ResourceNotFoundErrorHttpStatusCodeEnum =
  (typeof ResourceNotFoundErrorHttpStatusCodeEnum)[keyof typeof ResourceNotFoundErrorHttpStatusCodeEnum];

/**
 * This schema represents the default response in case of an API call resulting in an error.
 * @export
 * @interface ServiceErrorResponse
 */
export interface ServiceErrorResponse {
  /**
   * An unique id for correlating this specific error to logs.
   * @type {string}
   * @memberof ServiceErrorResponse
   */
  debugId: string;
  /**
   * The name of the error.
   * @type {string}
   * @memberof ServiceErrorResponse
   */
  name: string;
  /**
   * The backwards compatible Affinidi error code.
   * @type {string}
   * @memberof ServiceErrorResponse
   */
  code: string;
  /**
   * An optional list of explanatatory details about the occured errors.
   * @type {Array<ServiceErrorResponseDetailsInner>}
   * @memberof ServiceErrorResponse
   */
  details?: Array<ServiceErrorResponseDetailsInner>;
}
/**
 * Details about an input error informing about the location and the reason of the error.
 * @export
 * @interface ServiceErrorResponseDetailsInner
 */
export interface ServiceErrorResponseDetailsInner {
  /**
   * Information about what the error is about.
   * @type {string}
   * @memberof ServiceErrorResponseDetailsInner
   */
  issue: string;
  /**
   * Indicates the field which contains or is the issue.
   * @type {string}
   * @memberof ServiceErrorResponseDetailsInner
   */
  field?: string;
  /**
   * Indicates the field value which contains or is the issue.
   * @type {string}
   * @memberof ServiceErrorResponseDetailsInner
   */
  value?: string;
  /**
   * Indicates where the error occurred.
   * @type {string}
   * @memberof ServiceErrorResponseDetailsInner
   */
  location?: ServiceErrorResponseDetailsInnerLocationEnum;
}

export const ServiceErrorResponseDetailsInnerLocationEnum = {
  Body: 'BODY',
  Path: 'PATH',
  Query: 'QUERY',
} as const;

export type ServiceErrorResponseDetailsInnerLocationEnum =
  (typeof ServiceErrorResponseDetailsInnerLocationEnum)[keyof typeof ServiceErrorResponseDetailsInnerLocationEnum];

/**
 *
 * @export
 * @interface TransformationTemplateDto
 */
export interface TransformationTemplateDto {
  /**
   *
   * @type {string}
   * @memberof TransformationTemplateDto
   */
  endpoint: string;
  /**
   *
   * @type {string}
   * @memberof TransformationTemplateDto
   */
  targetSchemaUrl: string;
  /**
   *
   * @type {TransformationTemplateDtoSchemaMapping}
   * @memberof TransformationTemplateDto
   */
  schemaMapping: TransformationTemplateDtoSchemaMapping;
}
/**
 *
 * @export
 * @interface TransformationTemplateDtoSchemaMapping
 */
export interface TransformationTemplateDtoSchemaMapping {
  /**
   *
   * @type {Array<TransformationTemplateDtoSchemaMappingTransformationsInner>}
   * @memberof TransformationTemplateDtoSchemaMapping
   */
  transformations: Array<TransformationTemplateDtoSchemaMappingTransformationsInner>;
  /**
   *
   * @type {Array<TransformationTemplateDtoSchemaMappingAggregationsInner>}
   * @memberof TransformationTemplateDtoSchemaMapping
   */
  aggregations: Array<TransformationTemplateDtoSchemaMappingAggregationsInner>;
}
/**
 *
 * @export
 * @interface TransformationTemplateDtoSchemaMappingAggregationsInner
 */
export interface TransformationTemplateDtoSchemaMappingAggregationsInner {
  [key: string]: any;

  /**
   *
   * @type {string}
   * @memberof TransformationTemplateDtoSchemaMappingAggregationsInner
   */
  name: string;
  /**
   *
   * @type {Array<string>}
   * @memberof TransformationTemplateDtoSchemaMappingAggregationsInner
   */
  fields?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof TransformationTemplateDtoSchemaMappingAggregationsInner
   */
  resultField?: string;
}
/**
 *
 * @export
 * @interface TransformationTemplateDtoSchemaMappingTransformationsInner
 */
export interface TransformationTemplateDtoSchemaMappingTransformationsInner {
  [key: string]: any;

  /**
   *
   * @type {string}
   * @memberof TransformationTemplateDtoSchemaMappingTransformationsInner
   */
  name: string;
  /**
   *
   * @type {Array<string>}
   * @memberof TransformationTemplateDtoSchemaMappingTransformationsInner
   */
  fields?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof TransformationTemplateDtoSchemaMappingTransformationsInner
   */
  resultField?: string;
}
/**
 *
 * @export
 * @interface UnauthorizedError
 */
export interface UnauthorizedError {
  /**
   *
   * @type {string}
   * @memberof UnauthorizedError
   */
  name?: UnauthorizedErrorNameEnum;
  /**
   *
   * @type {string}
   * @memberof UnauthorizedError
   */
  message?: UnauthorizedErrorMessageEnum;
  /**
   *
   * @type {number}
   * @memberof UnauthorizedError
   */
  httpStatusCode?: UnauthorizedErrorHttpStatusCodeEnum;
}

export const UnauthorizedErrorNameEnum = {
  UnauthorizedError: 'UnauthorizedError',
} as const;

export type UnauthorizedErrorNameEnum =
  (typeof UnauthorizedErrorNameEnum)[keyof typeof UnauthorizedErrorNameEnum];
export const UnauthorizedErrorMessageEnum = {
  UnauthorizedRequest: 'Unauthorized request',
} as const;

export type UnauthorizedErrorMessageEnum =
  (typeof UnauthorizedErrorMessageEnum)[keyof typeof UnauthorizedErrorMessageEnum];
export const UnauthorizedErrorHttpStatusCodeEnum = {
  NUMBER_401: 401,
} as const;

export type UnauthorizedErrorHttpStatusCodeEnum =
  (typeof UnauthorizedErrorHttpStatusCodeEnum)[keyof typeof UnauthorizedErrorHttpStatusCodeEnum];

/**
 * CommonSchemaMappingsApi - axios parameter creator
 * @export
 */
export const CommonSchemaMappingsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Fetches mappings between commons schemas and connectors by schema names
     * @summary Gets mappings.
     * @param {Array<string>} schemas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCommonSchemaMappings: async (
      schemas: Array<string>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'schemas' is not null or undefined
      assertParamExists('getCommonSchemaMappings', 'schemas', schemas);
      const localVarPath = `/v1/mappings`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ConsumerTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration
      );

      if (schemas) {
        localVarQueryParameter['schemas'] = schemas;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CommonSchemaMappingsApi - functional programming interface
 * @export
 */
export const CommonSchemaMappingsApiFp = function (
  configuration?: Configuration
) {
  const localVarAxiosParamCreator =
    CommonSchemaMappingsApiAxiosParamCreator(configuration);
  return {
    /**
     * Fetches mappings between commons schemas and connectors by schema names
     * @summary Gets mappings.
     * @param {Array<string>} schemas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCommonSchemaMappings(
      schemas: Array<string>,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<MappingsResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCommonSchemaMappings(
          schemas,
          options
        );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['CommonSchemaMappingsApi.getCommonSchemaMappings']?.[
          index
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
  };
};

/**
 * CommonSchemaMappingsApi - factory interface
 * @export
 */
export const CommonSchemaMappingsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = CommonSchemaMappingsApiFp(configuration);
  return {
    /**
     * Fetches mappings between commons schemas and connectors by schema names
     * @summary Gets mappings.
     * @param {Array<string>} schemas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCommonSchemaMappings(
      schemas: Array<string>,
      options?: any
    ): AxiosPromise<MappingsResponse> {
      return localVarFp
        .getCommonSchemaMappings(schemas, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * CommonSchemaMappingsApi - object-oriented interface
 * @export
 * @class CommonSchemaMappingsApi
 * @extends {BaseAPI}
 */
export class CommonSchemaMappingsApi extends BaseAPI {
  /**
   * Fetches mappings between commons schemas and connectors by schema names
   * @summary Gets mappings.
   * @param {Array<string>} schemas
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CommonSchemaMappingsApi
   */
  public getCommonSchemaMappings(
    schemas: Array<string>,
    options?: RawAxiosRequestConfig
  ) {
    return CommonSchemaMappingsApiFp(this.configuration)
      .getCommonSchemaMappings(schemas, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ConnectionsApi - axios parameter creator
 * @export
 */
export const ConnectionsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Callback endpoint used by external data sources to redirect after successful authentication.
     * @summary Authentication callback
     * @param {string} code A code which identifies the connection from the request.
     * @param {string} [state] The state of the connection.
     * @param {string} [scope] The scope which has been send to the external data source and should be returned here.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authCallback: async (
      code: string,
      state?: string,
      scope?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'code' is not null or undefined
      assertParamExists('authCallback', 'code', code);
      const localVarPath = `/v1/connections/callback`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (code !== undefined) {
        localVarQueryParameter['code'] = code;
      }

      if (state !== undefined) {
        localVarQueryParameter['state'] = state;
      }

      if (scope !== undefined) {
        localVarQueryParameter['scope'] = scope;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Deactivates a connection.
     * @summary Delete connection
     * @param {string} connectionId The ID of the connection to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteConnection: async (
      connectionId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'connectionId' is not null or undefined
      assertParamExists('deleteConnection', 'connectionId', connectionId);
      const localVarPath = `/v1/connections/{connectionId}`.replace(
        `{${'connectionId'}}`,
        encodeURIComponent(String(connectionId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ConsumerTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Executes a user connection on a connection.
     * @summary Create execution request
     * @param {string} connectionId The ID of the connection.
     * @param {object | null} body ExecuteConnection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeConnection: async (
      connectionId: string,
      body: object | null,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'connectionId' is not null or undefined
      assertParamExists('executeConnection', 'connectionId', connectionId);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('executeConnection', 'body', body);
      const localVarPath =
        `/v1/connections/{connectionId}/execution-request`.replace(
          `{${'connectionId'}}`,
          encodeURIComponent(String(connectionId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Fetches a list of active user connections
     * @summary List active connections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActiveConnections: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/active-connections`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ConsumerTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Fetch a list of active user connections in dry-run mode
     * @summary Get dry run connections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConnectionsDryRun: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/connections/dry-run`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves the details of the executed connection.
     * @summary Get executed connection
     * @param {string} connectionId The ID of the connection.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExecutedConnection: async (
      connectionId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'connectionId' is not null or undefined
      assertParamExists('getExecutedConnection', 'connectionId', connectionId);
      const localVarPath =
        `/v1/connections/{connectionId}/execution-request`.replace(
          `{${'connectionId'}}`,
          encodeURIComponent(String(connectionId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates a new user connection.
     * @summary Create connection
     * @param {ConnectionCreationRequest} connectionCreationRequest PostConnection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postConnection: async (
      connectionCreationRequest: ConnectionCreationRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'connectionCreationRequest' is not null or undefined
      assertParamExists(
        'postConnection',
        'connectionCreationRequest',
        connectionCreationRequest
      );
      const localVarPath = `/v1/connections`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ConsumerTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        connectionCreationRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a new user connection in dry-run mode to validate Connector
     * @summary Post dry run connection
     * @param {ConnectionCreationRequest} connectionCreationRequest PostConnectionsDryRun
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postConnectionsDryRun: async (
      connectionCreationRequest: ConnectionCreationRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'connectionCreationRequest' is not null or undefined
      assertParamExists(
        'postConnectionsDryRun',
        'connectionCreationRequest',
        connectionCreationRequest
      );
      const localVarPath = `/v1/connections/dry-run`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        connectionCreationRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ConnectionsApi - functional programming interface
 * @export
 */
export const ConnectionsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ConnectionsApiAxiosParamCreator(configuration);
  return {
    /**
     * Callback endpoint used by external data sources to redirect after successful authentication.
     * @summary Authentication callback
     * @param {string} code A code which identifies the connection from the request.
     * @param {string} [state] The state of the connection.
     * @param {string} [scope] The scope which has been send to the external data source and should be returned here.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authCallback(
      code: string,
      state?: string,
      scope?: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CallbackResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.authCallback(
        code,
        state,
        scope,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['ConnectionsApi.authCallback']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Deactivates a connection.
     * @summary Delete connection
     * @param {string} connectionId The ID of the connection to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteConnection(
      connectionId: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteConnection(connectionId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['ConnectionsApi.deleteConnection']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Executes a user connection on a connection.
     * @summary Create execution request
     * @param {string} connectionId The ID of the connection.
     * @param {object | null} body ExecuteConnection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async executeConnection(
      connectionId: string,
      body: object | null,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GenericResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.executeConnection(
          connectionId,
          body,
          options
        );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['ConnectionsApi.executeConnection']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Fetches a list of active user connections
     * @summary List active connections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getActiveConnections(
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ActiveConnectionsResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getActiveConnections(options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['ConnectionsApi.getActiveConnections']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Fetch a list of active user connections in dry-run mode
     * @summary Get dry run connections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getConnectionsDryRun(
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ActiveConnectionsResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getConnectionsDryRun(options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['ConnectionsApi.getConnectionsDryRun']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Retrieves the details of the executed connection.
     * @summary Get executed connection
     * @param {string} connectionId The ID of the connection.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getExecutedConnection(
      connectionId: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ExecutedConnectionRequestResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getExecutedConnection(
          connectionId,
          options
        );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['ConnectionsApi.getExecutedConnection']?.[index]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Creates a new user connection.
     * @summary Create connection
     * @param {ConnectionCreationRequest} connectionCreationRequest PostConnection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postConnection(
      connectionCreationRequest: ConnectionCreationRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ConnectionCreationResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postConnection(
        connectionCreationRequest,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['ConnectionsApi.postConnection']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Create a new user connection in dry-run mode to validate Connector
     * @summary Post dry run connection
     * @param {ConnectionCreationRequest} connectionCreationRequest PostConnectionsDryRun
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postConnectionsDryRun(
      connectionCreationRequest: ConnectionCreationRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ConnectionCreationResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postConnectionsDryRun(
          connectionCreationRequest,
          options
        );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['ConnectionsApi.postConnectionsDryRun']?.[index]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
  };
};

/**
 * ConnectionsApi - factory interface
 * @export
 */
export const ConnectionsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ConnectionsApiFp(configuration);
  return {
    /**
     * Callback endpoint used by external data sources to redirect after successful authentication.
     * @summary Authentication callback
     * @param {string} code A code which identifies the connection from the request.
     * @param {string} [state] The state of the connection.
     * @param {string} [scope] The scope which has been send to the external data source and should be returned here.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authCallback(
      code: string,
      state?: string,
      scope?: string,
      options?: any
    ): AxiosPromise<CallbackResponse> {
      return localVarFp
        .authCallback(code, state, scope, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Deactivates a connection.
     * @summary Delete connection
     * @param {string} connectionId The ID of the connection to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteConnection(connectionId: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteConnection(connectionId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Executes a user connection on a connection.
     * @summary Create execution request
     * @param {string} connectionId The ID of the connection.
     * @param {object | null} body ExecuteConnection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeConnection(
      connectionId: string,
      body: object | null,
      options?: any
    ): AxiosPromise<GenericResponse> {
      return localVarFp
        .executeConnection(connectionId, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Fetches a list of active user connections
     * @summary List active connections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActiveConnections(
      options?: any
    ): AxiosPromise<ActiveConnectionsResponse> {
      return localVarFp
        .getActiveConnections(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Fetch a list of active user connections in dry-run mode
     * @summary Get dry run connections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConnectionsDryRun(
      options?: any
    ): AxiosPromise<ActiveConnectionsResponse> {
      return localVarFp
        .getConnectionsDryRun(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves the details of the executed connection.
     * @summary Get executed connection
     * @param {string} connectionId The ID of the connection.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExecutedConnection(
      connectionId: string,
      options?: any
    ): AxiosPromise<ExecutedConnectionRequestResponse> {
      return localVarFp
        .getExecutedConnection(connectionId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Creates a new user connection.
     * @summary Create connection
     * @param {ConnectionCreationRequest} connectionCreationRequest PostConnection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postConnection(
      connectionCreationRequest: ConnectionCreationRequest,
      options?: any
    ): AxiosPromise<ConnectionCreationResponse> {
      return localVarFp
        .postConnection(connectionCreationRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create a new user connection in dry-run mode to validate Connector
     * @summary Post dry run connection
     * @param {ConnectionCreationRequest} connectionCreationRequest PostConnectionsDryRun
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postConnectionsDryRun(
      connectionCreationRequest: ConnectionCreationRequest,
      options?: any
    ): AxiosPromise<ConnectionCreationResponse> {
      return localVarFp
        .postConnectionsDryRun(connectionCreationRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ConnectionsApi - object-oriented interface
 * @export
 * @class ConnectionsApi
 * @extends {BaseAPI}
 */
export class ConnectionsApi extends BaseAPI {
  /**
   * Callback endpoint used by external data sources to redirect after successful authentication.
   * @summary Authentication callback
   * @param {string} code A code which identifies the connection from the request.
   * @param {string} [state] The state of the connection.
   * @param {string} [scope] The scope which has been send to the external data source and should be returned here.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConnectionsApi
   */
  public authCallback(
    code: string,
    state?: string,
    scope?: string,
    options?: RawAxiosRequestConfig
  ) {
    return ConnectionsApiFp(this.configuration)
      .authCallback(code, state, scope, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deactivates a connection.
   * @summary Delete connection
   * @param {string} connectionId The ID of the connection to be deleted.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConnectionsApi
   */
  public deleteConnection(
    connectionId: string,
    options?: RawAxiosRequestConfig
  ) {
    return ConnectionsApiFp(this.configuration)
      .deleteConnection(connectionId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Executes a user connection on a connection.
   * @summary Create execution request
   * @param {string} connectionId The ID of the connection.
   * @param {object | null} body ExecuteConnection
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConnectionsApi
   */
  public executeConnection(
    connectionId: string,
    body: object | null,
    options?: RawAxiosRequestConfig
  ) {
    return ConnectionsApiFp(this.configuration)
      .executeConnection(connectionId, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Fetches a list of active user connections
   * @summary List active connections
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConnectionsApi
   */
  public getActiveConnections(options?: RawAxiosRequestConfig) {
    return ConnectionsApiFp(this.configuration)
      .getActiveConnections(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Fetch a list of active user connections in dry-run mode
   * @summary Get dry run connections
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConnectionsApi
   */
  public getConnectionsDryRun(options?: RawAxiosRequestConfig) {
    return ConnectionsApiFp(this.configuration)
      .getConnectionsDryRun(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves the details of the executed connection.
   * @summary Get executed connection
   * @param {string} connectionId The ID of the connection.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConnectionsApi
   */
  public getExecutedConnection(
    connectionId: string,
    options?: RawAxiosRequestConfig
  ) {
    return ConnectionsApiFp(this.configuration)
      .getExecutedConnection(connectionId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Creates a new user connection.
   * @summary Create connection
   * @param {ConnectionCreationRequest} connectionCreationRequest PostConnection
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConnectionsApi
   */
  public postConnection(
    connectionCreationRequest: ConnectionCreationRequest,
    options?: RawAxiosRequestConfig
  ) {
    return ConnectionsApiFp(this.configuration)
      .postConnection(connectionCreationRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a new user connection in dry-run mode to validate Connector
   * @summary Post dry run connection
   * @param {ConnectionCreationRequest} connectionCreationRequest PostConnectionsDryRun
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConnectionsApi
   */
  public postConnectionsDryRun(
    connectionCreationRequest: ConnectionCreationRequest,
    options?: RawAxiosRequestConfig
  ) {
    return ConnectionsApiFp(this.configuration)
      .postConnectionsDryRun(connectionCreationRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ConnectorsApi - axios parameter creator
 * @export
 */
export const ConnectorsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Used to delete a connector.
     * @summary Delete connector
     * @param {string} connectorId The ID of the connector.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteConnectors: async (
      connectorId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'connectorId' is not null or undefined
      assertParamExists('deleteConnectors', 'connectorId', connectorId);
      const localVarPath = `/v1/connectors/{connectorId}`.replace(
        `{${'connectorId'}}`,
        encodeURIComponent(String(connectorId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This is a consumer facing connector endpoint. It fetches list of available Connectors.
     * @summary Lists available connectors.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAvailableConnectors: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/available-connectors`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ConsumerTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This is a consumer facing connector endpoint. It fetches an available connector by ID.
     * @summary Gets an available connector by ID.
     * @param {string} connectorId The ID of the connector.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAvailableConnectorsById: async (
      connectorId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'connectorId' is not null or undefined
      assertParamExists(
        'getAvailableConnectorsById',
        'connectorId',
        connectorId
      );
      const localVarPath = `/v1/available-connectors/{connectorId}`.replace(
        `{${'connectorId'}}`,
        encodeURIComponent(String(connectorId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ConsumerTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Fetches a list of all connectors.
     * @summary List connectors
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConnectors: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/connectors`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Fetches a connector by its ID.
     * @summary Get connector by ID
     * @param {string} connectorId The ID of the connector.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConnectorsById: async (
      connectorId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'connectorId' is not null or undefined
      assertParamExists('getConnectorsById', 'connectorId', connectorId);
      const localVarPath = `/v1/connectors/{connectorId}`.replace(
        `{${'connectorId'}}`,
        encodeURIComponent(String(connectorId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Updates an existing connector by its ID.
     * @summary Update connector
     * @param {string} connectorId The ID of the connector.
     * @param {PatchConnectorRequest} [patchConnectorRequest] PatchConnectors
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchConnectors: async (
      connectorId: string,
      patchConnectorRequest?: PatchConnectorRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'connectorId' is not null or undefined
      assertParamExists('patchConnectors', 'connectorId', connectorId);
      const localVarPath = `/v1/connectors/{connectorId}`.replace(
        `{${'connectorId'}}`,
        encodeURIComponent(String(connectorId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        patchConnectorRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates a new connector.
     * @summary Create connector
     * @param {ConnectorsCreationRequest} [connectorsCreationRequest] PostConnectors
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postConnectors: async (
      connectorsCreationRequest?: ConnectorsCreationRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/connectors`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        connectorsCreationRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ConnectorsApi - functional programming interface
 * @export
 */
export const ConnectorsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ConnectorsApiAxiosParamCreator(configuration);
  return {
    /**
     * Used to delete a connector.
     * @summary Delete connector
     * @param {string} connectorId The ID of the connector.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteConnectors(
      connectorId: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteConnectors(connectorId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['ConnectorsApi.deleteConnectors']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * This is a consumer facing connector endpoint. It fetches list of available Connectors.
     * @summary Lists available connectors.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAvailableConnectors(
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<AvailableConnectorsResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAvailableConnectors(options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['ConnectorsApi.getAvailableConnectors']?.[index]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * This is a consumer facing connector endpoint. It fetches an available connector by ID.
     * @summary Gets an available connector by ID.
     * @param {string} connectorId The ID of the connector.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAvailableConnectorsById(
      connectorId: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ConnectorsByIdResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAvailableConnectorsById(
          connectorId,
          options
        );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['ConnectorsApi.getAvailableConnectorsById']?.[index]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Fetches a list of all connectors.
     * @summary List connectors
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getConnectors(
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ConnectorsResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getConnectors(
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['ConnectorsApi.getConnectors']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Fetches a connector by its ID.
     * @summary Get connector by ID
     * @param {string} connectorId The ID of the connector.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getConnectorsById(
      connectorId: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ConnectorsByIdResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getConnectorsById(connectorId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['ConnectorsApi.getConnectorsById']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Updates an existing connector by its ID.
     * @summary Update connector
     * @param {string} connectorId The ID of the connector.
     * @param {PatchConnectorRequest} [patchConnectorRequest] PatchConnectors
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchConnectors(
      connectorId: string,
      patchConnectorRequest?: PatchConnectorRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectorDTO>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.patchConnectors(
        connectorId,
        patchConnectorRequest,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['ConnectorsApi.patchConnectors']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Creates a new connector.
     * @summary Create connector
     * @param {ConnectorsCreationRequest} [connectorsCreationRequest] PostConnectors
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postConnectors(
      connectorsCreationRequest?: ConnectorsCreationRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PostConnectorsResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postConnectors(
        connectorsCreationRequest,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['ConnectorsApi.postConnectors']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
  };
};

/**
 * ConnectorsApi - factory interface
 * @export
 */
export const ConnectorsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ConnectorsApiFp(configuration);
  return {
    /**
     * Used to delete a connector.
     * @summary Delete connector
     * @param {string} connectorId The ID of the connector.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteConnectors(connectorId: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteConnectors(connectorId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * This is a consumer facing connector endpoint. It fetches list of available Connectors.
     * @summary Lists available connectors.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAvailableConnectors(
      options?: any
    ): AxiosPromise<AvailableConnectorsResponse> {
      return localVarFp
        .getAvailableConnectors(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * This is a consumer facing connector endpoint. It fetches an available connector by ID.
     * @summary Gets an available connector by ID.
     * @param {string} connectorId The ID of the connector.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAvailableConnectorsById(
      connectorId: string,
      options?: any
    ): AxiosPromise<ConnectorsByIdResponse> {
      return localVarFp
        .getAvailableConnectorsById(connectorId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Fetches a list of all connectors.
     * @summary List connectors
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConnectors(options?: any): AxiosPromise<ConnectorsResponse> {
      return localVarFp
        .getConnectors(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Fetches a connector by its ID.
     * @summary Get connector by ID
     * @param {string} connectorId The ID of the connector.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConnectorsById(
      connectorId: string,
      options?: any
    ): AxiosPromise<ConnectorsByIdResponse> {
      return localVarFp
        .getConnectorsById(connectorId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Updates an existing connector by its ID.
     * @summary Update connector
     * @param {string} connectorId The ID of the connector.
     * @param {PatchConnectorRequest} [patchConnectorRequest] PatchConnectors
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchConnectors(
      connectorId: string,
      patchConnectorRequest?: PatchConnectorRequest,
      options?: any
    ): AxiosPromise<ConnectorDTO> {
      return localVarFp
        .patchConnectors(connectorId, patchConnectorRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Creates a new connector.
     * @summary Create connector
     * @param {ConnectorsCreationRequest} [connectorsCreationRequest] PostConnectors
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postConnectors(
      connectorsCreationRequest?: ConnectorsCreationRequest,
      options?: any
    ): AxiosPromise<PostConnectorsResponse> {
      return localVarFp
        .postConnectors(connectorsCreationRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ConnectorsApi - object-oriented interface
 * @export
 * @class ConnectorsApi
 * @extends {BaseAPI}
 */
export class ConnectorsApi extends BaseAPI {
  /**
   * Used to delete a connector.
   * @summary Delete connector
   * @param {string} connectorId The ID of the connector.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConnectorsApi
   */
  public deleteConnectors(
    connectorId: string,
    options?: RawAxiosRequestConfig
  ) {
    return ConnectorsApiFp(this.configuration)
      .deleteConnectors(connectorId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * This is a consumer facing connector endpoint. It fetches list of available Connectors.
   * @summary Lists available connectors.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConnectorsApi
   */
  public getAvailableConnectors(options?: RawAxiosRequestConfig) {
    return ConnectorsApiFp(this.configuration)
      .getAvailableConnectors(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * This is a consumer facing connector endpoint. It fetches an available connector by ID.
   * @summary Gets an available connector by ID.
   * @param {string} connectorId The ID of the connector.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConnectorsApi
   */
  public getAvailableConnectorsById(
    connectorId: string,
    options?: RawAxiosRequestConfig
  ) {
    return ConnectorsApiFp(this.configuration)
      .getAvailableConnectorsById(connectorId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Fetches a list of all connectors.
   * @summary List connectors
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConnectorsApi
   */
  public getConnectors(options?: RawAxiosRequestConfig) {
    return ConnectorsApiFp(this.configuration)
      .getConnectors(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Fetches a connector by its ID.
   * @summary Get connector by ID
   * @param {string} connectorId The ID of the connector.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConnectorsApi
   */
  public getConnectorsById(
    connectorId: string,
    options?: RawAxiosRequestConfig
  ) {
    return ConnectorsApiFp(this.configuration)
      .getConnectorsById(connectorId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Updates an existing connector by its ID.
   * @summary Update connector
   * @param {string} connectorId The ID of the connector.
   * @param {PatchConnectorRequest} [patchConnectorRequest] PatchConnectors
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConnectorsApi
   */
  public patchConnectors(
    connectorId: string,
    patchConnectorRequest?: PatchConnectorRequest,
    options?: RawAxiosRequestConfig
  ) {
    return ConnectorsApiFp(this.configuration)
      .patchConnectors(connectorId, patchConnectorRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Creates a new connector.
   * @summary Create connector
   * @param {ConnectorsCreationRequest} [connectorsCreationRequest] PostConnectors
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConnectorsApi
   */
  public postConnectors(
    connectorsCreationRequest?: ConnectorsCreationRequest,
    options?: RawAxiosRequestConfig
  ) {
    return ConnectorsApiFp(this.configuration)
      .postConnectors(connectorsCreationRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * CorsApi - axios parameter creator
 * @export
 */
export const CorsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Enable CORS by returning correct headers
     * @summary CORS Support
     * @param {string} connectorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    corsDeleteConnectors: async (
      connectorId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'connectorId' is not null or undefined
      assertParamExists('corsDeleteConnectors', 'connectorId', connectorId);
      const localVarPath = `/v1/connectors/{connectorId}`.replace(
        `{${'connectorId'}}`,
        encodeURIComponent(String(connectorId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'OPTIONS',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Enable CORS by returning correct headers
     * @summary CORS Support
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    corsGetActiveConnections: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/active-connections`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'OPTIONS',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Enable CORS by returning correct headers
     * @summary CORS Support
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    corsGetActiveConnectionsTemp: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/temp-active-connections`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'OPTIONS',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Enable CORS by returning correct headers
     * @summary CORS Support
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    corsGetAvailableConnectors: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/available-connectors`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'OPTIONS',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Enable CORS by returning correct headers
     * @summary CORS Support
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    corsPostConnection: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/connections`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'OPTIONS',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Enable CORS by returning correct headers
     * @summary CORS Support
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    corsPostConnectionTemp: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/connections-temp`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'OPTIONS',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CorsApi - functional programming interface
 * @export
 */
export const CorsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = CorsApiAxiosParamCreator(configuration);
  return {
    /**
     * Enable CORS by returning correct headers
     * @summary CORS Support
     * @param {string} connectorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async corsDeleteConnectors(
      connectorId: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.corsDeleteConnectors(
          connectorId,
          options
        );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['CorsApi.corsDeleteConnectors']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Enable CORS by returning correct headers
     * @summary CORS Support
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async corsGetActiveConnections(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.corsGetActiveConnections(options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['CorsApi.corsGetActiveConnections']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Enable CORS by returning correct headers
     * @summary CORS Support
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async corsGetActiveConnectionsTemp(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.corsGetActiveConnectionsTemp(options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['CorsApi.corsGetActiveConnectionsTemp']?.[index]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Enable CORS by returning correct headers
     * @summary CORS Support
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async corsGetAvailableConnectors(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.corsGetAvailableConnectors(options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['CorsApi.corsGetAvailableConnectors']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Enable CORS by returning correct headers
     * @summary CORS Support
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async corsPostConnection(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.corsPostConnection(options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['CorsApi.corsPostConnection']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Enable CORS by returning correct headers
     * @summary CORS Support
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async corsPostConnectionTemp(
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.corsPostConnectionTemp(options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['CorsApi.corsPostConnectionTemp']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
  };
};

/**
 * CorsApi - factory interface
 * @export
 */
export const CorsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = CorsApiFp(configuration);
  return {
    /**
     * Enable CORS by returning correct headers
     * @summary CORS Support
     * @param {string} connectorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    corsDeleteConnectors(
      connectorId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .corsDeleteConnectors(connectorId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Enable CORS by returning correct headers
     * @summary CORS Support
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    corsGetActiveConnections(options?: any): AxiosPromise<void> {
      return localVarFp
        .corsGetActiveConnections(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Enable CORS by returning correct headers
     * @summary CORS Support
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    corsGetActiveConnectionsTemp(options?: any): AxiosPromise<void> {
      return localVarFp
        .corsGetActiveConnectionsTemp(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Enable CORS by returning correct headers
     * @summary CORS Support
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    corsGetAvailableConnectors(options?: any): AxiosPromise<void> {
      return localVarFp
        .corsGetAvailableConnectors(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Enable CORS by returning correct headers
     * @summary CORS Support
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    corsPostConnection(options?: any): AxiosPromise<void> {
      return localVarFp
        .corsPostConnection(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Enable CORS by returning correct headers
     * @summary CORS Support
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    corsPostConnectionTemp(options?: any): AxiosPromise<void> {
      return localVarFp
        .corsPostConnectionTemp(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * CorsApi - object-oriented interface
 * @export
 * @class CorsApi
 * @extends {BaseAPI}
 */
export class CorsApi extends BaseAPI {
  /**
   * Enable CORS by returning correct headers
   * @summary CORS Support
   * @param {string} connectorId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CorsApi
   */
  public corsDeleteConnectors(
    connectorId: string,
    options?: RawAxiosRequestConfig
  ) {
    return CorsApiFp(this.configuration)
      .corsDeleteConnectors(connectorId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Enable CORS by returning correct headers
   * @summary CORS Support
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CorsApi
   */
  public corsGetActiveConnections(options?: RawAxiosRequestConfig) {
    return CorsApiFp(this.configuration)
      .corsGetActiveConnections(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Enable CORS by returning correct headers
   * @summary CORS Support
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CorsApi
   */
  public corsGetActiveConnectionsTemp(options?: RawAxiosRequestConfig) {
    return CorsApiFp(this.configuration)
      .corsGetActiveConnectionsTemp(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Enable CORS by returning correct headers
   * @summary CORS Support
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CorsApi
   */
  public corsGetAvailableConnectors(options?: RawAxiosRequestConfig) {
    return CorsApiFp(this.configuration)
      .corsGetAvailableConnectors(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Enable CORS by returning correct headers
   * @summary CORS Support
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CorsApi
   */
  public corsPostConnection(options?: RawAxiosRequestConfig) {
    return CorsApiFp(this.configuration)
      .corsPostConnection(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Enable CORS by returning correct headers
   * @summary CORS Support
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CorsApi
   */
  public corsPostConnectionTemp(options?: RawAxiosRequestConfig) {
    return CorsApiFp(this.configuration)
      .corsPostConnectionTemp(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * DataSourceConfigsApi - axios parameter creator
 * @export
 */
export const DataSourceConfigsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Deletes an existing data source configuration.
     * @summary Delete data source config
     * @param {string} dataSourceConfigId The ID of the data source config.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDataSourceConfig: async (
      dataSourceConfigId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'dataSourceConfigId' is not null or undefined
      assertParamExists(
        'deleteDataSourceConfig',
        'dataSourceConfigId',
        dataSourceConfigId
      );
      const localVarPath =
        `/v1/data-source-configs/{dataSourceConfigId}`.replace(
          `{${'dataSourceConfigId'}}`,
          encodeURIComponent(String(dataSourceConfigId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Fetches a list of available data source configurations.
     * @summary List data source config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataSourceConfig: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/data-source-configs`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Fetches a list of available data source configurations.
     * @summary gets a data-source-config by it\'s ID
     * @param {string} dataSourceConfigId The ID of the data source config.
     * @param {boolean} [validationResult]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataSourceConfigById: async (
      dataSourceConfigId: string,
      validationResult?: boolean,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'dataSourceConfigId' is not null or undefined
      assertParamExists(
        'getDataSourceConfigById',
        'dataSourceConfigId',
        dataSourceConfigId
      );
      const localVarPath =
        `/v1/data-source-configs/{dataSourceConfigId}`.replace(
          `{${'dataSourceConfigId'}}`,
          encodeURIComponent(String(dataSourceConfigId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration
      );

      if (validationResult !== undefined) {
        localVarQueryParameter['validationResult'] = validationResult;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Updates the status of an existing data source config.
     * @summary Update data source config status
     * @param {string} dataSourceConfigId The ID of the data source config.
     * @param {DataSourceConfigPatchStatusRequest} [dataSourceConfigPatchStatusRequest] PatchDataSourceConfigStatus
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchDataSourceConfigStatus: async (
      dataSourceConfigId: string,
      dataSourceConfigPatchStatusRequest?: DataSourceConfigPatchStatusRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'dataSourceConfigId' is not null or undefined
      assertParamExists(
        'patchDataSourceConfigStatus',
        'dataSourceConfigId',
        dataSourceConfigId
      );
      const localVarPath =
        `/v1/data-source-configs/{dataSourceConfigId}/status`.replace(
          `{${'dataSourceConfigId'}}`,
          encodeURIComponent(String(dataSourceConfigId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        dataSourceConfigPatchStatusRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Updates the authentication configuration of an existing data source.
     * @summary Update data source config
     * @param {string} dataSourceConfigId The ID of the data source config.
     * @param {DataSourceConfigPatchRequest} [dataSourceConfigPatchRequest] PatchDataSourceConfigs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchDataSourceConfigs: async (
      dataSourceConfigId: string,
      dataSourceConfigPatchRequest?: DataSourceConfigPatchRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'dataSourceConfigId' is not null or undefined
      assertParamExists(
        'patchDataSourceConfigs',
        'dataSourceConfigId',
        dataSourceConfigId
      );
      const localVarPath =
        `/v1/data-source-configs/{dataSourceConfigId}`.replace(
          `{${'dataSourceConfigId'}}`,
          encodeURIComponent(String(dataSourceConfigId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        dataSourceConfigPatchRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates a new data source configuration.
     * @summary Create data source config
     * @param {DataSourceConfig} [dataSourceConfig] PostDataSourceConfig
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postDataSourceConfig: async (
      dataSourceConfig?: DataSourceConfig,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/data-source-configs`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        dataSourceConfig,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DataSourceConfigsApi - functional programming interface
 * @export
 */
export const DataSourceConfigsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    DataSourceConfigsApiAxiosParamCreator(configuration);
  return {
    /**
     * Deletes an existing data source configuration.
     * @summary Delete data source config
     * @param {string} dataSourceConfigId The ID of the data source config.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteDataSourceConfig(
      dataSourceConfigId: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteDataSourceConfig(
          dataSourceConfigId,
          options
        );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['DataSourceConfigsApi.deleteDataSourceConfig']?.[
          index
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Fetches a list of available data source configurations.
     * @summary List data source config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDataSourceConfig(
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<DataSourceConfigResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getDataSourceConfig(options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['DataSourceConfigsApi.getDataSourceConfig']?.[index]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Fetches a list of available data source configurations.
     * @summary gets a data-source-config by it\'s ID
     * @param {string} dataSourceConfigId The ID of the data source config.
     * @param {boolean} [validationResult]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDataSourceConfigById(
      dataSourceConfigId: string,
      validationResult?: boolean,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<DataSourceConfigByIdResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getDataSourceConfigById(
          dataSourceConfigId,
          validationResult,
          options
        );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['DataSourceConfigsApi.getDataSourceConfigById']?.[
          index
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Updates the status of an existing data source config.
     * @summary Update data source config status
     * @param {string} dataSourceConfigId The ID of the data source config.
     * @param {DataSourceConfigPatchStatusRequest} [dataSourceConfigPatchStatusRequest] PatchDataSourceConfigStatus
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchDataSourceConfigStatus(
      dataSourceConfigId: string,
      dataSourceConfigPatchStatusRequest?: DataSourceConfigPatchStatusRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PatchDataSourceConfigStatusResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.patchDataSourceConfigStatus(
          dataSourceConfigId,
          dataSourceConfigPatchStatusRequest,
          options
        );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap[
          'DataSourceConfigsApi.patchDataSourceConfigStatus'
        ]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Updates the authentication configuration of an existing data source.
     * @summary Update data source config
     * @param {string} dataSourceConfigId The ID of the data source config.
     * @param {DataSourceConfigPatchRequest} [dataSourceConfigPatchRequest] PatchDataSourceConfigs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchDataSourceConfigs(
      dataSourceConfigId: string,
      dataSourceConfigPatchRequest?: DataSourceConfigPatchRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthConfigDto>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.patchDataSourceConfigs(
          dataSourceConfigId,
          dataSourceConfigPatchRequest,
          options
        );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['DataSourceConfigsApi.patchDataSourceConfigs']?.[
          index
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Creates a new data source configuration.
     * @summary Create data source config
     * @param {DataSourceConfig} [dataSourceConfig] PostDataSourceConfig
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postDataSourceConfig(
      dataSourceConfig?: DataSourceConfig,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GenericResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postDataSourceConfig(
          dataSourceConfig,
          options
        );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['DataSourceConfigsApi.postDataSourceConfig']?.[index]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
  };
};

/**
 * DataSourceConfigsApi - factory interface
 * @export
 */
export const DataSourceConfigsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = DataSourceConfigsApiFp(configuration);
  return {
    /**
     * Deletes an existing data source configuration.
     * @summary Delete data source config
     * @param {string} dataSourceConfigId The ID of the data source config.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDataSourceConfig(
      dataSourceConfigId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteDataSourceConfig(dataSourceConfigId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Fetches a list of available data source configurations.
     * @summary List data source config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataSourceConfig(options?: any): AxiosPromise<DataSourceConfigResponse> {
      return localVarFp
        .getDataSourceConfig(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Fetches a list of available data source configurations.
     * @summary gets a data-source-config by it\'s ID
     * @param {string} dataSourceConfigId The ID of the data source config.
     * @param {boolean} [validationResult]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataSourceConfigById(
      dataSourceConfigId: string,
      validationResult?: boolean,
      options?: any
    ): AxiosPromise<DataSourceConfigByIdResponse> {
      return localVarFp
        .getDataSourceConfigById(dataSourceConfigId, validationResult, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Updates the status of an existing data source config.
     * @summary Update data source config status
     * @param {string} dataSourceConfigId The ID of the data source config.
     * @param {DataSourceConfigPatchStatusRequest} [dataSourceConfigPatchStatusRequest] PatchDataSourceConfigStatus
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchDataSourceConfigStatus(
      dataSourceConfigId: string,
      dataSourceConfigPatchStatusRequest?: DataSourceConfigPatchStatusRequest,
      options?: any
    ): AxiosPromise<PatchDataSourceConfigStatusResponse> {
      return localVarFp
        .patchDataSourceConfigStatus(
          dataSourceConfigId,
          dataSourceConfigPatchStatusRequest,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Updates the authentication configuration of an existing data source.
     * @summary Update data source config
     * @param {string} dataSourceConfigId The ID of the data source config.
     * @param {DataSourceConfigPatchRequest} [dataSourceConfigPatchRequest] PatchDataSourceConfigs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchDataSourceConfigs(
      dataSourceConfigId: string,
      dataSourceConfigPatchRequest?: DataSourceConfigPatchRequest,
      options?: any
    ): AxiosPromise<AuthConfigDto> {
      return localVarFp
        .patchDataSourceConfigs(
          dataSourceConfigId,
          dataSourceConfigPatchRequest,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Creates a new data source configuration.
     * @summary Create data source config
     * @param {DataSourceConfig} [dataSourceConfig] PostDataSourceConfig
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postDataSourceConfig(
      dataSourceConfig?: DataSourceConfig,
      options?: any
    ): AxiosPromise<GenericResponse> {
      return localVarFp
        .postDataSourceConfig(dataSourceConfig, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * DataSourceConfigsApi - object-oriented interface
 * @export
 * @class DataSourceConfigsApi
 * @extends {BaseAPI}
 */
export class DataSourceConfigsApi extends BaseAPI {
  /**
   * Deletes an existing data source configuration.
   * @summary Delete data source config
   * @param {string} dataSourceConfigId The ID of the data source config.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataSourceConfigsApi
   */
  public deleteDataSourceConfig(
    dataSourceConfigId: string,
    options?: RawAxiosRequestConfig
  ) {
    return DataSourceConfigsApiFp(this.configuration)
      .deleteDataSourceConfig(dataSourceConfigId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Fetches a list of available data source configurations.
   * @summary List data source config
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataSourceConfigsApi
   */
  public getDataSourceConfig(options?: RawAxiosRequestConfig) {
    return DataSourceConfigsApiFp(this.configuration)
      .getDataSourceConfig(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Fetches a list of available data source configurations.
   * @summary gets a data-source-config by it\'s ID
   * @param {string} dataSourceConfigId The ID of the data source config.
   * @param {boolean} [validationResult]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataSourceConfigsApi
   */
  public getDataSourceConfigById(
    dataSourceConfigId: string,
    validationResult?: boolean,
    options?: RawAxiosRequestConfig
  ) {
    return DataSourceConfigsApiFp(this.configuration)
      .getDataSourceConfigById(dataSourceConfigId, validationResult, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Updates the status of an existing data source config.
   * @summary Update data source config status
   * @param {string} dataSourceConfigId The ID of the data source config.
   * @param {DataSourceConfigPatchStatusRequest} [dataSourceConfigPatchStatusRequest] PatchDataSourceConfigStatus
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataSourceConfigsApi
   */
  public patchDataSourceConfigStatus(
    dataSourceConfigId: string,
    dataSourceConfigPatchStatusRequest?: DataSourceConfigPatchStatusRequest,
    options?: RawAxiosRequestConfig
  ) {
    return DataSourceConfigsApiFp(this.configuration)
      .patchDataSourceConfigStatus(
        dataSourceConfigId,
        dataSourceConfigPatchStatusRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Updates the authentication configuration of an existing data source.
   * @summary Update data source config
   * @param {string} dataSourceConfigId The ID of the data source config.
   * @param {DataSourceConfigPatchRequest} [dataSourceConfigPatchRequest] PatchDataSourceConfigs
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataSourceConfigsApi
   */
  public patchDataSourceConfigs(
    dataSourceConfigId: string,
    dataSourceConfigPatchRequest?: DataSourceConfigPatchRequest,
    options?: RawAxiosRequestConfig
  ) {
    return DataSourceConfigsApiFp(this.configuration)
      .patchDataSourceConfigs(
        dataSourceConfigId,
        dataSourceConfigPatchRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Creates a new data source configuration.
   * @summary Create data source config
   * @param {DataSourceConfig} [dataSourceConfig] PostDataSourceConfig
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataSourceConfigsApi
   */
  public postDataSourceConfig(
    dataSourceConfig?: DataSourceConfig,
    options?: RawAxiosRequestConfig
  ) {
    return DataSourceConfigsApiFp(this.configuration)
      .postDataSourceConfig(dataSourceConfig, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * DataSourcesApi - axios parameter creator
 * @export
 */
export const DataSourcesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Deletes an existing data source.
     * @summary Delete data source
     * @param {string} dataSourceId The ID of the data source.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDataSource: async (
      dataSourceId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'dataSourceId' is not null or undefined
      assertParamExists('deleteDataSource', 'dataSourceId', dataSourceId);
      const localVarPath = `/v1/data-sources/{dataSourceId}`.replace(
        `{${'dataSourceId'}}`,
        encodeURIComponent(String(dataSourceId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Fetches a list of available data sources.
     * @summary List data source
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataSource: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/data-sources`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Fetches a data source by the ID passed
     * @summary Gets a data source by it\'s ID
     * @param {string} dataSourceId The ID of the data source.
     * @param {boolean} [validationResult]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataSourceById: async (
      dataSourceId: string,
      validationResult?: boolean,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'dataSourceId' is not null or undefined
      assertParamExists('getDataSourceById', 'dataSourceId', dataSourceId);
      const localVarPath = `/v1/data-sources/{dataSourceId}`.replace(
        `{${'dataSourceId'}}`,
        encodeURIComponent(String(dataSourceId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration
      );

      if (validationResult !== undefined) {
        localVarQueryParameter['validationResult'] = validationResult;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Updates the endpoint configuration of an existing datasource.
     * @summary Update data source
     * @param {string} dataSourceId The ID of the data source.
     * @param {DataSourcePatchRequest} [dataSourcePatchRequest] PatchDataSource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchDataSource: async (
      dataSourceId: string,
      dataSourcePatchRequest?: DataSourcePatchRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'dataSourceId' is not null or undefined
      assertParamExists('patchDataSource', 'dataSourceId', dataSourceId);
      const localVarPath = `/v1/data-sources/{dataSourceId}`.replace(
        `{${'dataSourceId'}}`,
        encodeURIComponent(String(dataSourceId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        dataSourcePatchRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Updates the status of an existing data source.
     * @summary Update data source status
     * @param {string} dataSourceId The ID of the data source.
     * @param {DataSourcePatchStatusRequest} [dataSourcePatchStatusRequest] PatchDataSourceStatus
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchDataSourceStatus: async (
      dataSourceId: string,
      dataSourcePatchStatusRequest?: DataSourcePatchStatusRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'dataSourceId' is not null or undefined
      assertParamExists('patchDataSourceStatus', 'dataSourceId', dataSourceId);
      const localVarPath = `/v1/data-sources/{dataSourceId}/status`.replace(
        `{${'dataSourceId'}}`,
        encodeURIComponent(String(dataSourceId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        dataSourcePatchStatusRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates a new data source.
     * @summary Create data source
     * @param {DataSource} [dataSource] PostDataSource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postDataSource: async (
      dataSource?: DataSource,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/data-sources`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        dataSource,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Adds a new transformation template to a data source. Template is a contributors-defined configuration object that describes how to interact with a specific third-party service\'s API, allowing developers to easily connect to and interact with a variety of sources, as well as customising the connector\'s behaviour.
     * @summary Create data source transformation template
     * @param {string} dataSourceId The ID of the datasource for the transformation template.
     * @param {CreateTransformationTemplateRequest} [createTransformationTemplateRequest] PostDataSourceTransformationTemplate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postDataSourceTransformationTemplate: async (
      dataSourceId: string,
      createTransformationTemplateRequest?: CreateTransformationTemplateRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'dataSourceId' is not null or undefined
      assertParamExists(
        'postDataSourceTransformationTemplate',
        'dataSourceId',
        dataSourceId
      );
      const localVarPath =
        `/v1/data-sources/{dataSourceId}/transformation-template`.replace(
          `{${'dataSourceId'}}`,
          encodeURIComponent(String(dataSourceId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ProjectTokenAuth required
      await setApiKeyToObject(
        localVarHeaderParameter,
        'authorization',
        configuration
      );

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createTransformationTemplateRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DataSourcesApi - functional programming interface
 * @export
 */
export const DataSourcesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    DataSourcesApiAxiosParamCreator(configuration);
  return {
    /**
     * Deletes an existing data source.
     * @summary Delete data source
     * @param {string} dataSourceId The ID of the data source.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteDataSource(
      dataSourceId: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteDataSource(dataSourceId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['DataSourcesApi.deleteDataSource']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Fetches a list of available data sources.
     * @summary List data source
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDataSource(
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<DataSourceResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDataSource(
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['DataSourcesApi.getDataSource']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Fetches a data source by the ID passed
     * @summary Gets a data source by it\'s ID
     * @param {string} dataSourceId The ID of the data source.
     * @param {boolean} [validationResult]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDataSourceById(
      dataSourceId: string,
      validationResult?: boolean,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetDataSourcebyIdResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getDataSourceById(
          dataSourceId,
          validationResult,
          options
        );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['DataSourcesApi.getDataSourceById']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Updates the endpoint configuration of an existing datasource.
     * @summary Update data source
     * @param {string} dataSourceId The ID of the data source.
     * @param {DataSourcePatchRequest} [dataSourcePatchRequest] PatchDataSource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchDataSource(
      dataSourceId: string,
      dataSourcePatchRequest?: DataSourcePatchRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataSource>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.patchDataSource(
        dataSourceId,
        dataSourcePatchRequest,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['DataSourcesApi.patchDataSource']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Updates the status of an existing data source.
     * @summary Update data source status
     * @param {string} dataSourceId The ID of the data source.
     * @param {DataSourcePatchStatusRequest} [dataSourcePatchStatusRequest] PatchDataSourceStatus
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchDataSourceStatus(
      dataSourceId: string,
      dataSourcePatchStatusRequest?: DataSourcePatchStatusRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PatchDataSourceStatusResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.patchDataSourceStatus(
          dataSourceId,
          dataSourcePatchStatusRequest,
          options
        );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['DataSourcesApi.patchDataSourceStatus']?.[index]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Creates a new data source.
     * @summary Create data source
     * @param {DataSource} [dataSource] PostDataSource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postDataSource(
      dataSource?: DataSource,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<DataSourceCreationResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.postDataSource(
        dataSource,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['DataSourcesApi.postDataSource']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Adds a new transformation template to a data source. Template is a contributors-defined configuration object that describes how to interact with a specific third-party service\'s API, allowing developers to easily connect to and interact with a variety of sources, as well as customising the connector\'s behaviour.
     * @summary Create data source transformation template
     * @param {string} dataSourceId The ID of the datasource for the transformation template.
     * @param {CreateTransformationTemplateRequest} [createTransformationTemplateRequest] PostDataSourceTransformationTemplate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postDataSourceTransformationTemplate(
      dataSourceId: string,
      createTransformationTemplateRequest?: CreateTransformationTemplateRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GenericResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postDataSourceTransformationTemplate(
          dataSourceId,
          createTransformationTemplateRequest,
          options
        );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap[
          'DataSourcesApi.postDataSourceTransformationTemplate'
        ]?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
  };
};

/**
 * DataSourcesApi - factory interface
 * @export
 */
export const DataSourcesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = DataSourcesApiFp(configuration);
  return {
    /**
     * Deletes an existing data source.
     * @summary Delete data source
     * @param {string} dataSourceId The ID of the data source.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteDataSource(dataSourceId: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteDataSource(dataSourceId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Fetches a list of available data sources.
     * @summary List data source
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataSource(options?: any): AxiosPromise<DataSourceResponse> {
      return localVarFp
        .getDataSource(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Fetches a data source by the ID passed
     * @summary Gets a data source by it\'s ID
     * @param {string} dataSourceId The ID of the data source.
     * @param {boolean} [validationResult]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDataSourceById(
      dataSourceId: string,
      validationResult?: boolean,
      options?: any
    ): AxiosPromise<GetDataSourcebyIdResponse> {
      return localVarFp
        .getDataSourceById(dataSourceId, validationResult, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Updates the endpoint configuration of an existing datasource.
     * @summary Update data source
     * @param {string} dataSourceId The ID of the data source.
     * @param {DataSourcePatchRequest} [dataSourcePatchRequest] PatchDataSource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchDataSource(
      dataSourceId: string,
      dataSourcePatchRequest?: DataSourcePatchRequest,
      options?: any
    ): AxiosPromise<DataSource> {
      return localVarFp
        .patchDataSource(dataSourceId, dataSourcePatchRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Updates the status of an existing data source.
     * @summary Update data source status
     * @param {string} dataSourceId The ID of the data source.
     * @param {DataSourcePatchStatusRequest} [dataSourcePatchStatusRequest] PatchDataSourceStatus
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchDataSourceStatus(
      dataSourceId: string,
      dataSourcePatchStatusRequest?: DataSourcePatchStatusRequest,
      options?: any
    ): AxiosPromise<PatchDataSourceStatusResponse> {
      return localVarFp
        .patchDataSourceStatus(
          dataSourceId,
          dataSourcePatchStatusRequest,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Creates a new data source.
     * @summary Create data source
     * @param {DataSource} [dataSource] PostDataSource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postDataSource(
      dataSource?: DataSource,
      options?: any
    ): AxiosPromise<DataSourceCreationResponse> {
      return localVarFp
        .postDataSource(dataSource, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Adds a new transformation template to a data source. Template is a contributors-defined configuration object that describes how to interact with a specific third-party service\'s API, allowing developers to easily connect to and interact with a variety of sources, as well as customising the connector\'s behaviour.
     * @summary Create data source transformation template
     * @param {string} dataSourceId The ID of the datasource for the transformation template.
     * @param {CreateTransformationTemplateRequest} [createTransformationTemplateRequest] PostDataSourceTransformationTemplate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postDataSourceTransformationTemplate(
      dataSourceId: string,
      createTransformationTemplateRequest?: CreateTransformationTemplateRequest,
      options?: any
    ): AxiosPromise<GenericResponse> {
      return localVarFp
        .postDataSourceTransformationTemplate(
          dataSourceId,
          createTransformationTemplateRequest,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * DataSourcesApi - object-oriented interface
 * @export
 * @class DataSourcesApi
 * @extends {BaseAPI}
 */
export class DataSourcesApi extends BaseAPI {
  /**
   * Deletes an existing data source.
   * @summary Delete data source
   * @param {string} dataSourceId The ID of the data source.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataSourcesApi
   */
  public deleteDataSource(
    dataSourceId: string,
    options?: RawAxiosRequestConfig
  ) {
    return DataSourcesApiFp(this.configuration)
      .deleteDataSource(dataSourceId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Fetches a list of available data sources.
   * @summary List data source
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataSourcesApi
   */
  public getDataSource(options?: RawAxiosRequestConfig) {
    return DataSourcesApiFp(this.configuration)
      .getDataSource(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Fetches a data source by the ID passed
   * @summary Gets a data source by it\'s ID
   * @param {string} dataSourceId The ID of the data source.
   * @param {boolean} [validationResult]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataSourcesApi
   */
  public getDataSourceById(
    dataSourceId: string,
    validationResult?: boolean,
    options?: RawAxiosRequestConfig
  ) {
    return DataSourcesApiFp(this.configuration)
      .getDataSourceById(dataSourceId, validationResult, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Updates the endpoint configuration of an existing datasource.
   * @summary Update data source
   * @param {string} dataSourceId The ID of the data source.
   * @param {DataSourcePatchRequest} [dataSourcePatchRequest] PatchDataSource
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataSourcesApi
   */
  public patchDataSource(
    dataSourceId: string,
    dataSourcePatchRequest?: DataSourcePatchRequest,
    options?: RawAxiosRequestConfig
  ) {
    return DataSourcesApiFp(this.configuration)
      .patchDataSource(dataSourceId, dataSourcePatchRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Updates the status of an existing data source.
   * @summary Update data source status
   * @param {string} dataSourceId The ID of the data source.
   * @param {DataSourcePatchStatusRequest} [dataSourcePatchStatusRequest] PatchDataSourceStatus
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataSourcesApi
   */
  public patchDataSourceStatus(
    dataSourceId: string,
    dataSourcePatchStatusRequest?: DataSourcePatchStatusRequest,
    options?: RawAxiosRequestConfig
  ) {
    return DataSourcesApiFp(this.configuration)
      .patchDataSourceStatus(
        dataSourceId,
        dataSourcePatchStatusRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Creates a new data source.
   * @summary Create data source
   * @param {DataSource} [dataSource] PostDataSource
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataSourcesApi
   */
  public postDataSource(
    dataSource?: DataSource,
    options?: RawAxiosRequestConfig
  ) {
    return DataSourcesApiFp(this.configuration)
      .postDataSource(dataSource, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Adds a new transformation template to a data source. Template is a contributors-defined configuration object that describes how to interact with a specific third-party service\'s API, allowing developers to easily connect to and interact with a variety of sources, as well as customising the connector\'s behaviour.
   * @summary Create data source transformation template
   * @param {string} dataSourceId The ID of the datasource for the transformation template.
   * @param {CreateTransformationTemplateRequest} [createTransformationTemplateRequest] PostDataSourceTransformationTemplate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataSourcesApi
   */
  public postDataSourceTransformationTemplate(
    dataSourceId: string,
    createTransformationTemplateRequest?: CreateTransformationTemplateRequest,
    options?: RawAxiosRequestConfig
  ) {
    return DataSourcesApiFp(this.configuration)
      .postDataSourceTransformationTemplate(
        dataSourceId,
        createTransformationTemplateRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * TempApi - axios parameter creator
 * @export
 */
export const TempApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Deactivates a connection.
     * @summary Delete connection
     * @param {string} connectionId The ID of the connection to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteConnectionTemp: async (
      connectionId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'connectionId' is not null or undefined
      assertParamExists('deleteConnectionTemp', 'connectionId', connectionId);
      const localVarPath = `/v1/temp-connections/{connectionId}`.replace(
        `{${'connectionId'}}`,
        encodeURIComponent(String(connectionId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Executes a user connection on a connection.
     * @summary Create execution request
     * @param {string} connectionId The ID of the connection.
     * @param {object | null} body ExecuteConnection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeConnectionTemp: async (
      connectionId: string,
      body: object | null,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'connectionId' is not null or undefined
      assertParamExists('executeConnectionTemp', 'connectionId', connectionId);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('executeConnectionTemp', 'body', body);
      const localVarPath =
        `/v1/temp-connections/{connectionId}/execution-request`.replace(
          `{${'connectionId'}}`,
          encodeURIComponent(String(connectionId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Fetches a list of active user connections
     * @summary List active connections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActiveConnectionsTemp: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/temp-active-connections`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Fetches a list of all connectors.
     * @summary List connectors
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConnectorsTemp: async (
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/temp-connectors`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates a new user connection.
     * @summary Create connection
     * @param {ConnectionCreationRequest} connectionCreationRequest PostConnection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postConnectionTemp: async (
      connectionCreationRequest: ConnectionCreationRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'connectionCreationRequest' is not null or undefined
      assertParamExists(
        'postConnectionTemp',
        'connectionCreationRequest',
        connectionCreationRequest
      );
      const localVarPath = `/v1/connections-temp`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        connectionCreationRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TempApi - functional programming interface
 * @export
 */
export const TempApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TempApiAxiosParamCreator(configuration);
  return {
    /**
     * Deactivates a connection.
     * @summary Delete connection
     * @param {string} connectionId The ID of the connection to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteConnectionTemp(
      connectionId: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteConnectionTemp(
          connectionId,
          options
        );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['TempApi.deleteConnectionTemp']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Executes a user connection on a connection.
     * @summary Create execution request
     * @param {string} connectionId The ID of the connection.
     * @param {object | null} body ExecuteConnection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async executeConnectionTemp(
      connectionId: string,
      body: object | null,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ConnectionExecutedTempResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.executeConnectionTemp(
          connectionId,
          body,
          options
        );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['TempApi.executeConnectionTemp']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Fetches a list of active user connections
     * @summary List active connections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getActiveConnectionsTemp(
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ActiveConnectionsResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getActiveConnectionsTemp(options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['TempApi.getActiveConnectionsTemp']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Fetches a list of all connectors.
     * @summary List connectors
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getConnectorsTemp(
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ConnectorsResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getConnectorsTemp(options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['TempApi.getConnectorsTemp']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Creates a new user connection.
     * @summary Create connection
     * @param {ConnectionCreationRequest} connectionCreationRequest PostConnection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postConnectionTemp(
      connectionCreationRequest: ConnectionCreationRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ConnectionCreationResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postConnectionTemp(
          connectionCreationRequest,
          options
        );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['TempApi.postConnectionTemp']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
  };
};

/**
 * TempApi - factory interface
 * @export
 */
export const TempApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = TempApiFp(configuration);
  return {
    /**
     * Deactivates a connection.
     * @summary Delete connection
     * @param {string} connectionId The ID of the connection to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteConnectionTemp(
      connectionId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteConnectionTemp(connectionId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Executes a user connection on a connection.
     * @summary Create execution request
     * @param {string} connectionId The ID of the connection.
     * @param {object | null} body ExecuteConnection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeConnectionTemp(
      connectionId: string,
      body: object | null,
      options?: any
    ): AxiosPromise<ConnectionExecutedTempResponse> {
      return localVarFp
        .executeConnectionTemp(connectionId, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Fetches a list of active user connections
     * @summary List active connections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActiveConnectionsTemp(
      options?: any
    ): AxiosPromise<ActiveConnectionsResponse> {
      return localVarFp
        .getActiveConnectionsTemp(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Fetches a list of all connectors.
     * @summary List connectors
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConnectorsTemp(options?: any): AxiosPromise<ConnectorsResponse> {
      return localVarFp
        .getConnectorsTemp(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Creates a new user connection.
     * @summary Create connection
     * @param {ConnectionCreationRequest} connectionCreationRequest PostConnection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postConnectionTemp(
      connectionCreationRequest: ConnectionCreationRequest,
      options?: any
    ): AxiosPromise<ConnectionCreationResponse> {
      return localVarFp
        .postConnectionTemp(connectionCreationRequest, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * TempApi - object-oriented interface
 * @export
 * @class TempApi
 * @extends {BaseAPI}
 */
export class TempApi extends BaseAPI {
  /**
   * Deactivates a connection.
   * @summary Delete connection
   * @param {string} connectionId The ID of the connection to be deleted.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TempApi
   */
  public deleteConnectionTemp(
    connectionId: string,
    options?: RawAxiosRequestConfig
  ) {
    return TempApiFp(this.configuration)
      .deleteConnectionTemp(connectionId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Executes a user connection on a connection.
   * @summary Create execution request
   * @param {string} connectionId The ID of the connection.
   * @param {object | null} body ExecuteConnection
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TempApi
   */
  public executeConnectionTemp(
    connectionId: string,
    body: object | null,
    options?: RawAxiosRequestConfig
  ) {
    return TempApiFp(this.configuration)
      .executeConnectionTemp(connectionId, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Fetches a list of active user connections
   * @summary List active connections
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TempApi
   */
  public getActiveConnectionsTemp(options?: RawAxiosRequestConfig) {
    return TempApiFp(this.configuration)
      .getActiveConnectionsTemp(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Fetches a list of all connectors.
   * @summary List connectors
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TempApi
   */
  public getConnectorsTemp(options?: RawAxiosRequestConfig) {
    return TempApiFp(this.configuration)
      .getConnectorsTemp(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Creates a new user connection.
   * @summary Create connection
   * @param {ConnectionCreationRequest} connectionCreationRequest PostConnection
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TempApi
   */
  public postConnectionTemp(
    connectionCreationRequest: ConnectionCreationRequest,
    options?: RawAxiosRequestConfig
  ) {
    return TempApiFp(this.configuration)
      .postConnectionTemp(connectionCreationRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
