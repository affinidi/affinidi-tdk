import { v4 as uuidv4 } from 'uuid'
import { Jwt, ProjectScopedToken, Iota } from './helpers'
import { EnvironmentUtils } from '@affinidi-tdk/common'

export interface IotaTokenOutput {
  readonly iotaJwt: string
  readonly iotaSessionId: string
}

export interface IAuthProviderParams {
  apiGatewayUrl: string
  keyId: string
  tokenId: string
  passphrase: string
  privateKey: string
  projectId: string
  tokenEndpoint: string
}

export class AuthProvider {
  // NOTE: publicKey to validate projectScopedToken generated by Affinidi,
  //       need to fetch from Affinidi service
  private publicKey: string = ''
  private projectScopedToken = ''
  private readonly apiGatewayUrl: string = ''
  private readonly keyId: string = ''
  private readonly tokenId: string = ''
  private readonly passphrase: string = ''
  private readonly privateKey: string = ''
  private readonly projectId: string = ''
  private readonly tokenEndpoint: string = ''
  private readonly projectScopedTokenInstance: ProjectScopedToken
  private readonly jwt: Jwt
  private readonly iotaInstance: Iota

  constructor(param: { [key: string]: string }) {
    const authProviderParams: IAuthProviderParams = {
      apiGatewayUrl: '',
      keyId: '',
      tokenId: '',
      passphrase: '',
      privateKey: '',
      projectId: '',
      tokenEndpoint: '',
    }

    if (!param.apiGatewayUrl) {
      param.apiGatewayUrl = EnvironmentUtils.fetchApiGwUrl()
    }

    if (!param.tokenEndpoint) {
      param.tokenEndpoint = EnvironmentUtils.fetchElementsAuthTokenUrl()
    }

    this.validateMissingInput(authProviderParams, param)

    this.apiGatewayUrl = param.apiGatewayUrl
    this.keyId = param.keyId
    this.tokenId = param.tokenId
    this.passphrase = param.passphrase
    this.privateKey = param.privateKey
    this.projectId = param.projectId
    this.tokenEndpoint = param.tokenEndpoint

    this.projectScopedTokenInstance = new ProjectScopedToken()
    this.jwt = new Jwt()
    this.iotaInstance = new Iota()
  }

  private validateMissingInput<T>(interfaceType: T, input: any): void {
    const missingFields: string[] = []

    const keys = Object.keys(interfaceType as object) as Array<keyof T>
    keys.forEach((key) => !input[key] && missingFields.push(key as string))

    if (missingFields.length > 0) {
      throw new Error(`Required fields missing: ${missingFields.join(', ')}`)
    }
  }

  private async shouldRefreshToken(): Promise<boolean> {
    if (!this.publicKey) {
      this.publicKey = await this.jwt.fetchPublicKey(this.apiGatewayUrl)
    }

    const itExistsAndExpired =
      !!this.projectScopedToken &&
      this.jwt.validateToken(this.projectScopedToken, this.publicKey).isExpired

    return !this.projectScopedToken || itExistsAndExpired
  }

  public async fetchProjectScopedToken(): Promise<string> {
    const shouldRefreshToken = await this.shouldRefreshToken()

    if (shouldRefreshToken) {
      this.projectScopedToken =
        await this.projectScopedTokenInstance.fetchProjectScopedToken({
          apiGatewayUrl: this.apiGatewayUrl,
          keyId: this.keyId,
          tokenId: this.tokenId,
          passphrase: this.passphrase,
          privateKey: this.privateKey,
          projectId: this.projectId,
          audience: this.tokenEndpoint,
        })
    }

    return this.projectScopedToken
  }

  public createIotaToken(
    iotaConfigId: string,
    did: string,
    iotaSessionId?: string,
  ): IotaTokenOutput {
    const sessionId = iotaSessionId ?? uuidv4()

    return {
      iotaJwt: this.iotaInstance.signIotaJwt(
        this.projectId,
        iotaConfigId,
        sessionId,
        {
          keyId: this.keyId,
          tokenId: `token/${this.tokenId}`,
          passphrase: this.passphrase,
          privateKey: this.privateKey,
          audience: did,
        },
      ),
      iotaSessionId: sessionId,
    }
  }
}
